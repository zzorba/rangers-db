import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  _text: { input: any; output: any; }
  bigint: { input: any; output: any; }
  float8: { input: any; output: any; }
  json: { input: any; output: any; }
  jsonb: { input: any; output: any; }
  timestamp: { input: any; output: any; }
  timestamptz: { input: any; output: any; }
  uuid: { input: any; output: any; }
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Boolean']['input']>;
  _gt?: InputMaybe<Scalars['Boolean']['input']>;
  _gte?: InputMaybe<Scalars['Boolean']['input']>;
  _in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Boolean']['input']>;
  _lte?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Scalars['Boolean']['input']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export type CreateCampaignInput = {
  campaignId: Scalars['String']['input'];
  guided?: InputMaybe<Scalars['Boolean']['input']>;
  linked?: InputMaybe<LinkedCampaignId>;
};

export type CreateCampaignOutput = {
  __typename?: 'CreateCampaignOutput';
  campaignId: Scalars['Int']['output'];
  campaignIdA?: Maybe<Scalars['Int']['output']>;
  campaignIdB?: Maybe<Scalars['Int']['output']>;
};

export type CreateDeckInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  ignoreDeckLimitSlots: Scalars['jsonb']['input'];
  investigator: Scalars['String']['input'];
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name: Scalars['String']['input'];
  problem?: InputMaybe<Scalars['String']['input']>;
  slots: Scalars['jsonb']['input'];
  tabooSetId?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
};

export type CreateDeckOutput = {
  __typename?: 'CreateDeckOutput';
  deck?: Maybe<Arkhamdb_Deck>;
  deckId: Scalars['String']['output'];
};

export type DeckId = {
  __typename?: 'DeckId';
  campaignId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
};

export type DeleteCampaignInput = {
  campaignId: Scalars['String']['input'];
  serverId: Scalars['Int']['input'];
};

export type DeleteCampaignOutput = {
  __typename?: 'DeleteCampaignOutput';
  campaignId: Scalars['Int']['output'];
};

export type DeleteDeckInput = {
  deckId: Scalars['Int']['input'];
  deleteAllVersions: Scalars['Boolean']['input'];
};

export type DeleteDeckOutput = {
  __typename?: 'DeleteDeckOutput';
  success: Scalars['Boolean']['output'];
};

export enum EditAccessAction {
  Grant = 'grant',
  Revoke = 'revoke'
}

export type EditCampaignAccessInput = {
  action: EditAccessAction;
  campaignId: Scalars['String']['input'];
  serverId: Scalars['Int']['input'];
  users: Array<Scalars['String']['input']>;
};

export type EditCampaignAccessOutput = {
  __typename?: 'EditCampaignAccessOutput';
  campaignId: Scalars['Int']['output'];
};

export enum FriendRequestAction {
  Request = 'request',
  Revoke = 'revoke'
}

export type FriendRequestInput = {
  action: FriendRequestAction;
  userId: Scalars['String']['input'];
};

export type FriendRequestOutput = {
  __typename?: 'FriendRequestOutput';
  success: Scalars['Boolean']['output'];
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type LinkedCampaignId = {
  campaignIdA: Scalars['String']['input'];
  campaignIdB: Scalars['String']['input'];
};

export type LoginInput = {
  code: Scalars['String']['input'];
  redirectUri: Scalars['String']['input'];
  state: Scalars['String']['input'];
};

export type LoginOutput = {
  __typename?: 'LoginOutput';
  success: Scalars['Boolean']['output'];
};

export type LogoutOutput = {
  __typename?: 'LogoutOutput';
  success: Scalars['Boolean']['output'];
};

export type MigrateLoginInput = {
  accessToken: Scalars['String']['input'];
  refreshToken: Scalars['String']['input'];
};

export type MigrateLoginOutput = {
  __typename?: 'MigrateLoginOutput';
  success: Scalars['Boolean']['output'];
};

export type RefreshDecksInput = {
  force: Scalars['Boolean']['input'];
};

export type RefreshDecksOutput = {
  __typename?: 'RefreshDecksOutput';
  updated: Scalars['Boolean']['output'];
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']['input']>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateHandleInput = {
  handle: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateHandleOutput = {
  __typename?: 'UpdateHandleOutput';
  success: Scalars['Boolean']['output'];
  user?: Maybe<Users>;
  userId: Scalars['String']['output'];
};

export type UpgradeDeckInput = {
  deckId: Scalars['Int']['input'];
  exiles?: InputMaybe<Scalars['jsonb']['input']>;
  xp: Scalars['Int']['input'];
};

export type UpgradeDeckOutput = {
  __typename?: 'UpgradeDeckOutput';
  deckId: Scalars['Int']['output'];
  upgradedDeckId: Scalars['Int']['output'];
};

export type UploadLocalCampaignDeckInput = {
  arkhamDbId: Scalars['Int']['input'];
  localDeckId: Scalars['String']['input'];
};

export type UploadLocalCampaignDeckOutput = {
  __typename?: 'UploadLocalCampaignDeckOutput';
  deckIds: Array<DeckId>;
};

export type UserSearchResult = {
  __typename?: 'UserSearchResult';
  handle: Scalars['String']['output'];
  id: Scalars['String']['output'];
};

export type UsersSearchInput = {
  continueToken?: InputMaybe<Scalars['String']['input']>;
  search: Scalars['String']['input'];
};

export type UsersSearchOutput = {
  __typename?: 'UsersSearchOutput';
  hasMore: Scalars['String']['output'];
  users: Array<UserSearchResult>;
};

/** columns and relationships of "all_card" */
export type All_Card = {
  __typename?: 'all_card';
  alt_art_investigator?: Maybe<Scalars['Boolean']['output']>;
  alternate_of_code?: Maybe<Scalars['String']['output']>;
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_illustrator?: Maybe<Scalars['String']['output']>;
  back_link_id?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  backimageurl?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  clues_fixed?: Maybe<Scalars['Boolean']['output']>;
  code: Scalars['String']['output'];
  cost?: Maybe<Scalars['Int']['output']>;
  customization_options?: Maybe<Scalars['jsonb']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  deck_options?: Maybe<Scalars['jsonb']['output']>;
  deck_requirements?: Maybe<Scalars['jsonb']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  double_sided?: Maybe<Scalars['Boolean']['output']>;
  duplicate_of_code?: Maybe<Scalars['String']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  encounter_sets: Array<Card_Encounter_Set>;
  /** An aggregate relationship */
  encounter_sets_aggregate: Card_Encounter_Set_Aggregate;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  errata_date?: Maybe<Scalars['String']['output']>;
  exceptional?: Maybe<Scalars['Boolean']['output']>;
  exile?: Maybe<Scalars['Boolean']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code: Scalars['String']['output'];
  gender?: Maybe<Gender_Enum>;
  heals_damage?: Maybe<Scalars['Boolean']['output']>;
  heals_horror?: Maybe<Scalars['Boolean']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  health_per_investigator?: Maybe<Scalars['Boolean']['output']>;
  hidden?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['String']['output'];
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  imageurl?: Maybe<Scalars['String']['output']>;
  is_unique?: Maybe<Scalars['Boolean']['output']>;
  linked?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  linked_card?: Maybe<All_Card>;
  myriad?: Maybe<Scalars['Boolean']['output']>;
  official: Scalars['Boolean']['output'];
  /** An object relationship */
  pack: Pack;
  pack_code: Scalars['String']['output'];
  pack_position: Scalars['Int']['output'];
  /** An array relationship */
  packs: Array<Card_Pack>;
  /** An aggregate relationship */
  packs_aggregate: Card_Pack_Aggregate;
  permanent?: Maybe<Scalars['Boolean']['output']>;
  position: Scalars['Int']['output'];
  preview?: Maybe<Scalars['Boolean']['output']>;
  quantity: Scalars['Int']['output'];
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_customization_change?: Maybe<Scalars['String']['output']>;
  real_customization_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name: Scalars['String']['output'];
  real_pack_name: Scalars['String']['output'];
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  real_taboo_original_text?: Maybe<Scalars['String']['output']>;
  real_taboo_text_change?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  restrictions?: Maybe<Scalars['jsonb']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  side_deck_options?: Maybe<Scalars['jsonb']['output']>;
  side_deck_requirements?: Maybe<Scalars['jsonb']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  spoiler?: Maybe<Scalars['Boolean']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  taboo_placeholder?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  taboo_set?: Maybe<Taboo_Set>;
  taboo_set_id?: Maybe<Scalars['Int']['output']>;
  taboo_xp?: Maybe<Scalars['Int']['output']>;
  tags?: Maybe<Scalars['jsonb']['output']>;
  /** An array relationship */
  translations: Array<All_Card_Text>;
  /** An aggregate relationship */
  translations_aggregate: All_Card_Text_Aggregate;
  /** An object relationship */
  type: Card_Type_Code;
  type_code: Card_Type_Code_Enum;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version: Scalars['Int']['output'];
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "all_card" */
export type All_CardCustomization_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardDeck_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardDeck_RequirementsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardEncounter_SetsArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


/** columns and relationships of "all_card" */
export type All_CardEncounter_Sets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


/** columns and relationships of "all_card" */
export type All_CardPacksArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "all_card" */
export type All_CardPacks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "all_card" */
export type All_CardRestrictionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardSide_Deck_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardSide_Deck_RequirementsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardTranslationsArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


/** columns and relationships of "all_card" */
export type All_CardTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};

/** aggregated selection of "all_card" */
export type All_Card_Aggregate = {
  __typename?: 'all_card_aggregate';
  aggregate?: Maybe<All_Card_Aggregate_Fields>;
  nodes: Array<All_Card>;
};

export type All_Card_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<All_Card_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<All_Card_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<All_Card_Aggregate_Bool_Exp_Count>;
};

export type All_Card_Aggregate_Bool_Exp_Bool_And = {
  arguments: All_Card_Select_Column_All_Card_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<All_Card_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type All_Card_Aggregate_Bool_Exp_Bool_Or = {
  arguments: All_Card_Select_Column_All_Card_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<All_Card_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type All_Card_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<All_Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<All_Card_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "all_card" */
export type All_Card_Aggregate_Fields = {
  __typename?: 'all_card_aggregate_fields';
  avg?: Maybe<All_Card_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<All_Card_Max_Fields>;
  min?: Maybe<All_Card_Min_Fields>;
  stddev?: Maybe<All_Card_Stddev_Fields>;
  stddev_pop?: Maybe<All_Card_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<All_Card_Stddev_Samp_Fields>;
  sum?: Maybe<All_Card_Sum_Fields>;
  var_pop?: Maybe<All_Card_Var_Pop_Fields>;
  var_samp?: Maybe<All_Card_Var_Samp_Fields>;
  variance?: Maybe<All_Card_Variance_Fields>;
};


/** aggregate fields of "all_card" */
export type All_Card_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<All_Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "all_card" */
export type All_Card_Aggregate_Order_By = {
  avg?: InputMaybe<All_Card_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<All_Card_Max_Order_By>;
  min?: InputMaybe<All_Card_Min_Order_By>;
  stddev?: InputMaybe<All_Card_Stddev_Order_By>;
  stddev_pop?: InputMaybe<All_Card_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<All_Card_Stddev_Samp_Order_By>;
  sum?: InputMaybe<All_Card_Sum_Order_By>;
  var_pop?: InputMaybe<All_Card_Var_Pop_Order_By>;
  var_samp?: InputMaybe<All_Card_Var_Samp_Order_By>;
  variance?: InputMaybe<All_Card_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type All_Card_Append_Input = {
  customization_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "all_card" */
export type All_Card_Arr_Rel_Insert_Input = {
  data: Array<All_Card_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<All_Card_On_Conflict>;
};

/** aggregate avg on columns */
export type All_Card_Avg_Fields = {
  __typename?: 'all_card_avg_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "all_card" */
export type All_Card_Avg_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "all_card". All fields are combined with a logical 'AND'. */
export type All_Card_Bool_Exp = {
  _and?: InputMaybe<Array<All_Card_Bool_Exp>>;
  _not?: InputMaybe<All_Card_Bool_Exp>;
  _or?: InputMaybe<Array<All_Card_Bool_Exp>>;
  alt_art_investigator?: InputMaybe<Boolean_Comparison_Exp>;
  alternate_of_code?: InputMaybe<String_Comparison_Exp>;
  alternate_required_code?: InputMaybe<String_Comparison_Exp>;
  back_illustrator?: InputMaybe<String_Comparison_Exp>;
  back_link_id?: InputMaybe<String_Comparison_Exp>;
  backimagesrc?: InputMaybe<String_Comparison_Exp>;
  backimageurl?: InputMaybe<String_Comparison_Exp>;
  clues?: InputMaybe<Int_Comparison_Exp>;
  clues_fixed?: InputMaybe<Boolean_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  customization_options?: InputMaybe<Jsonb_Comparison_Exp>;
  deck_limit?: InputMaybe<Int_Comparison_Exp>;
  deck_options?: InputMaybe<Jsonb_Comparison_Exp>;
  deck_requirements?: InputMaybe<Jsonb_Comparison_Exp>;
  doom?: InputMaybe<Int_Comparison_Exp>;
  double_sided?: InputMaybe<Boolean_Comparison_Exp>;
  duplicate_of_code?: InputMaybe<String_Comparison_Exp>;
  encounter_code?: InputMaybe<String_Comparison_Exp>;
  encounter_position?: InputMaybe<Int_Comparison_Exp>;
  encounter_sets?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  encounter_sets_aggregate?: InputMaybe<Card_Encounter_Set_Aggregate_Bool_Exp>;
  enemy_damage?: InputMaybe<Int_Comparison_Exp>;
  enemy_evade?: InputMaybe<Int_Comparison_Exp>;
  enemy_fight?: InputMaybe<Int_Comparison_Exp>;
  enemy_horror?: InputMaybe<Int_Comparison_Exp>;
  errata_date?: InputMaybe<String_Comparison_Exp>;
  exceptional?: InputMaybe<Boolean_Comparison_Exp>;
  exile?: InputMaybe<Boolean_Comparison_Exp>;
  faction2_code?: InputMaybe<String_Comparison_Exp>;
  faction3_code?: InputMaybe<String_Comparison_Exp>;
  faction_code?: InputMaybe<String_Comparison_Exp>;
  gender?: InputMaybe<Gender_Enum_Comparison_Exp>;
  heals_damage?: InputMaybe<Boolean_Comparison_Exp>;
  heals_horror?: InputMaybe<Boolean_Comparison_Exp>;
  health?: InputMaybe<Int_Comparison_Exp>;
  health_per_investigator?: InputMaybe<Boolean_Comparison_Exp>;
  hidden?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  imageurl?: InputMaybe<String_Comparison_Exp>;
  is_unique?: InputMaybe<Boolean_Comparison_Exp>;
  linked?: InputMaybe<Boolean_Comparison_Exp>;
  linked_card?: InputMaybe<All_Card_Bool_Exp>;
  myriad?: InputMaybe<Boolean_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
  pack?: InputMaybe<Pack_Bool_Exp>;
  pack_code?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  packs?: InputMaybe<Card_Pack_Bool_Exp>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Bool_Exp>;
  permanent?: InputMaybe<Boolean_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  preview?: InputMaybe<Boolean_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  real_back_flavor?: InputMaybe<String_Comparison_Exp>;
  real_back_name?: InputMaybe<String_Comparison_Exp>;
  real_back_text?: InputMaybe<String_Comparison_Exp>;
  real_back_traits?: InputMaybe<String_Comparison_Exp>;
  real_customization_change?: InputMaybe<String_Comparison_Exp>;
  real_customization_text?: InputMaybe<String_Comparison_Exp>;
  real_encounter_set_name?: InputMaybe<String_Comparison_Exp>;
  real_flavor?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_pack_name?: InputMaybe<String_Comparison_Exp>;
  real_slot?: InputMaybe<String_Comparison_Exp>;
  real_subname?: InputMaybe<String_Comparison_Exp>;
  real_taboo_original_back_text?: InputMaybe<String_Comparison_Exp>;
  real_taboo_original_text?: InputMaybe<String_Comparison_Exp>;
  real_taboo_text_change?: InputMaybe<String_Comparison_Exp>;
  real_text?: InputMaybe<String_Comparison_Exp>;
  real_traits?: InputMaybe<String_Comparison_Exp>;
  restrictions?: InputMaybe<Jsonb_Comparison_Exp>;
  sanity?: InputMaybe<Int_Comparison_Exp>;
  shroud?: InputMaybe<Int_Comparison_Exp>;
  side_deck_options?: InputMaybe<Jsonb_Comparison_Exp>;
  side_deck_requirements?: InputMaybe<Jsonb_Comparison_Exp>;
  skill_agility?: InputMaybe<Int_Comparison_Exp>;
  skill_combat?: InputMaybe<Int_Comparison_Exp>;
  skill_intellect?: InputMaybe<Int_Comparison_Exp>;
  skill_wild?: InputMaybe<Int_Comparison_Exp>;
  skill_willpower?: InputMaybe<Int_Comparison_Exp>;
  spoiler?: InputMaybe<Boolean_Comparison_Exp>;
  stage?: InputMaybe<Int_Comparison_Exp>;
  subtype_code?: InputMaybe<String_Comparison_Exp>;
  taboo_placeholder?: InputMaybe<Boolean_Comparison_Exp>;
  taboo_set?: InputMaybe<Taboo_Set_Bool_Exp>;
  taboo_set_id?: InputMaybe<Int_Comparison_Exp>;
  taboo_xp?: InputMaybe<Int_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  translations?: InputMaybe<All_Card_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<All_Card_Text_Aggregate_Bool_Exp>;
  type?: InputMaybe<Card_Type_Code_Bool_Exp>;
  type_code?: InputMaybe<Card_Type_Code_Enum_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  vengeance?: InputMaybe<Int_Comparison_Exp>;
  version?: InputMaybe<Int_Comparison_Exp>;
  victory?: InputMaybe<Int_Comparison_Exp>;
  xp?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "all_card" */
export enum All_Card_Constraint {
  /** unique or primary key constraint on columns "id" */
  AllCardIdKey = 'all_card_id_key',
  /** unique or primary key constraint on columns "id" */
  AllCardPkey = 'all_card_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type All_Card_Delete_At_Path_Input = {
  customization_options?: InputMaybe<Array<Scalars['String']['input']>>;
  deck_options?: InputMaybe<Array<Scalars['String']['input']>>;
  deck_requirements?: InputMaybe<Array<Scalars['String']['input']>>;
  restrictions?: InputMaybe<Array<Scalars['String']['input']>>;
  side_deck_options?: InputMaybe<Array<Scalars['String']['input']>>;
  side_deck_requirements?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type All_Card_Delete_Elem_Input = {
  customization_options?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['Int']['input']>;
  deck_requirements?: InputMaybe<Scalars['Int']['input']>;
  restrictions?: InputMaybe<Scalars['Int']['input']>;
  side_deck_options?: InputMaybe<Scalars['Int']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type All_Card_Delete_Key_Input = {
  customization_options?: InputMaybe<Scalars['String']['input']>;
  deck_options?: InputMaybe<Scalars['String']['input']>;
  deck_requirements?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['String']['input']>;
  side_deck_options?: InputMaybe<Scalars['String']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "all_card" */
export type All_Card_Inc_Input = {
  clues?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  taboo_set_id?: InputMaybe<Scalars['Int']['input']>;
  taboo_xp?: InputMaybe<Scalars['Int']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "all_card" */
export type All_Card_Insert_Input = {
  alt_art_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  alternate_of_code?: InputMaybe<Scalars['String']['input']>;
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_illustrator?: InputMaybe<Scalars['String']['input']>;
  back_link_id?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  backimageurl?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  customization_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  duplicate_of_code?: InputMaybe<Scalars['String']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  encounter_sets?: InputMaybe<Card_Encounter_Set_Arr_Rel_Insert_Input>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  errata_date?: InputMaybe<Scalars['String']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Gender_Enum>;
  heals_damage?: InputMaybe<Scalars['Boolean']['input']>;
  heals_horror?: InputMaybe<Scalars['Boolean']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  imageurl?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  linked?: InputMaybe<Scalars['Boolean']['input']>;
  linked_card?: InputMaybe<All_Card_Obj_Rel_Insert_Input>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  pack?: InputMaybe<Pack_Obj_Rel_Insert_Input>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  packs?: InputMaybe<Card_Pack_Arr_Rel_Insert_Input>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preview?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_back_traits?: InputMaybe<Scalars['String']['input']>;
  real_customization_change?: InputMaybe<Scalars['String']['input']>;
  real_customization_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  side_deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  taboo_placeholder?: InputMaybe<Scalars['Boolean']['input']>;
  taboo_set?: InputMaybe<Taboo_Set_Obj_Rel_Insert_Input>;
  taboo_set_id?: InputMaybe<Scalars['Int']['input']>;
  taboo_xp?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  translations?: InputMaybe<All_Card_Text_Arr_Rel_Insert_Input>;
  type?: InputMaybe<Card_Type_Code_Obj_Rel_Insert_Input>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type All_Card_Max_Fields = {
  __typename?: 'all_card_max_fields';
  alternate_of_code?: Maybe<Scalars['String']['output']>;
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_illustrator?: Maybe<Scalars['String']['output']>;
  back_link_id?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  backimageurl?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  duplicate_of_code?: Maybe<Scalars['String']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  errata_date?: Maybe<Scalars['String']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  imageurl?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_customization_change?: Maybe<Scalars['String']['output']>;
  real_customization_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  real_taboo_original_text?: Maybe<Scalars['String']['output']>;
  real_taboo_text_change?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  taboo_set_id?: Maybe<Scalars['Int']['output']>;
  taboo_xp?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "all_card" */
export type All_Card_Max_Order_By = {
  alternate_of_code?: InputMaybe<Order_By>;
  alternate_required_code?: InputMaybe<Order_By>;
  back_illustrator?: InputMaybe<Order_By>;
  back_link_id?: InputMaybe<Order_By>;
  backimagesrc?: InputMaybe<Order_By>;
  backimageurl?: InputMaybe<Order_By>;
  clues?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  duplicate_of_code?: InputMaybe<Order_By>;
  encounter_code?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  errata_date?: InputMaybe<Order_By>;
  faction2_code?: InputMaybe<Order_By>;
  faction3_code?: InputMaybe<Order_By>;
  faction_code?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  imageurl?: InputMaybe<Order_By>;
  pack_code?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_name?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_back_traits?: InputMaybe<Order_By>;
  real_customization_change?: InputMaybe<Order_By>;
  real_customization_text?: InputMaybe<Order_By>;
  real_encounter_set_name?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_pack_name?: InputMaybe<Order_By>;
  real_slot?: InputMaybe<Order_By>;
  real_subname?: InputMaybe<Order_By>;
  real_taboo_original_back_text?: InputMaybe<Order_By>;
  real_taboo_original_text?: InputMaybe<Order_By>;
  real_taboo_text_change?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  subtype_code?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type All_Card_Min_Fields = {
  __typename?: 'all_card_min_fields';
  alternate_of_code?: Maybe<Scalars['String']['output']>;
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_illustrator?: Maybe<Scalars['String']['output']>;
  back_link_id?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  backimageurl?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  duplicate_of_code?: Maybe<Scalars['String']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  errata_date?: Maybe<Scalars['String']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  imageurl?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_customization_change?: Maybe<Scalars['String']['output']>;
  real_customization_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  real_taboo_original_text?: Maybe<Scalars['String']['output']>;
  real_taboo_text_change?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  taboo_set_id?: Maybe<Scalars['Int']['output']>;
  taboo_xp?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "all_card" */
export type All_Card_Min_Order_By = {
  alternate_of_code?: InputMaybe<Order_By>;
  alternate_required_code?: InputMaybe<Order_By>;
  back_illustrator?: InputMaybe<Order_By>;
  back_link_id?: InputMaybe<Order_By>;
  backimagesrc?: InputMaybe<Order_By>;
  backimageurl?: InputMaybe<Order_By>;
  clues?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  duplicate_of_code?: InputMaybe<Order_By>;
  encounter_code?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  errata_date?: InputMaybe<Order_By>;
  faction2_code?: InputMaybe<Order_By>;
  faction3_code?: InputMaybe<Order_By>;
  faction_code?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  imageurl?: InputMaybe<Order_By>;
  pack_code?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_name?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_back_traits?: InputMaybe<Order_By>;
  real_customization_change?: InputMaybe<Order_By>;
  real_customization_text?: InputMaybe<Order_By>;
  real_encounter_set_name?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_pack_name?: InputMaybe<Order_By>;
  real_slot?: InputMaybe<Order_By>;
  real_subname?: InputMaybe<Order_By>;
  real_taboo_original_back_text?: InputMaybe<Order_By>;
  real_taboo_original_text?: InputMaybe<Order_By>;
  real_taboo_text_change?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  subtype_code?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "all_card" */
export type All_Card_Mutation_Response = {
  __typename?: 'all_card_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<All_Card>;
};

/** input type for inserting object relation for remote table "all_card" */
export type All_Card_Obj_Rel_Insert_Input = {
  data: All_Card_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<All_Card_On_Conflict>;
};

/** on_conflict condition type for table "all_card" */
export type All_Card_On_Conflict = {
  constraint: All_Card_Constraint;
  update_columns?: Array<All_Card_Update_Column>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};

/** Ordering options when selecting data from "all_card". */
export type All_Card_Order_By = {
  alt_art_investigator?: InputMaybe<Order_By>;
  alternate_of_code?: InputMaybe<Order_By>;
  alternate_required_code?: InputMaybe<Order_By>;
  back_illustrator?: InputMaybe<Order_By>;
  back_link_id?: InputMaybe<Order_By>;
  backimagesrc?: InputMaybe<Order_By>;
  backimageurl?: InputMaybe<Order_By>;
  clues?: InputMaybe<Order_By>;
  clues_fixed?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  customization_options?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  deck_options?: InputMaybe<Order_By>;
  deck_requirements?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  double_sided?: InputMaybe<Order_By>;
  duplicate_of_code?: InputMaybe<Order_By>;
  encounter_code?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  encounter_sets_aggregate?: InputMaybe<Card_Encounter_Set_Aggregate_Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  errata_date?: InputMaybe<Order_By>;
  exceptional?: InputMaybe<Order_By>;
  exile?: InputMaybe<Order_By>;
  faction2_code?: InputMaybe<Order_By>;
  faction3_code?: InputMaybe<Order_By>;
  faction_code?: InputMaybe<Order_By>;
  gender?: InputMaybe<Order_By>;
  heals_damage?: InputMaybe<Order_By>;
  heals_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  health_per_investigator?: InputMaybe<Order_By>;
  hidden?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  imageurl?: InputMaybe<Order_By>;
  is_unique?: InputMaybe<Order_By>;
  linked?: InputMaybe<Order_By>;
  linked_card?: InputMaybe<All_Card_Order_By>;
  myriad?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
  pack?: InputMaybe<Pack_Order_By>;
  pack_code?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Order_By>;
  permanent?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  preview?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_name?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_back_traits?: InputMaybe<Order_By>;
  real_customization_change?: InputMaybe<Order_By>;
  real_customization_text?: InputMaybe<Order_By>;
  real_encounter_set_name?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_pack_name?: InputMaybe<Order_By>;
  real_slot?: InputMaybe<Order_By>;
  real_subname?: InputMaybe<Order_By>;
  real_taboo_original_back_text?: InputMaybe<Order_By>;
  real_taboo_original_text?: InputMaybe<Order_By>;
  real_taboo_text_change?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  restrictions?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  side_deck_options?: InputMaybe<Order_By>;
  side_deck_requirements?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  spoiler?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  subtype_code?: InputMaybe<Order_By>;
  taboo_placeholder?: InputMaybe<Order_By>;
  taboo_set?: InputMaybe<Taboo_Set_Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<All_Card_Text_Aggregate_Order_By>;
  type?: InputMaybe<Card_Type_Code_Order_By>;
  type_code?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** primary key columns input for table: all_card */
export type All_Card_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type All_Card_Prepend_Input = {
  customization_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "all_card" */
export enum All_Card_Select_Column {
  /** column name */
  AltArtInvestigator = 'alt_art_investigator',
  /** column name */
  AlternateOfCode = 'alternate_of_code',
  /** column name */
  AlternateRequiredCode = 'alternate_required_code',
  /** column name */
  BackIllustrator = 'back_illustrator',
  /** column name */
  BackLinkId = 'back_link_id',
  /** column name */
  Backimagesrc = 'backimagesrc',
  /** column name */
  Backimageurl = 'backimageurl',
  /** column name */
  Clues = 'clues',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  CustomizationOptions = 'customization_options',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  DuplicateOfCode = 'duplicate_of_code',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  ErrataDate = 'errata_date',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  Faction2Code = 'faction2_code',
  /** column name */
  Faction3Code = 'faction3_code',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Gender = 'gender',
  /** column name */
  HealsDamage = 'heals_damage',
  /** column name */
  HealsHorror = 'heals_horror',
  /** column name */
  Health = 'health',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Imageurl = 'imageurl',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Linked = 'linked',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  Official = 'official',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Preview = 'preview',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealBackTraits = 'real_back_traits',
  /** column name */
  RealCustomizationChange = 'real_customization_change',
  /** column name */
  RealCustomizationText = 'real_customization_text',
  /** column name */
  RealEncounterSetName = 'real_encounter_set_name',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealTabooOriginalBackText = 'real_taboo_original_back_text',
  /** column name */
  RealTabooOriginalText = 'real_taboo_original_text',
  /** column name */
  RealTabooTextChange = 'real_taboo_text_change',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SideDeckOptions = 'side_deck_options',
  /** column name */
  SideDeckRequirements = 'side_deck_requirements',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TabooPlaceholder = 'taboo_placeholder',
  /** column name */
  TabooSetId = 'taboo_set_id',
  /** column name */
  TabooXp = 'taboo_xp',
  /** column name */
  Tags = 'tags',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Vengeance = 'vengeance',
  /** column name */
  Version = 'version',
  /** column name */
  Victory = 'victory',
  /** column name */
  Xp = 'xp'
}

/** select "all_card_aggregate_bool_exp_bool_and_arguments_columns" columns of table "all_card" */
export enum All_Card_Select_Column_All_Card_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  AltArtInvestigator = 'alt_art_investigator',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  HealsDamage = 'heals_damage',
  /** column name */
  HealsHorror = 'heals_horror',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Linked = 'linked',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  Official = 'official',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Preview = 'preview',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  TabooPlaceholder = 'taboo_placeholder'
}

/** select "all_card_aggregate_bool_exp_bool_or_arguments_columns" columns of table "all_card" */
export enum All_Card_Select_Column_All_Card_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  AltArtInvestigator = 'alt_art_investigator',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  HealsDamage = 'heals_damage',
  /** column name */
  HealsHorror = 'heals_horror',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Linked = 'linked',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  Official = 'official',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Preview = 'preview',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  TabooPlaceholder = 'taboo_placeholder'
}

/** input type for updating data in table "all_card" */
export type All_Card_Set_Input = {
  alt_art_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  alternate_of_code?: InputMaybe<Scalars['String']['input']>;
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_illustrator?: InputMaybe<Scalars['String']['input']>;
  back_link_id?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  backimageurl?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  customization_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  duplicate_of_code?: InputMaybe<Scalars['String']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  errata_date?: InputMaybe<Scalars['String']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Gender_Enum>;
  heals_damage?: InputMaybe<Scalars['Boolean']['input']>;
  heals_horror?: InputMaybe<Scalars['Boolean']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  imageurl?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  linked?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preview?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_back_traits?: InputMaybe<Scalars['String']['input']>;
  real_customization_change?: InputMaybe<Scalars['String']['input']>;
  real_customization_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  side_deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  taboo_placeholder?: InputMaybe<Scalars['Boolean']['input']>;
  taboo_set_id?: InputMaybe<Scalars['Int']['input']>;
  taboo_xp?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type All_Card_Stddev_Fields = {
  __typename?: 'all_card_stddev_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "all_card" */
export type All_Card_Stddev_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type All_Card_Stddev_Pop_Fields = {
  __typename?: 'all_card_stddev_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "all_card" */
export type All_Card_Stddev_Pop_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type All_Card_Stddev_Samp_Fields = {
  __typename?: 'all_card_stddev_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "all_card" */
export type All_Card_Stddev_Samp_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "all_card" */
export type All_Card_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: All_Card_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type All_Card_Stream_Cursor_Value_Input = {
  alt_art_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  alternate_of_code?: InputMaybe<Scalars['String']['input']>;
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_illustrator?: InputMaybe<Scalars['String']['input']>;
  back_link_id?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  backimageurl?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  customization_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  duplicate_of_code?: InputMaybe<Scalars['String']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  errata_date?: InputMaybe<Scalars['String']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Gender_Enum>;
  heals_damage?: InputMaybe<Scalars['Boolean']['input']>;
  heals_horror?: InputMaybe<Scalars['Boolean']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  imageurl?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  linked?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preview?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_back_traits?: InputMaybe<Scalars['String']['input']>;
  real_customization_change?: InputMaybe<Scalars['String']['input']>;
  real_customization_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  side_deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  taboo_placeholder?: InputMaybe<Scalars['Boolean']['input']>;
  taboo_set_id?: InputMaybe<Scalars['Int']['input']>;
  taboo_xp?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type All_Card_Sum_Fields = {
  __typename?: 'all_card_sum_fields';
  clues?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  taboo_set_id?: Maybe<Scalars['Int']['output']>;
  taboo_xp?: Maybe<Scalars['Int']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "all_card" */
export type All_Card_Sum_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** columns and relationships of "all_card_text" */
export type All_Card_Text = {
  __typename?: 'all_card_text';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  backimageurl?: Maybe<Scalars['String']['output']>;
  customization_change?: Maybe<Scalars['String']['output']>;
  customization_text?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  imageurl?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  taboo_original_text?: Maybe<Scalars['String']['output']>;
  taboo_text_change?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "all_card_text" */
export type All_Card_Text_Aggregate = {
  __typename?: 'all_card_text_aggregate';
  aggregate?: Maybe<All_Card_Text_Aggregate_Fields>;
  nodes: Array<All_Card_Text>;
};

export type All_Card_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<All_Card_Text_Aggregate_Bool_Exp_Count>;
};

export type All_Card_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<All_Card_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "all_card_text" */
export type All_Card_Text_Aggregate_Fields = {
  __typename?: 'all_card_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<All_Card_Text_Max_Fields>;
  min?: Maybe<All_Card_Text_Min_Fields>;
};


/** aggregate fields of "all_card_text" */
export type All_Card_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "all_card_text" */
export type All_Card_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<All_Card_Text_Max_Order_By>;
  min?: InputMaybe<All_Card_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "all_card_text" */
export type All_Card_Text_Arr_Rel_Insert_Input = {
  data: Array<All_Card_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<All_Card_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "all_card_text". All fields are combined with a logical 'AND'. */
export type All_Card_Text_Bool_Exp = {
  _and?: InputMaybe<Array<All_Card_Text_Bool_Exp>>;
  _not?: InputMaybe<All_Card_Text_Bool_Exp>;
  _or?: InputMaybe<Array<All_Card_Text_Bool_Exp>>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_name?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  back_traits?: InputMaybe<String_Comparison_Exp>;
  backimageurl?: InputMaybe<String_Comparison_Exp>;
  customization_change?: InputMaybe<String_Comparison_Exp>;
  customization_text?: InputMaybe<String_Comparison_Exp>;
  encounter_name?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  imageurl?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  slot?: InputMaybe<String_Comparison_Exp>;
  subname?: InputMaybe<String_Comparison_Exp>;
  taboo_original_back_text?: InputMaybe<String_Comparison_Exp>;
  taboo_original_text?: InputMaybe<String_Comparison_Exp>;
  taboo_text_change?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "all_card_text" */
export enum All_Card_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  AllCardTextPkey = 'all_card_text_pkey'
}

/** input type for inserting data into table "all_card_text" */
export type All_Card_Text_Insert_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  backimageurl?: InputMaybe<Scalars['String']['input']>;
  customization_change?: InputMaybe<Scalars['String']['input']>;
  customization_text?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imageurl?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type All_Card_Text_Max_Fields = {
  __typename?: 'all_card_text_max_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  backimageurl?: Maybe<Scalars['String']['output']>;
  customization_change?: Maybe<Scalars['String']['output']>;
  customization_text?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  imageurl?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  taboo_original_text?: Maybe<Scalars['String']['output']>;
  taboo_text_change?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "all_card_text" */
export type All_Card_Text_Max_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  backimageurl?: InputMaybe<Order_By>;
  customization_change?: InputMaybe<Order_By>;
  customization_text?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imageurl?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  taboo_original_back_text?: InputMaybe<Order_By>;
  taboo_original_text?: InputMaybe<Order_By>;
  taboo_text_change?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type All_Card_Text_Min_Fields = {
  __typename?: 'all_card_text_min_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  backimageurl?: Maybe<Scalars['String']['output']>;
  customization_change?: Maybe<Scalars['String']['output']>;
  customization_text?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  imageurl?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  taboo_original_text?: Maybe<Scalars['String']['output']>;
  taboo_text_change?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "all_card_text" */
export type All_Card_Text_Min_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  backimageurl?: InputMaybe<Order_By>;
  customization_change?: InputMaybe<Order_By>;
  customization_text?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imageurl?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  taboo_original_back_text?: InputMaybe<Order_By>;
  taboo_original_text?: InputMaybe<Order_By>;
  taboo_text_change?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "all_card_text" */
export type All_Card_Text_Mutation_Response = {
  __typename?: 'all_card_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<All_Card_Text>;
};

/** on_conflict condition type for table "all_card_text" */
export type All_Card_Text_On_Conflict = {
  constraint: All_Card_Text_Constraint;
  update_columns?: Array<All_Card_Text_Update_Column>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "all_card_text". */
export type All_Card_Text_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  backimageurl?: InputMaybe<Order_By>;
  customization_change?: InputMaybe<Order_By>;
  customization_text?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imageurl?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  taboo_original_back_text?: InputMaybe<Order_By>;
  taboo_original_text?: InputMaybe<Order_By>;
  taboo_text_change?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: all_card_text */
export type All_Card_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "all_card_text" */
export enum All_Card_Text_Select_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  Backimageurl = 'backimageurl',
  /** column name */
  CustomizationChange = 'customization_change',
  /** column name */
  CustomizationText = 'customization_text',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Imageurl = 'imageurl',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  TabooOriginalBackText = 'taboo_original_back_text',
  /** column name */
  TabooOriginalText = 'taboo_original_text',
  /** column name */
  TabooTextChange = 'taboo_text_change',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "all_card_text" */
export type All_Card_Text_Set_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  backimageurl?: InputMaybe<Scalars['String']['input']>;
  customization_change?: InputMaybe<Scalars['String']['input']>;
  customization_text?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imageurl?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "all_card_text" */
export type All_Card_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: All_Card_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type All_Card_Text_Stream_Cursor_Value_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  backimageurl?: InputMaybe<Scalars['String']['input']>;
  customization_change?: InputMaybe<Scalars['String']['input']>;
  customization_text?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imageurl?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "all_card_text" */
export enum All_Card_Text_Update_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  Backimageurl = 'backimageurl',
  /** column name */
  CustomizationChange = 'customization_change',
  /** column name */
  CustomizationText = 'customization_text',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Imageurl = 'imageurl',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  TabooOriginalBackText = 'taboo_original_back_text',
  /** column name */
  TabooOriginalText = 'taboo_original_text',
  /** column name */
  TabooTextChange = 'taboo_text_change',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type All_Card_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<All_Card_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: All_Card_Text_Bool_Exp;
};

/** update columns of table "all_card" */
export enum All_Card_Update_Column {
  /** column name */
  AltArtInvestigator = 'alt_art_investigator',
  /** column name */
  AlternateOfCode = 'alternate_of_code',
  /** column name */
  AlternateRequiredCode = 'alternate_required_code',
  /** column name */
  BackIllustrator = 'back_illustrator',
  /** column name */
  BackLinkId = 'back_link_id',
  /** column name */
  Backimagesrc = 'backimagesrc',
  /** column name */
  Backimageurl = 'backimageurl',
  /** column name */
  Clues = 'clues',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  CustomizationOptions = 'customization_options',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  DuplicateOfCode = 'duplicate_of_code',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  ErrataDate = 'errata_date',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  Faction2Code = 'faction2_code',
  /** column name */
  Faction3Code = 'faction3_code',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Gender = 'gender',
  /** column name */
  HealsDamage = 'heals_damage',
  /** column name */
  HealsHorror = 'heals_horror',
  /** column name */
  Health = 'health',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Imageurl = 'imageurl',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Linked = 'linked',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  Official = 'official',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Preview = 'preview',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealBackTraits = 'real_back_traits',
  /** column name */
  RealCustomizationChange = 'real_customization_change',
  /** column name */
  RealCustomizationText = 'real_customization_text',
  /** column name */
  RealEncounterSetName = 'real_encounter_set_name',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealTabooOriginalBackText = 'real_taboo_original_back_text',
  /** column name */
  RealTabooOriginalText = 'real_taboo_original_text',
  /** column name */
  RealTabooTextChange = 'real_taboo_text_change',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SideDeckOptions = 'side_deck_options',
  /** column name */
  SideDeckRequirements = 'side_deck_requirements',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TabooPlaceholder = 'taboo_placeholder',
  /** column name */
  TabooSetId = 'taboo_set_id',
  /** column name */
  TabooXp = 'taboo_xp',
  /** column name */
  Tags = 'tags',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Vengeance = 'vengeance',
  /** column name */
  Version = 'version',
  /** column name */
  Victory = 'victory',
  /** column name */
  Xp = 'xp'
}

/** columns and relationships of "all_card_updated" */
export type All_Card_Updated = {
  __typename?: 'all_card_updated';
  card_count?: Maybe<Scalars['Int']['output']>;
  cards_updated_at: Scalars['timestamp']['output'];
  locale: Scalars['String']['output'];
  translation_updated_at: Scalars['timestamp']['output'];
};

/** aggregated selection of "all_card_updated" */
export type All_Card_Updated_Aggregate = {
  __typename?: 'all_card_updated_aggregate';
  aggregate?: Maybe<All_Card_Updated_Aggregate_Fields>;
  nodes: Array<All_Card_Updated>;
};

/** aggregate fields of "all_card_updated" */
export type All_Card_Updated_Aggregate_Fields = {
  __typename?: 'all_card_updated_aggregate_fields';
  avg?: Maybe<All_Card_Updated_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<All_Card_Updated_Max_Fields>;
  min?: Maybe<All_Card_Updated_Min_Fields>;
  stddev?: Maybe<All_Card_Updated_Stddev_Fields>;
  stddev_pop?: Maybe<All_Card_Updated_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<All_Card_Updated_Stddev_Samp_Fields>;
  sum?: Maybe<All_Card_Updated_Sum_Fields>;
  var_pop?: Maybe<All_Card_Updated_Var_Pop_Fields>;
  var_samp?: Maybe<All_Card_Updated_Var_Samp_Fields>;
  variance?: Maybe<All_Card_Updated_Variance_Fields>;
};


/** aggregate fields of "all_card_updated" */
export type All_Card_Updated_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<All_Card_Updated_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type All_Card_Updated_Avg_Fields = {
  __typename?: 'all_card_updated_avg_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "all_card_updated". All fields are combined with a logical 'AND'. */
export type All_Card_Updated_Bool_Exp = {
  _and?: InputMaybe<Array<All_Card_Updated_Bool_Exp>>;
  _not?: InputMaybe<All_Card_Updated_Bool_Exp>;
  _or?: InputMaybe<Array<All_Card_Updated_Bool_Exp>>;
  card_count?: InputMaybe<Int_Comparison_Exp>;
  cards_updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  translation_updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** columns and relationships of "all_card_updated_by_version" */
export type All_Card_Updated_By_Version = {
  __typename?: 'all_card_updated_by_version';
  card_count: Scalars['Int']['output'];
  cards_updated_at: Scalars['timestamp']['output'];
  locale: Scalars['String']['output'];
  translation_updated_at: Scalars['timestamp']['output'];
  version: Scalars['Int']['output'];
};

/** aggregated selection of "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Aggregate = {
  __typename?: 'all_card_updated_by_version_aggregate';
  aggregate?: Maybe<All_Card_Updated_By_Version_Aggregate_Fields>;
  nodes: Array<All_Card_Updated_By_Version>;
};

/** aggregate fields of "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Aggregate_Fields = {
  __typename?: 'all_card_updated_by_version_aggregate_fields';
  avg?: Maybe<All_Card_Updated_By_Version_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<All_Card_Updated_By_Version_Max_Fields>;
  min?: Maybe<All_Card_Updated_By_Version_Min_Fields>;
  stddev?: Maybe<All_Card_Updated_By_Version_Stddev_Fields>;
  stddev_pop?: Maybe<All_Card_Updated_By_Version_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<All_Card_Updated_By_Version_Stddev_Samp_Fields>;
  sum?: Maybe<All_Card_Updated_By_Version_Sum_Fields>;
  var_pop?: Maybe<All_Card_Updated_By_Version_Var_Pop_Fields>;
  var_samp?: Maybe<All_Card_Updated_By_Version_Var_Samp_Fields>;
  variance?: Maybe<All_Card_Updated_By_Version_Variance_Fields>;
};


/** aggregate fields of "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<All_Card_Updated_By_Version_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type All_Card_Updated_By_Version_Avg_Fields = {
  __typename?: 'all_card_updated_by_version_avg_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "all_card_updated_by_version". All fields are combined with a logical 'AND'. */
export type All_Card_Updated_By_Version_Bool_Exp = {
  _and?: InputMaybe<Array<All_Card_Updated_By_Version_Bool_Exp>>;
  _not?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
  _or?: InputMaybe<Array<All_Card_Updated_By_Version_Bool_Exp>>;
  card_count?: InputMaybe<Int_Comparison_Exp>;
  cards_updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  translation_updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
  version?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "all_card_updated_by_version" */
export enum All_Card_Updated_By_Version_Constraint {
  /** unique or primary key constraint on columns "locale", "version" */
  AllCardUpdatedByVersionPkey = 'all_card_updated_by_version_pkey'
}

/** input type for incrementing numeric columns in table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Inc_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Insert_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type All_Card_Updated_By_Version_Max_Fields = {
  __typename?: 'all_card_updated_by_version_max_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  cards_updated_at?: Maybe<Scalars['timestamp']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  translation_updated_at?: Maybe<Scalars['timestamp']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type All_Card_Updated_By_Version_Min_Fields = {
  __typename?: 'all_card_updated_by_version_min_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  cards_updated_at?: Maybe<Scalars['timestamp']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  translation_updated_at?: Maybe<Scalars['timestamp']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Mutation_Response = {
  __typename?: 'all_card_updated_by_version_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<All_Card_Updated_By_Version>;
};

/** on_conflict condition type for table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_On_Conflict = {
  constraint: All_Card_Updated_By_Version_Constraint;
  update_columns?: Array<All_Card_Updated_By_Version_Update_Column>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};

/** Ordering options when selecting data from "all_card_updated_by_version". */
export type All_Card_Updated_By_Version_Order_By = {
  card_count?: InputMaybe<Order_By>;
  cards_updated_at?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  translation_updated_at?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** primary key columns input for table: all_card_updated_by_version */
export type All_Card_Updated_By_Version_Pk_Columns_Input = {
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
};

/** select columns of table "all_card_updated_by_version" */
export enum All_Card_Updated_By_Version_Select_Column {
  /** column name */
  CardCount = 'card_count',
  /** column name */
  CardsUpdatedAt = 'cards_updated_at',
  /** column name */
  Locale = 'locale',
  /** column name */
  TranslationUpdatedAt = 'translation_updated_at',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Set_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type All_Card_Updated_By_Version_Stddev_Fields = {
  __typename?: 'all_card_updated_by_version_stddev_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type All_Card_Updated_By_Version_Stddev_Pop_Fields = {
  __typename?: 'all_card_updated_by_version_stddev_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type All_Card_Updated_By_Version_Stddev_Samp_Fields = {
  __typename?: 'all_card_updated_by_version_stddev_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: All_Card_Updated_By_Version_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type All_Card_Updated_By_Version_Stream_Cursor_Value_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type All_Card_Updated_By_Version_Sum_Fields = {
  __typename?: 'all_card_updated_by_version_sum_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "all_card_updated_by_version" */
export enum All_Card_Updated_By_Version_Update_Column {
  /** column name */
  CardCount = 'card_count',
  /** column name */
  CardsUpdatedAt = 'cards_updated_at',
  /** column name */
  Locale = 'locale',
  /** column name */
  TranslationUpdatedAt = 'translation_updated_at',
  /** column name */
  Version = 'version'
}

export type All_Card_Updated_By_Version_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<All_Card_Updated_By_Version_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<All_Card_Updated_By_Version_Set_Input>;
  /** filter the rows which have to be updated */
  where: All_Card_Updated_By_Version_Bool_Exp;
};

/** aggregate var_pop on columns */
export type All_Card_Updated_By_Version_Var_Pop_Fields = {
  __typename?: 'all_card_updated_by_version_var_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type All_Card_Updated_By_Version_Var_Samp_Fields = {
  __typename?: 'all_card_updated_by_version_var_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type All_Card_Updated_By_Version_Variance_Fields = {
  __typename?: 'all_card_updated_by_version_variance_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** unique or primary key constraints on table "all_card_updated" */
export enum All_Card_Updated_Constraint {
  /** unique or primary key constraint on columns "locale" */
  AllCardUpdatedPkey = 'all_card_updated_pkey'
}

/** input type for incrementing numeric columns in table "all_card_updated" */
export type All_Card_Updated_Inc_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "all_card_updated" */
export type All_Card_Updated_Insert_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type All_Card_Updated_Max_Fields = {
  __typename?: 'all_card_updated_max_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  cards_updated_at?: Maybe<Scalars['timestamp']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  translation_updated_at?: Maybe<Scalars['timestamp']['output']>;
};

/** aggregate min on columns */
export type All_Card_Updated_Min_Fields = {
  __typename?: 'all_card_updated_min_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  cards_updated_at?: Maybe<Scalars['timestamp']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  translation_updated_at?: Maybe<Scalars['timestamp']['output']>;
};

/** response of any mutation on the table "all_card_updated" */
export type All_Card_Updated_Mutation_Response = {
  __typename?: 'all_card_updated_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<All_Card_Updated>;
};

/** on_conflict condition type for table "all_card_updated" */
export type All_Card_Updated_On_Conflict = {
  constraint: All_Card_Updated_Constraint;
  update_columns?: Array<All_Card_Updated_Update_Column>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};

/** Ordering options when selecting data from "all_card_updated". */
export type All_Card_Updated_Order_By = {
  card_count?: InputMaybe<Order_By>;
  cards_updated_at?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  translation_updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: all_card_updated */
export type All_Card_Updated_Pk_Columns_Input = {
  locale: Scalars['String']['input'];
};

/** select columns of table "all_card_updated" */
export enum All_Card_Updated_Select_Column {
  /** column name */
  CardCount = 'card_count',
  /** column name */
  CardsUpdatedAt = 'cards_updated_at',
  /** column name */
  Locale = 'locale',
  /** column name */
  TranslationUpdatedAt = 'translation_updated_at'
}

/** input type for updating data in table "all_card_updated" */
export type All_Card_Updated_Set_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type All_Card_Updated_Stddev_Fields = {
  __typename?: 'all_card_updated_stddev_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type All_Card_Updated_Stddev_Pop_Fields = {
  __typename?: 'all_card_updated_stddev_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type All_Card_Updated_Stddev_Samp_Fields = {
  __typename?: 'all_card_updated_stddev_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "all_card_updated" */
export type All_Card_Updated_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: All_Card_Updated_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type All_Card_Updated_Stream_Cursor_Value_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type All_Card_Updated_Sum_Fields = {
  __typename?: 'all_card_updated_sum_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "all_card_updated" */
export enum All_Card_Updated_Update_Column {
  /** column name */
  CardCount = 'card_count',
  /** column name */
  CardsUpdatedAt = 'cards_updated_at',
  /** column name */
  Locale = 'locale',
  /** column name */
  TranslationUpdatedAt = 'translation_updated_at'
}

export type All_Card_Updated_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<All_Card_Updated_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<All_Card_Updated_Set_Input>;
  /** filter the rows which have to be updated */
  where: All_Card_Updated_Bool_Exp;
};

/** aggregate var_pop on columns */
export type All_Card_Updated_Var_Pop_Fields = {
  __typename?: 'all_card_updated_var_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type All_Card_Updated_Var_Samp_Fields = {
  __typename?: 'all_card_updated_var_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type All_Card_Updated_Variance_Fields = {
  __typename?: 'all_card_updated_variance_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

export type All_Card_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<All_Card_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<All_Card_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<All_Card_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<All_Card_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<All_Card_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<All_Card_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<All_Card_Set_Input>;
  /** filter the rows which have to be updated */
  where: All_Card_Bool_Exp;
};

/** aggregate var_pop on columns */
export type All_Card_Var_Pop_Fields = {
  __typename?: 'all_card_var_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "all_card" */
export type All_Card_Var_Pop_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type All_Card_Var_Samp_Fields = {
  __typename?: 'all_card_var_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "all_card" */
export type All_Card_Var_Samp_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type All_Card_Variance_Fields = {
  __typename?: 'all_card_variance_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "all_card" */
export type All_Card_Variance_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** columns and relationships of "arkhamdb_auth" */
export type Arkhamdb_Auth = {
  __typename?: 'arkhamdb_auth';
  access_token: Scalars['String']['output'];
  access_token_expiration: Scalars['timestamptz']['output'];
  account_id?: Maybe<Scalars['Int']['output']>;
  account_name?: Maybe<Scalars['String']['output']>;
  decks_cache_key?: Maybe<Scalars['String']['output']>;
  reauthorization_required: Scalars['Boolean']['output'];
  refresh_token: Scalars['String']['output'];
  refresh_token_expiration?: Maybe<Scalars['timestamptz']['output']>;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "arkhamdb_auth" */
export type Arkhamdb_Auth_Aggregate = {
  __typename?: 'arkhamdb_auth_aggregate';
  aggregate?: Maybe<Arkhamdb_Auth_Aggregate_Fields>;
  nodes: Array<Arkhamdb_Auth>;
};

/** aggregate fields of "arkhamdb_auth" */
export type Arkhamdb_Auth_Aggregate_Fields = {
  __typename?: 'arkhamdb_auth_aggregate_fields';
  avg?: Maybe<Arkhamdb_Auth_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Arkhamdb_Auth_Max_Fields>;
  min?: Maybe<Arkhamdb_Auth_Min_Fields>;
  stddev?: Maybe<Arkhamdb_Auth_Stddev_Fields>;
  stddev_pop?: Maybe<Arkhamdb_Auth_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arkhamdb_Auth_Stddev_Samp_Fields>;
  sum?: Maybe<Arkhamdb_Auth_Sum_Fields>;
  var_pop?: Maybe<Arkhamdb_Auth_Var_Pop_Fields>;
  var_samp?: Maybe<Arkhamdb_Auth_Var_Samp_Fields>;
  variance?: Maybe<Arkhamdb_Auth_Variance_Fields>;
};


/** aggregate fields of "arkhamdb_auth" */
export type Arkhamdb_Auth_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Arkhamdb_Auth_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Arkhamdb_Auth_Avg_Fields = {
  __typename?: 'arkhamdb_auth_avg_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "arkhamdb_auth". All fields are combined with a logical 'AND'. */
export type Arkhamdb_Auth_Bool_Exp = {
  _and?: InputMaybe<Array<Arkhamdb_Auth_Bool_Exp>>;
  _not?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
  _or?: InputMaybe<Array<Arkhamdb_Auth_Bool_Exp>>;
  access_token?: InputMaybe<String_Comparison_Exp>;
  access_token_expiration?: InputMaybe<Timestamptz_Comparison_Exp>;
  account_id?: InputMaybe<Int_Comparison_Exp>;
  account_name?: InputMaybe<String_Comparison_Exp>;
  decks_cache_key?: InputMaybe<String_Comparison_Exp>;
  reauthorization_required?: InputMaybe<Boolean_Comparison_Exp>;
  refresh_token?: InputMaybe<String_Comparison_Exp>;
  refresh_token_expiration?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "arkhamdb_auth" */
export enum Arkhamdb_Auth_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  ArkhamdbAuthPkey = 'arkhamdb_auth_pkey'
}

/** input type for incrementing numeric columns in table "arkhamdb_auth" */
export type Arkhamdb_Auth_Inc_Input = {
  account_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "arkhamdb_auth" */
export type Arkhamdb_Auth_Insert_Input = {
  access_token?: InputMaybe<Scalars['String']['input']>;
  access_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  account_id?: InputMaybe<Scalars['Int']['input']>;
  account_name?: InputMaybe<Scalars['String']['input']>;
  decks_cache_key?: InputMaybe<Scalars['String']['input']>;
  reauthorization_required?: InputMaybe<Scalars['Boolean']['input']>;
  refresh_token?: InputMaybe<Scalars['String']['input']>;
  refresh_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Arkhamdb_Auth_Max_Fields = {
  __typename?: 'arkhamdb_auth_max_fields';
  access_token?: Maybe<Scalars['String']['output']>;
  access_token_expiration?: Maybe<Scalars['timestamptz']['output']>;
  account_id?: Maybe<Scalars['Int']['output']>;
  account_name?: Maybe<Scalars['String']['output']>;
  decks_cache_key?: Maybe<Scalars['String']['output']>;
  refresh_token?: Maybe<Scalars['String']['output']>;
  refresh_token_expiration?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Arkhamdb_Auth_Min_Fields = {
  __typename?: 'arkhamdb_auth_min_fields';
  access_token?: Maybe<Scalars['String']['output']>;
  access_token_expiration?: Maybe<Scalars['timestamptz']['output']>;
  account_id?: Maybe<Scalars['Int']['output']>;
  account_name?: Maybe<Scalars['String']['output']>;
  decks_cache_key?: Maybe<Scalars['String']['output']>;
  refresh_token?: Maybe<Scalars['String']['output']>;
  refresh_token_expiration?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "arkhamdb_auth" */
export type Arkhamdb_Auth_Mutation_Response = {
  __typename?: 'arkhamdb_auth_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Arkhamdb_Auth>;
};

/** on_conflict condition type for table "arkhamdb_auth" */
export type Arkhamdb_Auth_On_Conflict = {
  constraint: Arkhamdb_Auth_Constraint;
  update_columns?: Array<Arkhamdb_Auth_Update_Column>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};

/** Ordering options when selecting data from "arkhamdb_auth". */
export type Arkhamdb_Auth_Order_By = {
  access_token?: InputMaybe<Order_By>;
  access_token_expiration?: InputMaybe<Order_By>;
  account_id?: InputMaybe<Order_By>;
  account_name?: InputMaybe<Order_By>;
  decks_cache_key?: InputMaybe<Order_By>;
  reauthorization_required?: InputMaybe<Order_By>;
  refresh_token?: InputMaybe<Order_By>;
  refresh_token_expiration?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: arkhamdb_auth */
export type Arkhamdb_Auth_Pk_Columns_Input = {
  user_id: Scalars['String']['input'];
};

/** select columns of table "arkhamdb_auth" */
export enum Arkhamdb_Auth_Select_Column {
  /** column name */
  AccessToken = 'access_token',
  /** column name */
  AccessTokenExpiration = 'access_token_expiration',
  /** column name */
  AccountId = 'account_id',
  /** column name */
  AccountName = 'account_name',
  /** column name */
  DecksCacheKey = 'decks_cache_key',
  /** column name */
  ReauthorizationRequired = 'reauthorization_required',
  /** column name */
  RefreshToken = 'refresh_token',
  /** column name */
  RefreshTokenExpiration = 'refresh_token_expiration',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "arkhamdb_auth" */
export type Arkhamdb_Auth_Set_Input = {
  access_token?: InputMaybe<Scalars['String']['input']>;
  access_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  account_id?: InputMaybe<Scalars['Int']['input']>;
  account_name?: InputMaybe<Scalars['String']['input']>;
  decks_cache_key?: InputMaybe<Scalars['String']['input']>;
  reauthorization_required?: InputMaybe<Scalars['Boolean']['input']>;
  refresh_token?: InputMaybe<Scalars['String']['input']>;
  refresh_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Arkhamdb_Auth_Stddev_Fields = {
  __typename?: 'arkhamdb_auth_stddev_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Arkhamdb_Auth_Stddev_Pop_Fields = {
  __typename?: 'arkhamdb_auth_stddev_pop_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Arkhamdb_Auth_Stddev_Samp_Fields = {
  __typename?: 'arkhamdb_auth_stddev_samp_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "arkhamdb_auth" */
export type Arkhamdb_Auth_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arkhamdb_Auth_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arkhamdb_Auth_Stream_Cursor_Value_Input = {
  access_token?: InputMaybe<Scalars['String']['input']>;
  access_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  account_id?: InputMaybe<Scalars['Int']['input']>;
  account_name?: InputMaybe<Scalars['String']['input']>;
  decks_cache_key?: InputMaybe<Scalars['String']['input']>;
  reauthorization_required?: InputMaybe<Scalars['Boolean']['input']>;
  refresh_token?: InputMaybe<Scalars['String']['input']>;
  refresh_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Arkhamdb_Auth_Sum_Fields = {
  __typename?: 'arkhamdb_auth_sum_fields';
  account_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "arkhamdb_auth" */
export enum Arkhamdb_Auth_Update_Column {
  /** column name */
  AccessToken = 'access_token',
  /** column name */
  AccessTokenExpiration = 'access_token_expiration',
  /** column name */
  AccountId = 'account_id',
  /** column name */
  AccountName = 'account_name',
  /** column name */
  DecksCacheKey = 'decks_cache_key',
  /** column name */
  ReauthorizationRequired = 'reauthorization_required',
  /** column name */
  RefreshToken = 'refresh_token',
  /** column name */
  RefreshTokenExpiration = 'refresh_token_expiration',
  /** column name */
  UserId = 'user_id'
}

export type Arkhamdb_Auth_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Arkhamdb_Auth_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Arkhamdb_Auth_Set_Input>;
  /** filter the rows which have to be updated */
  where: Arkhamdb_Auth_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arkhamdb_Auth_Var_Pop_Fields = {
  __typename?: 'arkhamdb_auth_var_pop_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Arkhamdb_Auth_Var_Samp_Fields = {
  __typename?: 'arkhamdb_auth_var_samp_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Arkhamdb_Auth_Variance_Fields = {
  __typename?: 'arkhamdb_auth_variance_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_Deck = {
  __typename?: 'arkhamdb_deck';
  archived?: Maybe<Scalars['Boolean']['output']>;
  created_at: Scalars['timestamptz']['output'];
  deleted: Scalars['Boolean']['output'];
  description: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  ignore_deck_limit_slots: Scalars['jsonb']['output'];
  investigator: Scalars['String']['output'];
  meta: Scalars['jsonb']['output'];
  name: Scalars['String']['output'];
  /** An object relationship */
  next_deck?: Maybe<Arkhamdb_Deck>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  owner: Users;
  owner_id: Scalars['String']['output'];
  /** An object relationship */
  previous_deck?: Maybe<Arkhamdb_Deck>;
  side_slots: Scalars['jsonb']['output'];
  slots: Scalars['jsonb']['output'];
  tags: Scalars['jsonb']['output'];
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_DeckIgnore_Deck_Limit_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_DeckMetaArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_DeckSide_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_DeckSlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_DeckTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "arkhamdb_deck" */
export type Arkhamdb_Deck_Aggregate = {
  __typename?: 'arkhamdb_deck_aggregate';
  aggregate?: Maybe<Arkhamdb_Deck_Aggregate_Fields>;
  nodes: Array<Arkhamdb_Deck>;
};

/** aggregate fields of "arkhamdb_deck" */
export type Arkhamdb_Deck_Aggregate_Fields = {
  __typename?: 'arkhamdb_deck_aggregate_fields';
  avg?: Maybe<Arkhamdb_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Arkhamdb_Deck_Max_Fields>;
  min?: Maybe<Arkhamdb_Deck_Min_Fields>;
  stddev?: Maybe<Arkhamdb_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Arkhamdb_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arkhamdb_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Arkhamdb_Deck_Sum_Fields>;
  var_pop?: Maybe<Arkhamdb_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Arkhamdb_Deck_Var_Samp_Fields>;
  variance?: Maybe<Arkhamdb_Deck_Variance_Fields>;
};


/** aggregate fields of "arkhamdb_deck" */
export type Arkhamdb_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Arkhamdb_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Arkhamdb_Deck_Append_Input = {
  ignore_deck_limit_slots?: InputMaybe<Scalars['jsonb']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Arkhamdb_Deck_Avg_Fields = {
  __typename?: 'arkhamdb_deck_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "arkhamdb_deck". All fields are combined with a logical 'AND'. */
export type Arkhamdb_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Arkhamdb_Deck_Bool_Exp>>;
  _not?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Arkhamdb_Deck_Bool_Exp>>;
  archived?: InputMaybe<Boolean_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deleted?: InputMaybe<Boolean_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  ignore_deck_limit_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  investigator?: InputMaybe<String_Comparison_Exp>;
  meta?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  next_deck?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
  next_deck_id?: InputMaybe<Int_Comparison_Exp>;
  owner?: InputMaybe<Users_Bool_Exp>;
  owner_id?: InputMaybe<String_Comparison_Exp>;
  previous_deck?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
  side_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  slots?: InputMaybe<Jsonb_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "arkhamdb_deck" */
export enum Arkhamdb_Deck_Constraint {
  /** unique or primary key constraint on columns "next_deck_id" */
  DeckNextDeckIdKey = 'deck_next_deck_id_key',
  /** unique or primary key constraint on columns "id" */
  DeckPkey1 = 'deck_pkey1'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Arkhamdb_Deck_Delete_At_Path_Input = {
  ignore_deck_limit_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  meta?: InputMaybe<Array<Scalars['String']['input']>>;
  side_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  slots?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Arkhamdb_Deck_Delete_Elem_Input = {
  ignore_deck_limit_slots?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['Int']['input']>;
  side_slots?: InputMaybe<Scalars['Int']['input']>;
  slots?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Arkhamdb_Deck_Delete_Key_Input = {
  ignore_deck_limit_slots?: InputMaybe<Scalars['String']['input']>;
  meta?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['String']['input']>;
  slots?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "arkhamdb_deck" */
export type Arkhamdb_Deck_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "arkhamdb_deck" */
export type Arkhamdb_Deck_Insert_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ignore_deck_limit_slots?: InputMaybe<Scalars['jsonb']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck?: InputMaybe<Arkhamdb_Deck_Obj_Rel_Insert_Input>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  owner?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  previous_deck?: InputMaybe<Arkhamdb_Deck_Obj_Rel_Insert_Input>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Arkhamdb_Deck_Max_Fields = {
  __typename?: 'arkhamdb_deck_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Arkhamdb_Deck_Min_Fields = {
  __typename?: 'arkhamdb_deck_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "arkhamdb_deck" */
export type Arkhamdb_Deck_Mutation_Response = {
  __typename?: 'arkhamdb_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Arkhamdb_Deck>;
};

/** input type for inserting object relation for remote table "arkhamdb_deck" */
export type Arkhamdb_Deck_Obj_Rel_Insert_Input = {
  data: Arkhamdb_Deck_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Arkhamdb_Deck_On_Conflict>;
};

/** on_conflict condition type for table "arkhamdb_deck" */
export type Arkhamdb_Deck_On_Conflict = {
  constraint: Arkhamdb_Deck_Constraint;
  update_columns?: Array<Arkhamdb_Deck_Update_Column>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};

/** Ordering options when selecting data from "arkhamdb_deck". */
export type Arkhamdb_Deck_Order_By = {
  archived?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deleted?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  ignore_deck_limit_slots?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  meta?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  next_deck?: InputMaybe<Arkhamdb_Deck_Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  owner?: InputMaybe<Users_Order_By>;
  owner_id?: InputMaybe<Order_By>;
  previous_deck?: InputMaybe<Arkhamdb_Deck_Order_By>;
  side_slots?: InputMaybe<Order_By>;
  slots?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: arkhamdb_deck */
export type Arkhamdb_Deck_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Arkhamdb_Deck_Prepend_Input = {
  ignore_deck_limit_slots?: InputMaybe<Scalars['jsonb']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "arkhamdb_deck" */
export enum Arkhamdb_Deck_Select_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Deleted = 'deleted',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  IgnoreDeckLimitSlots = 'ignore_deck_limit_slots',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "arkhamdb_deck" */
export type Arkhamdb_Deck_Set_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ignore_deck_limit_slots?: InputMaybe<Scalars['jsonb']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Arkhamdb_Deck_Stddev_Fields = {
  __typename?: 'arkhamdb_deck_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Arkhamdb_Deck_Stddev_Pop_Fields = {
  __typename?: 'arkhamdb_deck_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Arkhamdb_Deck_Stddev_Samp_Fields = {
  __typename?: 'arkhamdb_deck_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "arkhamdb_deck" */
export type Arkhamdb_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arkhamdb_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arkhamdb_Deck_Stream_Cursor_Value_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ignore_deck_limit_slots?: InputMaybe<Scalars['jsonb']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Arkhamdb_Deck_Sum_Fields = {
  __typename?: 'arkhamdb_deck_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "arkhamdb_deck" */
export enum Arkhamdb_Deck_Update_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Deleted = 'deleted',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  IgnoreDeckLimitSlots = 'ignore_deck_limit_slots',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Arkhamdb_Deck_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Arkhamdb_Deck_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Arkhamdb_Deck_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Arkhamdb_Deck_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Arkhamdb_Deck_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Arkhamdb_Deck_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Arkhamdb_Deck_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Arkhamdb_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Arkhamdb_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arkhamdb_Deck_Var_Pop_Fields = {
  __typename?: 'arkhamdb_deck_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Arkhamdb_Deck_Var_Samp_Fields = {
  __typename?: 'arkhamdb_deck_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Arkhamdb_Deck_Variance_Fields = {
  __typename?: 'arkhamdb_deck_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "base_decks" */
export type Base_Decks = {
  __typename?: 'base_decks';
  /** An object relationship */
  campaign?: Maybe<Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  deck?: Maybe<Campaign_Deck>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "base_decks" */
export type Base_Decks_Aggregate = {
  __typename?: 'base_decks_aggregate';
  aggregate?: Maybe<Base_Decks_Aggregate_Fields>;
  nodes: Array<Base_Decks>;
};

export type Base_Decks_Aggregate_Bool_Exp = {
  count?: InputMaybe<Base_Decks_Aggregate_Bool_Exp_Count>;
};

export type Base_Decks_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Base_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Base_Decks_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "base_decks" */
export type Base_Decks_Aggregate_Fields = {
  __typename?: 'base_decks_aggregate_fields';
  avg?: Maybe<Base_Decks_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Base_Decks_Max_Fields>;
  min?: Maybe<Base_Decks_Min_Fields>;
  stddev?: Maybe<Base_Decks_Stddev_Fields>;
  stddev_pop?: Maybe<Base_Decks_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Base_Decks_Stddev_Samp_Fields>;
  sum?: Maybe<Base_Decks_Sum_Fields>;
  var_pop?: Maybe<Base_Decks_Var_Pop_Fields>;
  var_samp?: Maybe<Base_Decks_Var_Samp_Fields>;
  variance?: Maybe<Base_Decks_Variance_Fields>;
};


/** aggregate fields of "base_decks" */
export type Base_Decks_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Base_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "base_decks" */
export type Base_Decks_Aggregate_Order_By = {
  avg?: InputMaybe<Base_Decks_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Base_Decks_Max_Order_By>;
  min?: InputMaybe<Base_Decks_Min_Order_By>;
  stddev?: InputMaybe<Base_Decks_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Base_Decks_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Base_Decks_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Base_Decks_Sum_Order_By>;
  var_pop?: InputMaybe<Base_Decks_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Base_Decks_Var_Samp_Order_By>;
  variance?: InputMaybe<Base_Decks_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "base_decks" */
export type Base_Decks_Arr_Rel_Insert_Input = {
  data: Array<Base_Decks_Insert_Input>;
};

/** aggregate avg on columns */
export type Base_Decks_Avg_Fields = {
  __typename?: 'base_decks_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "base_decks" */
export type Base_Decks_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "base_decks". All fields are combined with a logical 'AND'. */
export type Base_Decks_Bool_Exp = {
  _and?: InputMaybe<Array<Base_Decks_Bool_Exp>>;
  _not?: InputMaybe<Base_Decks_Bool_Exp>;
  _or?: InputMaybe<Array<Base_Decks_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  deck?: InputMaybe<Campaign_Deck_Bool_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "base_decks" */
export type Base_Decks_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "base_decks" */
export type Base_Decks_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck?: InputMaybe<Campaign_Deck_Obj_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Base_Decks_Max_Fields = {
  __typename?: 'base_decks_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "base_decks" */
export type Base_Decks_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Base_Decks_Min_Fields = {
  __typename?: 'base_decks_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "base_decks" */
export type Base_Decks_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "base_decks" */
export type Base_Decks_Mutation_Response = {
  __typename?: 'base_decks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Base_Decks>;
};

/** Ordering options when selecting data from "base_decks". */
export type Base_Decks_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  deck?: InputMaybe<Campaign_Deck_Order_By>;
  id?: InputMaybe<Order_By>;
};

/** select columns of table "base_decks" */
export enum Base_Decks_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Id = 'id'
}

/** input type for updating data in table "base_decks" */
export type Base_Decks_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Base_Decks_Stddev_Fields = {
  __typename?: 'base_decks_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "base_decks" */
export type Base_Decks_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Base_Decks_Stddev_Pop_Fields = {
  __typename?: 'base_decks_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "base_decks" */
export type Base_Decks_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Base_Decks_Stddev_Samp_Fields = {
  __typename?: 'base_decks_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "base_decks" */
export type Base_Decks_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "base_decks" */
export type Base_Decks_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Base_Decks_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Base_Decks_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Base_Decks_Sum_Fields = {
  __typename?: 'base_decks_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "base_decks" */
export type Base_Decks_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

export type Base_Decks_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Base_Decks_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Base_Decks_Set_Input>;
  /** filter the rows which have to be updated */
  where: Base_Decks_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Base_Decks_Var_Pop_Fields = {
  __typename?: 'base_decks_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "base_decks" */
export type Base_Decks_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Base_Decks_Var_Samp_Fields = {
  __typename?: 'base_decks_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "base_decks" */
export type Base_Decks_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Base_Decks_Variance_Fields = {
  __typename?: 'base_decks_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "base_decks" */
export type Base_Decks_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['bigint']['input']>;
  _gt?: InputMaybe<Scalars['bigint']['input']>;
  _gte?: InputMaybe<Scalars['bigint']['input']>;
  _in?: InputMaybe<Array<Scalars['bigint']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['bigint']['input']>;
  _lte?: InputMaybe<Scalars['bigint']['input']>;
  _neq?: InputMaybe<Scalars['bigint']['input']>;
  _nin?: InputMaybe<Array<Scalars['bigint']['input']>>;
};

/** columns and relationships of "campaign" */
export type Campaign = {
  __typename?: 'campaign';
  /** An array relationship */
  access: Array<Campaign_Access>;
  /** An aggregate relationship */
  access_aggregate: Campaign_Access_Aggregate;
  archived?: Maybe<Scalars['Boolean']['output']>;
  /** An array relationship */
  base_decks: Array<Base_Decks>;
  /** An aggregate relationship */
  base_decks_aggregate: Base_Decks_Aggregate;
  campaignNotes?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  campaign_guide?: Maybe<Campaign_Guide>;
  chaosBag?: Maybe<Scalars['jsonb']['output']>;
  /** An array relationship */
  chaos_bag_result: Array<Chaos_Bag_Result>;
  /** An aggregate relationship */
  chaos_bag_result_aggregate: Chaos_Bag_Result_Aggregate;
  created_at: Scalars['timestamptz']['output'];
  cycleCode?: Maybe<Scalars['String']['output']>;
  deleted?: Maybe<Scalars['Boolean']['output']>;
  difficulty?: Maybe<Scalars['String']['output']>;
  guide_version?: Maybe<Scalars['Int']['output']>;
  guided?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['Int']['output'];
  /** An array relationship */
  investigator_data: Array<Investigator_Data>;
  /** An aggregate relationship */
  investigator_data_aggregate: Investigator_Data_Aggregate;
  /** An array relationship */
  investigators: Array<Campaign_Investigator>;
  /** An aggregate relationship */
  investigators_aggregate: Campaign_Investigator_Aggregate;
  /** An array relationship */
  latest_decks: Array<Latest_Decks>;
  /** An aggregate relationship */
  latest_decks_aggregate: Latest_Decks_Aggregate;
  /** An object relationship */
  link_a_campaign?: Maybe<Campaign>;
  link_a_campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  link_b_campaign?: Maybe<Campaign>;
  link_b_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  linked_campaign?: Maybe<Campaign>;
  name?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  owner: Users;
  owner_id: Scalars['String']['output'];
  scenarioResults?: Maybe<Scalars['jsonb']['output']>;
  showInterludes?: Maybe<Scalars['Boolean']['output']>;
  standaloneId?: Maybe<Scalars['jsonb']['output']>;
  tarot_reading?: Maybe<Scalars['jsonb']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['String']['output'];
  weaknessSet?: Maybe<Scalars['jsonb']['output']>;
};


/** columns and relationships of "campaign" */
export type CampaignAccessArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignAccess_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignBase_DecksArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignBase_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignCampaignNotesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign" */
export type CampaignChaosBagArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign" */
export type CampaignChaos_Bag_ResultArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignChaos_Bag_Result_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignInvestigator_DataArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignInvestigator_Data_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignInvestigatorsArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignInvestigators_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignLatest_DecksArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignLatest_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignScenarioResultsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign" */
export type CampaignStandaloneIdArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign" */
export type CampaignTarot_ReadingArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign" */
export type CampaignWeaknessSetArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "campaign_access" */
export type Campaign_Access = {
  __typename?: 'campaign_access';
  /** An object relationship */
  campaign: Campaign;
  campaign_id: Scalars['Int']['output'];
  hidden?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['Int']['output'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "campaign_access" */
export type Campaign_Access_Aggregate = {
  __typename?: 'campaign_access_aggregate';
  aggregate?: Maybe<Campaign_Access_Aggregate_Fields>;
  nodes: Array<Campaign_Access>;
};

export type Campaign_Access_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Campaign_Access_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Campaign_Access_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Campaign_Access_Aggregate_Bool_Exp_Count>;
};

export type Campaign_Access_Aggregate_Bool_Exp_Bool_And = {
  arguments: Campaign_Access_Select_Column_Campaign_Access_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Access_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Campaign_Access_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Campaign_Access_Select_Column_Campaign_Access_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Access_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Campaign_Access_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Access_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "campaign_access" */
export type Campaign_Access_Aggregate_Fields = {
  __typename?: 'campaign_access_aggregate_fields';
  avg?: Maybe<Campaign_Access_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Access_Max_Fields>;
  min?: Maybe<Campaign_Access_Min_Fields>;
  stddev?: Maybe<Campaign_Access_Stddev_Fields>;
  stddev_pop?: Maybe<Campaign_Access_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaign_Access_Stddev_Samp_Fields>;
  sum?: Maybe<Campaign_Access_Sum_Fields>;
  var_pop?: Maybe<Campaign_Access_Var_Pop_Fields>;
  var_samp?: Maybe<Campaign_Access_Var_Samp_Fields>;
  variance?: Maybe<Campaign_Access_Variance_Fields>;
};


/** aggregate fields of "campaign_access" */
export type Campaign_Access_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "campaign_access" */
export type Campaign_Access_Aggregate_Order_By = {
  avg?: InputMaybe<Campaign_Access_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Campaign_Access_Max_Order_By>;
  min?: InputMaybe<Campaign_Access_Min_Order_By>;
  stddev?: InputMaybe<Campaign_Access_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Campaign_Access_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Campaign_Access_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Campaign_Access_Sum_Order_By>;
  var_pop?: InputMaybe<Campaign_Access_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Campaign_Access_Var_Samp_Order_By>;
  variance?: InputMaybe<Campaign_Access_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "campaign_access" */
export type Campaign_Access_Arr_Rel_Insert_Input = {
  data: Array<Campaign_Access_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Campaign_Access_On_Conflict>;
};

/** aggregate avg on columns */
export type Campaign_Access_Avg_Fields = {
  __typename?: 'campaign_access_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "campaign_access" */
export type Campaign_Access_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "campaign_access". All fields are combined with a logical 'AND'. */
export type Campaign_Access_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Access_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Access_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Access_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  hidden?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "campaign_access" */
export enum Campaign_Access_Constraint {
  /** unique or primary key constraint on columns "id" */
  CampaignAccessPkey = 'campaign_access_pkey',
  /** unique or primary key constraint on columns "user_id", "campaign_id" */
  CampaignAccessUserIdCampaignIdKey = 'campaign_access_user_id_campaign_id_key'
}

/** input type for incrementing numeric columns in table "campaign_access" */
export type Campaign_Access_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "campaign_access" */
export type Campaign_Access_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Campaign_Access_Max_Fields = {
  __typename?: 'campaign_access_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "campaign_access" */
export type Campaign_Access_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Campaign_Access_Min_Fields = {
  __typename?: 'campaign_access_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "campaign_access" */
export type Campaign_Access_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "campaign_access" */
export type Campaign_Access_Mutation_Response = {
  __typename?: 'campaign_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign_Access>;
};

/** on_conflict condition type for table "campaign_access" */
export type Campaign_Access_On_Conflict = {
  constraint: Campaign_Access_Constraint;
  update_columns?: Array<Campaign_Access_Update_Column>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};

/** Ordering options when selecting data from "campaign_access". */
export type Campaign_Access_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  hidden?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: campaign_access */
export type Campaign_Access_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "campaign_access" */
export enum Campaign_Access_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Id = 'id',
  /** column name */
  UserId = 'user_id'
}

/** select "campaign_access_aggregate_bool_exp_bool_and_arguments_columns" columns of table "campaign_access" */
export enum Campaign_Access_Select_Column_Campaign_Access_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Hidden = 'hidden'
}

/** select "campaign_access_aggregate_bool_exp_bool_or_arguments_columns" columns of table "campaign_access" */
export enum Campaign_Access_Select_Column_Campaign_Access_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Hidden = 'hidden'
}

/** input type for updating data in table "campaign_access" */
export type Campaign_Access_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Campaign_Access_Stddev_Fields = {
  __typename?: 'campaign_access_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "campaign_access" */
export type Campaign_Access_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Campaign_Access_Stddev_Pop_Fields = {
  __typename?: 'campaign_access_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "campaign_access" */
export type Campaign_Access_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Campaign_Access_Stddev_Samp_Fields = {
  __typename?: 'campaign_access_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "campaign_access" */
export type Campaign_Access_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "campaign_access" */
export type Campaign_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Access_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Campaign_Access_Sum_Fields = {
  __typename?: 'campaign_access_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "campaign_access" */
export type Campaign_Access_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** update columns of table "campaign_access" */
export enum Campaign_Access_Update_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Id = 'id',
  /** column name */
  UserId = 'user_id'
}

export type Campaign_Access_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Campaign_Access_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Access_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Campaign_Access_Var_Pop_Fields = {
  __typename?: 'campaign_access_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "campaign_access" */
export type Campaign_Access_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Campaign_Access_Var_Samp_Fields = {
  __typename?: 'campaign_access_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "campaign_access" */
export type Campaign_Access_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Campaign_Access_Variance_Fields = {
  __typename?: 'campaign_access_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "campaign_access" */
export type Campaign_Access_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregated selection of "campaign" */
export type Campaign_Aggregate = {
  __typename?: 'campaign_aggregate';
  aggregate?: Maybe<Campaign_Aggregate_Fields>;
  nodes: Array<Campaign>;
};

/** aggregate fields of "campaign" */
export type Campaign_Aggregate_Fields = {
  __typename?: 'campaign_aggregate_fields';
  avg?: Maybe<Campaign_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Max_Fields>;
  min?: Maybe<Campaign_Min_Fields>;
  stddev?: Maybe<Campaign_Stddev_Fields>;
  stddev_pop?: Maybe<Campaign_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaign_Stddev_Samp_Fields>;
  sum?: Maybe<Campaign_Sum_Fields>;
  var_pop?: Maybe<Campaign_Var_Pop_Fields>;
  var_samp?: Maybe<Campaign_Var_Samp_Fields>;
  variance?: Maybe<Campaign_Variance_Fields>;
};


/** aggregate fields of "campaign" */
export type Campaign_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Campaign_Append_Input = {
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  tarot_reading?: InputMaybe<Scalars['jsonb']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Campaign_Avg_Fields = {
  __typename?: 'campaign_avg_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "campaign". All fields are combined with a logical 'AND'. */
export type Campaign_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Bool_Exp>>;
  access?: InputMaybe<Campaign_Access_Bool_Exp>;
  access_aggregate?: InputMaybe<Campaign_Access_Aggregate_Bool_Exp>;
  archived?: InputMaybe<Boolean_Comparison_Exp>;
  base_decks?: InputMaybe<Base_Decks_Bool_Exp>;
  base_decks_aggregate?: InputMaybe<Base_Decks_Aggregate_Bool_Exp>;
  campaignNotes?: InputMaybe<Jsonb_Comparison_Exp>;
  campaign_guide?: InputMaybe<Campaign_Guide_Bool_Exp>;
  chaosBag?: InputMaybe<Jsonb_Comparison_Exp>;
  chaos_bag_result?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
  chaos_bag_result_aggregate?: InputMaybe<Chaos_Bag_Result_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  cycleCode?: InputMaybe<String_Comparison_Exp>;
  deleted?: InputMaybe<Boolean_Comparison_Exp>;
  difficulty?: InputMaybe<String_Comparison_Exp>;
  guide_version?: InputMaybe<Int_Comparison_Exp>;
  guided?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  investigator_data?: InputMaybe<Investigator_Data_Bool_Exp>;
  investigator_data_aggregate?: InputMaybe<Investigator_Data_Aggregate_Bool_Exp>;
  investigators?: InputMaybe<Campaign_Investigator_Bool_Exp>;
  investigators_aggregate?: InputMaybe<Campaign_Investigator_Aggregate_Bool_Exp>;
  latest_decks?: InputMaybe<Latest_Decks_Bool_Exp>;
  latest_decks_aggregate?: InputMaybe<Latest_Decks_Aggregate_Bool_Exp>;
  link_a_campaign?: InputMaybe<Campaign_Bool_Exp>;
  link_a_campaign_id?: InputMaybe<Int_Comparison_Exp>;
  link_b_campaign?: InputMaybe<Campaign_Bool_Exp>;
  link_b_campaign_id?: InputMaybe<Int_Comparison_Exp>;
  link_campaign_id?: InputMaybe<Int_Comparison_Exp>;
  linked_campaign?: InputMaybe<Campaign_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  owner?: InputMaybe<Users_Bool_Exp>;
  owner_id?: InputMaybe<String_Comparison_Exp>;
  scenarioResults?: InputMaybe<Jsonb_Comparison_Exp>;
  showInterludes?: InputMaybe<Boolean_Comparison_Exp>;
  standaloneId?: InputMaybe<Jsonb_Comparison_Exp>;
  tarot_reading?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<String_Comparison_Exp>;
  weaknessSet?: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "campaign" */
export enum Campaign_Constraint {
  /** unique or primary key constraint on columns "id" */
  CampaignDataPkey = 'campaign_data_pkey'
}

/** columns and relationships of "campaign_deck" */
export type Campaign_Deck = {
  __typename?: 'campaign_deck';
  archived?: Maybe<Scalars['Boolean']['output']>;
  arkhamdb_id?: Maybe<Scalars['Int']['output']>;
  arkhamdb_user?: Maybe<Scalars['Int']['output']>;
  base?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  campaign: Campaign;
  campaign_id: Scalars['Int']['output'];
  content?: Maybe<Scalars['jsonb']['output']>;
  content_hash?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  investigator: Scalars['String']['output'];
  /** An object relationship */
  investigator_data?: Maybe<Investigator_Data>;
  local_uuid?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  next_deck?: Maybe<Campaign_Deck>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  other_decks: Array<Campaign_Deck>;
  /** An aggregate relationship */
  other_decks_aggregate: Campaign_Deck_Aggregate;
  /** An object relationship */
  owner: Users;
  owner_id: Scalars['String']['output'];
  /** An object relationship */
  previous_deck?: Maybe<Campaign_Deck>;
  /** An array relationship */
  previous_decks: Array<Campaign_Deck>;
  /** An aggregate relationship */
  previous_decks_aggregate: Campaign_Deck_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "campaign_deck" */
export type Campaign_DeckContentArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign_deck" */
export type Campaign_DeckOther_DecksArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


/** columns and relationships of "campaign_deck" */
export type Campaign_DeckOther_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


/** columns and relationships of "campaign_deck" */
export type Campaign_DeckPrevious_DecksArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


/** columns and relationships of "campaign_deck" */
export type Campaign_DeckPrevious_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};

/** aggregated selection of "campaign_deck" */
export type Campaign_Deck_Aggregate = {
  __typename?: 'campaign_deck_aggregate';
  aggregate?: Maybe<Campaign_Deck_Aggregate_Fields>;
  nodes: Array<Campaign_Deck>;
};

export type Campaign_Deck_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp_Count>;
};

export type Campaign_Deck_Aggregate_Bool_Exp_Bool_And = {
  arguments: Campaign_Deck_Select_Column_Campaign_Deck_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Deck_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Campaign_Deck_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Campaign_Deck_Select_Column_Campaign_Deck_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Deck_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Campaign_Deck_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Deck_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "campaign_deck" */
export type Campaign_Deck_Aggregate_Fields = {
  __typename?: 'campaign_deck_aggregate_fields';
  avg?: Maybe<Campaign_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Deck_Max_Fields>;
  min?: Maybe<Campaign_Deck_Min_Fields>;
  stddev?: Maybe<Campaign_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Campaign_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaign_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Campaign_Deck_Sum_Fields>;
  var_pop?: Maybe<Campaign_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Campaign_Deck_Var_Samp_Fields>;
  variance?: Maybe<Campaign_Deck_Variance_Fields>;
};


/** aggregate fields of "campaign_deck" */
export type Campaign_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "campaign_deck" */
export type Campaign_Deck_Aggregate_Order_By = {
  avg?: InputMaybe<Campaign_Deck_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Campaign_Deck_Max_Order_By>;
  min?: InputMaybe<Campaign_Deck_Min_Order_By>;
  stddev?: InputMaybe<Campaign_Deck_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Campaign_Deck_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Campaign_Deck_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Campaign_Deck_Sum_Order_By>;
  var_pop?: InputMaybe<Campaign_Deck_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Campaign_Deck_Var_Samp_Order_By>;
  variance?: InputMaybe<Campaign_Deck_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Campaign_Deck_Append_Input = {
  content?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "campaign_deck" */
export type Campaign_Deck_Arr_Rel_Insert_Input = {
  data: Array<Campaign_Deck_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Campaign_Deck_On_Conflict>;
};

/** aggregate avg on columns */
export type Campaign_Deck_Avg_Fields = {
  __typename?: 'campaign_deck_avg_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "campaign_deck" */
export type Campaign_Deck_Avg_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "campaign_deck". All fields are combined with a logical 'AND'. */
export type Campaign_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Deck_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Deck_Bool_Exp>>;
  archived?: InputMaybe<Boolean_Comparison_Exp>;
  arkhamdb_id?: InputMaybe<Int_Comparison_Exp>;
  arkhamdb_user?: InputMaybe<Int_Comparison_Exp>;
  base?: InputMaybe<Boolean_Comparison_Exp>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  content?: InputMaybe<Jsonb_Comparison_Exp>;
  content_hash?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  investigator?: InputMaybe<String_Comparison_Exp>;
  investigator_data?: InputMaybe<Investigator_Data_Bool_Exp>;
  local_uuid?: InputMaybe<String_Comparison_Exp>;
  next_deck?: InputMaybe<Campaign_Deck_Bool_Exp>;
  next_deck_id?: InputMaybe<Int_Comparison_Exp>;
  other_decks?: InputMaybe<Campaign_Deck_Bool_Exp>;
  other_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp>;
  owner?: InputMaybe<Users_Bool_Exp>;
  owner_id?: InputMaybe<String_Comparison_Exp>;
  previous_deck?: InputMaybe<Campaign_Deck_Bool_Exp>;
  previous_decks?: InputMaybe<Campaign_Deck_Bool_Exp>;
  previous_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "campaign_deck" */
export enum Campaign_Deck_Constraint {
  /** unique or primary key constraint on columns "arkhamdb_id", "campaign_id" */
  DeckArkhamdbIdCampaignIdKey = 'deck_arkhamdb_id_campaign_id_key',
  /** unique or primary key constraint on columns "local_uuid", "campaign_id" */
  DeckLocalUuidCampaignIdKey = 'deck_local_uuid_campaign_id_key',
  /** unique or primary key constraint on columns "id" */
  DeckPkey = 'deck_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Campaign_Deck_Delete_At_Path_Input = {
  content?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Campaign_Deck_Delete_Elem_Input = {
  content?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Campaign_Deck_Delete_Key_Input = {
  content?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "campaign_deck" */
export type Campaign_Deck_Inc_Input = {
  arkhamdb_id?: InputMaybe<Scalars['Int']['input']>;
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "campaign_deck" */
export type Campaign_Deck_Insert_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  arkhamdb_id?: InputMaybe<Scalars['Int']['input']>;
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
  base?: InputMaybe<Scalars['Boolean']['input']>;
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  content?: InputMaybe<Scalars['jsonb']['input']>;
  content_hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  investigator_data?: InputMaybe<Investigator_Data_Obj_Rel_Insert_Input>;
  local_uuid?: InputMaybe<Scalars['String']['input']>;
  next_deck?: InputMaybe<Campaign_Deck_Obj_Rel_Insert_Input>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  other_decks?: InputMaybe<Campaign_Deck_Arr_Rel_Insert_Input>;
  owner?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  previous_deck?: InputMaybe<Campaign_Deck_Obj_Rel_Insert_Input>;
  previous_decks?: InputMaybe<Campaign_Deck_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Campaign_Deck_Max_Fields = {
  __typename?: 'campaign_deck_max_fields';
  arkhamdb_id?: Maybe<Scalars['Int']['output']>;
  arkhamdb_user?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  content_hash?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  local_uuid?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "campaign_deck" */
export type Campaign_Deck_Max_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  content_hash?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  local_uuid?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Campaign_Deck_Min_Fields = {
  __typename?: 'campaign_deck_min_fields';
  arkhamdb_id?: Maybe<Scalars['Int']['output']>;
  arkhamdb_user?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  content_hash?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  local_uuid?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "campaign_deck" */
export type Campaign_Deck_Min_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  content_hash?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  local_uuid?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "campaign_deck" */
export type Campaign_Deck_Mutation_Response = {
  __typename?: 'campaign_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign_Deck>;
};

/** input type for inserting object relation for remote table "campaign_deck" */
export type Campaign_Deck_Obj_Rel_Insert_Input = {
  data: Campaign_Deck_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Campaign_Deck_On_Conflict>;
};

/** on_conflict condition type for table "campaign_deck" */
export type Campaign_Deck_On_Conflict = {
  constraint: Campaign_Deck_Constraint;
  update_columns?: Array<Campaign_Deck_Update_Column>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};

/** Ordering options when selecting data from "campaign_deck". */
export type Campaign_Deck_Order_By = {
  archived?: InputMaybe<Order_By>;
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  base?: InputMaybe<Order_By>;
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  content?: InputMaybe<Order_By>;
  content_hash?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  investigator_data?: InputMaybe<Investigator_Data_Order_By>;
  local_uuid?: InputMaybe<Order_By>;
  next_deck?: InputMaybe<Campaign_Deck_Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  other_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Order_By>;
  owner?: InputMaybe<Users_Order_By>;
  owner_id?: InputMaybe<Order_By>;
  previous_deck?: InputMaybe<Campaign_Deck_Order_By>;
  previous_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: campaign_deck */
export type Campaign_Deck_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Campaign_Deck_Prepend_Input = {
  content?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "campaign_deck" */
export enum Campaign_Deck_Select_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  ArkhamdbId = 'arkhamdb_id',
  /** column name */
  ArkhamdbUser = 'arkhamdb_user',
  /** column name */
  Base = 'base',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Content = 'content',
  /** column name */
  ContentHash = 'content_hash',
  /** column name */
  Id = 'id',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  LocalUuid = 'local_uuid',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "campaign_deck_aggregate_bool_exp_bool_and_arguments_columns" columns of table "campaign_deck" */
export enum Campaign_Deck_Select_Column_Campaign_Deck_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Archived = 'archived',
  /** column name */
  Base = 'base'
}

/** select "campaign_deck_aggregate_bool_exp_bool_or_arguments_columns" columns of table "campaign_deck" */
export enum Campaign_Deck_Select_Column_Campaign_Deck_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Archived = 'archived',
  /** column name */
  Base = 'base'
}

/** input type for updating data in table "campaign_deck" */
export type Campaign_Deck_Set_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  arkhamdb_id?: InputMaybe<Scalars['Int']['input']>;
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
  base?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  content?: InputMaybe<Scalars['jsonb']['input']>;
  content_hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  local_uuid?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Campaign_Deck_Stddev_Fields = {
  __typename?: 'campaign_deck_stddev_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "campaign_deck" */
export type Campaign_Deck_Stddev_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Campaign_Deck_Stddev_Pop_Fields = {
  __typename?: 'campaign_deck_stddev_pop_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "campaign_deck" */
export type Campaign_Deck_Stddev_Pop_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Campaign_Deck_Stddev_Samp_Fields = {
  __typename?: 'campaign_deck_stddev_samp_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "campaign_deck" */
export type Campaign_Deck_Stddev_Samp_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "campaign_deck" */
export type Campaign_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Deck_Stream_Cursor_Value_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  arkhamdb_id?: InputMaybe<Scalars['Int']['input']>;
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
  base?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  content?: InputMaybe<Scalars['jsonb']['input']>;
  content_hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  local_uuid?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Campaign_Deck_Sum_Fields = {
  __typename?: 'campaign_deck_sum_fields';
  arkhamdb_id?: Maybe<Scalars['Int']['output']>;
  arkhamdb_user?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "campaign_deck" */
export type Campaign_Deck_Sum_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** update columns of table "campaign_deck" */
export enum Campaign_Deck_Update_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  ArkhamdbId = 'arkhamdb_id',
  /** column name */
  ArkhamdbUser = 'arkhamdb_user',
  /** column name */
  Base = 'base',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Content = 'content',
  /** column name */
  ContentHash = 'content_hash',
  /** column name */
  Id = 'id',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  LocalUuid = 'local_uuid',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Campaign_Deck_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Campaign_Deck_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Campaign_Deck_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Campaign_Deck_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Campaign_Deck_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Campaign_Deck_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Campaign_Deck_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Campaign_Deck_Var_Pop_Fields = {
  __typename?: 'campaign_deck_var_pop_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "campaign_deck" */
export type Campaign_Deck_Var_Pop_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Campaign_Deck_Var_Samp_Fields = {
  __typename?: 'campaign_deck_var_samp_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "campaign_deck" */
export type Campaign_Deck_Var_Samp_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Campaign_Deck_Variance_Fields = {
  __typename?: 'campaign_deck_variance_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "campaign_deck" */
export type Campaign_Deck_Variance_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Campaign_Delete_At_Path_Input = {
  campaignNotes?: InputMaybe<Array<Scalars['String']['input']>>;
  chaosBag?: InputMaybe<Array<Scalars['String']['input']>>;
  scenarioResults?: InputMaybe<Array<Scalars['String']['input']>>;
  standaloneId?: InputMaybe<Array<Scalars['String']['input']>>;
  tarot_reading?: InputMaybe<Array<Scalars['String']['input']>>;
  weaknessSet?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Campaign_Delete_Elem_Input = {
  campaignNotes?: InputMaybe<Scalars['Int']['input']>;
  chaosBag?: InputMaybe<Scalars['Int']['input']>;
  scenarioResults?: InputMaybe<Scalars['Int']['input']>;
  standaloneId?: InputMaybe<Scalars['Int']['input']>;
  tarot_reading?: InputMaybe<Scalars['Int']['input']>;
  weaknessSet?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Campaign_Delete_Key_Input = {
  campaignNotes?: InputMaybe<Scalars['String']['input']>;
  chaosBag?: InputMaybe<Scalars['String']['input']>;
  scenarioResults?: InputMaybe<Scalars['String']['input']>;
  standaloneId?: InputMaybe<Scalars['String']['input']>;
  tarot_reading?: InputMaybe<Scalars['String']['input']>;
  weaknessSet?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "campaign_difficulty" */
export type Campaign_Difficulty = {
  __typename?: 'campaign_difficulty';
  value: Scalars['String']['output'];
};

/** aggregated selection of "campaign_difficulty" */
export type Campaign_Difficulty_Aggregate = {
  __typename?: 'campaign_difficulty_aggregate';
  aggregate?: Maybe<Campaign_Difficulty_Aggregate_Fields>;
  nodes: Array<Campaign_Difficulty>;
};

/** aggregate fields of "campaign_difficulty" */
export type Campaign_Difficulty_Aggregate_Fields = {
  __typename?: 'campaign_difficulty_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Difficulty_Max_Fields>;
  min?: Maybe<Campaign_Difficulty_Min_Fields>;
};


/** aggregate fields of "campaign_difficulty" */
export type Campaign_Difficulty_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Difficulty_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "campaign_difficulty". All fields are combined with a logical 'AND'. */
export type Campaign_Difficulty_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Difficulty_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Difficulty_Bool_Exp>>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "campaign_difficulty" */
export enum Campaign_Difficulty_Constraint {
  /** unique or primary key constraint on columns "value" */
  CampaignDifficultyPkey = 'campaign_difficulty_pkey'
}

export enum Campaign_Difficulty_Enum {
  Easy = 'easy',
  Expert = 'expert',
  Hard = 'hard',
  Standard = 'standard'
}

/** Boolean expression to compare columns of type "campaign_difficulty_enum". All fields are combined with logical 'AND'. */
export type Campaign_Difficulty_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Campaign_Difficulty_Enum>;
  _in?: InputMaybe<Array<Campaign_Difficulty_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Campaign_Difficulty_Enum>;
  _nin?: InputMaybe<Array<Campaign_Difficulty_Enum>>;
};

/** input type for inserting data into table "campaign_difficulty" */
export type Campaign_Difficulty_Insert_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Campaign_Difficulty_Max_Fields = {
  __typename?: 'campaign_difficulty_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Campaign_Difficulty_Min_Fields = {
  __typename?: 'campaign_difficulty_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "campaign_difficulty" */
export type Campaign_Difficulty_Mutation_Response = {
  __typename?: 'campaign_difficulty_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign_Difficulty>;
};

/** on_conflict condition type for table "campaign_difficulty" */
export type Campaign_Difficulty_On_Conflict = {
  constraint: Campaign_Difficulty_Constraint;
  update_columns?: Array<Campaign_Difficulty_Update_Column>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};

/** Ordering options when selecting data from "campaign_difficulty". */
export type Campaign_Difficulty_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: campaign_difficulty */
export type Campaign_Difficulty_Pk_Columns_Input = {
  value: Scalars['String']['input'];
};

/** select columns of table "campaign_difficulty" */
export enum Campaign_Difficulty_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "campaign_difficulty" */
export type Campaign_Difficulty_Set_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "campaign_difficulty" */
export type Campaign_Difficulty_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Difficulty_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Difficulty_Stream_Cursor_Value_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "campaign_difficulty" */
export enum Campaign_Difficulty_Update_Column {
  /** column name */
  Value = 'value'
}

export type Campaign_Difficulty_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Difficulty_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Difficulty_Bool_Exp;
};

/** columns and relationships of "campaign_guide" */
export type Campaign_Guide = {
  __typename?: 'campaign_guide';
  /** An array relationship */
  access: Array<Campaign_Access>;
  /** An aggregate relationship */
  access_aggregate: Campaign_Access_Aggregate;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  guide_achievements: Array<Guide_Achievement>;
  /** An aggregate relationship */
  guide_achievements_aggregate: Guide_Achievement_Aggregate;
  /** An array relationship */
  guide_inputs: Array<Guide_Input>;
  /** An aggregate relationship */
  guide_inputs_aggregate: Guide_Input_Aggregate;
  id?: Maybe<Scalars['Int']['output']>;
  owner?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideAccessArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideAccess_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideGuide_AchievementsArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideGuide_Achievements_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideGuide_InputsArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideGuide_Inputs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};

/** aggregated selection of "campaign_guide" */
export type Campaign_Guide_Aggregate = {
  __typename?: 'campaign_guide_aggregate';
  aggregate?: Maybe<Campaign_Guide_Aggregate_Fields>;
  nodes: Array<Campaign_Guide>;
};

/** aggregate fields of "campaign_guide" */
export type Campaign_Guide_Aggregate_Fields = {
  __typename?: 'campaign_guide_aggregate_fields';
  avg?: Maybe<Campaign_Guide_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Guide_Max_Fields>;
  min?: Maybe<Campaign_Guide_Min_Fields>;
  stddev?: Maybe<Campaign_Guide_Stddev_Fields>;
  stddev_pop?: Maybe<Campaign_Guide_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaign_Guide_Stddev_Samp_Fields>;
  sum?: Maybe<Campaign_Guide_Sum_Fields>;
  var_pop?: Maybe<Campaign_Guide_Var_Pop_Fields>;
  var_samp?: Maybe<Campaign_Guide_Var_Samp_Fields>;
  variance?: Maybe<Campaign_Guide_Variance_Fields>;
};


/** aggregate fields of "campaign_guide" */
export type Campaign_Guide_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Guide_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Campaign_Guide_Avg_Fields = {
  __typename?: 'campaign_guide_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "campaign_guide". All fields are combined with a logical 'AND'. */
export type Campaign_Guide_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Guide_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Guide_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Guide_Bool_Exp>>;
  access?: InputMaybe<Campaign_Access_Bool_Exp>;
  access_aggregate?: InputMaybe<Campaign_Access_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  guide_achievements?: InputMaybe<Guide_Achievement_Bool_Exp>;
  guide_achievements_aggregate?: InputMaybe<Guide_Achievement_Aggregate_Bool_Exp>;
  guide_inputs?: InputMaybe<Guide_Input_Bool_Exp>;
  guide_inputs_aggregate?: InputMaybe<Guide_Input_Aggregate_Bool_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  owner?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "campaign_guide" */
export type Campaign_Guide_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "campaign_guide" */
export type Campaign_Guide_Insert_Input = {
  access?: InputMaybe<Campaign_Access_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  guide_achievements?: InputMaybe<Guide_Achievement_Arr_Rel_Insert_Input>;
  guide_inputs?: InputMaybe<Guide_Input_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Campaign_Guide_Max_Fields = {
  __typename?: 'campaign_guide_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Campaign_Guide_Min_Fields = {
  __typename?: 'campaign_guide_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "campaign_guide" */
export type Campaign_Guide_Mutation_Response = {
  __typename?: 'campaign_guide_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign_Guide>;
};

/** input type for inserting object relation for remote table "campaign_guide" */
export type Campaign_Guide_Obj_Rel_Insert_Input = {
  data: Campaign_Guide_Insert_Input;
};

/** Ordering options when selecting data from "campaign_guide". */
export type Campaign_Guide_Order_By = {
  access_aggregate?: InputMaybe<Campaign_Access_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  guide_achievements_aggregate?: InputMaybe<Guide_Achievement_Aggregate_Order_By>;
  guide_inputs_aggregate?: InputMaybe<Guide_Input_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  owner?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** select columns of table "campaign_guide" */
export enum Campaign_Guide_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Owner = 'owner',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "campaign_guide" */
export type Campaign_Guide_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Campaign_Guide_Stddev_Fields = {
  __typename?: 'campaign_guide_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Campaign_Guide_Stddev_Pop_Fields = {
  __typename?: 'campaign_guide_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Campaign_Guide_Stddev_Samp_Fields = {
  __typename?: 'campaign_guide_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "campaign_guide" */
export type Campaign_Guide_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Guide_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Guide_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Campaign_Guide_Sum_Fields = {
  __typename?: 'campaign_guide_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

export type Campaign_Guide_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Campaign_Guide_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Guide_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Guide_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Campaign_Guide_Var_Pop_Fields = {
  __typename?: 'campaign_guide_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Campaign_Guide_Var_Samp_Fields = {
  __typename?: 'campaign_guide_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Campaign_Guide_Variance_Fields = {
  __typename?: 'campaign_guide_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** input type for incrementing numeric columns in table "campaign" */
export type Campaign_Inc_Input = {
  guide_version?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  link_a_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_b_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "campaign" */
export type Campaign_Insert_Input = {
  access?: InputMaybe<Campaign_Access_Arr_Rel_Insert_Input>;
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  base_decks?: InputMaybe<Base_Decks_Arr_Rel_Insert_Input>;
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  campaign_guide?: InputMaybe<Campaign_Guide_Obj_Rel_Insert_Input>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  chaos_bag_result?: InputMaybe<Chaos_Bag_Result_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cycleCode?: InputMaybe<Scalars['String']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  difficulty?: InputMaybe<Scalars['String']['input']>;
  guide_version?: InputMaybe<Scalars['Int']['input']>;
  guided?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  investigator_data?: InputMaybe<Investigator_Data_Arr_Rel_Insert_Input>;
  investigators?: InputMaybe<Campaign_Investigator_Arr_Rel_Insert_Input>;
  latest_decks?: InputMaybe<Latest_Decks_Arr_Rel_Insert_Input>;
  link_a_campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  link_a_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_b_campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  link_b_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  linked_campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  showInterludes?: InputMaybe<Scalars['Boolean']['input']>;
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  tarot_reading?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
};

/** columns and relationships of "campaign_investigator" */
export type Campaign_Investigator = {
  __typename?: 'campaign_investigator';
  /** An object relationship */
  campaign: Campaign;
  campaign_id: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** A computed field, executes function "campaign_investigator_id" */
  id?: Maybe<Scalars['String']['output']>;
  investigator: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "campaign_investigator" */
export type Campaign_Investigator_Aggregate = {
  __typename?: 'campaign_investigator_aggregate';
  aggregate?: Maybe<Campaign_Investigator_Aggregate_Fields>;
  nodes: Array<Campaign_Investigator>;
};

export type Campaign_Investigator_Aggregate_Bool_Exp = {
  count?: InputMaybe<Campaign_Investigator_Aggregate_Bool_Exp_Count>;
};

export type Campaign_Investigator_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Investigator_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "campaign_investigator" */
export type Campaign_Investigator_Aggregate_Fields = {
  __typename?: 'campaign_investigator_aggregate_fields';
  avg?: Maybe<Campaign_Investigator_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Investigator_Max_Fields>;
  min?: Maybe<Campaign_Investigator_Min_Fields>;
  stddev?: Maybe<Campaign_Investigator_Stddev_Fields>;
  stddev_pop?: Maybe<Campaign_Investigator_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaign_Investigator_Stddev_Samp_Fields>;
  sum?: Maybe<Campaign_Investigator_Sum_Fields>;
  var_pop?: Maybe<Campaign_Investigator_Var_Pop_Fields>;
  var_samp?: Maybe<Campaign_Investigator_Var_Samp_Fields>;
  variance?: Maybe<Campaign_Investigator_Variance_Fields>;
};


/** aggregate fields of "campaign_investigator" */
export type Campaign_Investigator_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "campaign_investigator" */
export type Campaign_Investigator_Aggregate_Order_By = {
  avg?: InputMaybe<Campaign_Investigator_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Campaign_Investigator_Max_Order_By>;
  min?: InputMaybe<Campaign_Investigator_Min_Order_By>;
  stddev?: InputMaybe<Campaign_Investigator_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Campaign_Investigator_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Campaign_Investigator_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Campaign_Investigator_Sum_Order_By>;
  var_pop?: InputMaybe<Campaign_Investigator_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Campaign_Investigator_Var_Samp_Order_By>;
  variance?: InputMaybe<Campaign_Investigator_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "campaign_investigator" */
export type Campaign_Investigator_Arr_Rel_Insert_Input = {
  data: Array<Campaign_Investigator_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Campaign_Investigator_On_Conflict>;
};

/** aggregate avg on columns */
export type Campaign_Investigator_Avg_Fields = {
  __typename?: 'campaign_investigator_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "campaign_investigator". All fields are combined with a logical 'AND'. */
export type Campaign_Investigator_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Investigator_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Investigator_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Investigator_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  investigator?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "campaign_investigator" */
export enum Campaign_Investigator_Constraint {
  /** unique or primary key constraint on columns "campaign_id", "investigator" */
  CampaignInvestigatorCampaignIdInvestigatorKey = 'campaign_investigator_campaign_id_investigator_key',
  /** unique or primary key constraint on columns "campaign_id", "investigator" */
  CampaignInvestigatorPkey = 'campaign_investigator_pkey'
}

/** input type for incrementing numeric columns in table "campaign_investigator" */
export type Campaign_Investigator_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "campaign_investigator" */
export type Campaign_Investigator_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Campaign_Investigator_Max_Fields = {
  __typename?: 'campaign_investigator_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "campaign_investigator_id" */
  id?: Maybe<Scalars['String']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Campaign_Investigator_Min_Fields = {
  __typename?: 'campaign_investigator_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "campaign_investigator_id" */
  id?: Maybe<Scalars['String']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "campaign_investigator" */
export type Campaign_Investigator_Mutation_Response = {
  __typename?: 'campaign_investigator_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign_Investigator>;
};

/** on_conflict condition type for table "campaign_investigator" */
export type Campaign_Investigator_On_Conflict = {
  constraint: Campaign_Investigator_Constraint;
  update_columns?: Array<Campaign_Investigator_Update_Column>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};

/** Ordering options when selecting data from "campaign_investigator". */
export type Campaign_Investigator_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: campaign_investigator */
export type Campaign_Investigator_Pk_Columns_Input = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};

/** select columns of table "campaign_investigator" */
export enum Campaign_Investigator_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "campaign_investigator" */
export type Campaign_Investigator_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Campaign_Investigator_Stddev_Fields = {
  __typename?: 'campaign_investigator_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Campaign_Investigator_Stddev_Pop_Fields = {
  __typename?: 'campaign_investigator_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Campaign_Investigator_Stddev_Samp_Fields = {
  __typename?: 'campaign_investigator_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "campaign_investigator" */
export type Campaign_Investigator_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Investigator_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Investigator_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Campaign_Investigator_Sum_Fields = {
  __typename?: 'campaign_investigator_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** update columns of table "campaign_investigator" */
export enum Campaign_Investigator_Update_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Campaign_Investigator_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Campaign_Investigator_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Investigator_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Investigator_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Campaign_Investigator_Var_Pop_Fields = {
  __typename?: 'campaign_investigator_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Campaign_Investigator_Var_Samp_Fields = {
  __typename?: 'campaign_investigator_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Campaign_Investigator_Variance_Fields = {
  __typename?: 'campaign_investigator_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate max on columns */
export type Campaign_Max_Fields = {
  __typename?: 'campaign_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  cycleCode?: Maybe<Scalars['String']['output']>;
  difficulty?: Maybe<Scalars['String']['output']>;
  guide_version?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_campaign_id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Campaign_Min_Fields = {
  __typename?: 'campaign_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  cycleCode?: Maybe<Scalars['String']['output']>;
  difficulty?: Maybe<Scalars['String']['output']>;
  guide_version?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_campaign_id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "campaign" */
export type Campaign_Mutation_Response = {
  __typename?: 'campaign_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign>;
};

/** input type for inserting object relation for remote table "campaign" */
export type Campaign_Obj_Rel_Insert_Input = {
  data: Campaign_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Campaign_On_Conflict>;
};

/** on_conflict condition type for table "campaign" */
export type Campaign_On_Conflict = {
  constraint: Campaign_Constraint;
  update_columns?: Array<Campaign_Update_Column>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};

/** Ordering options when selecting data from "campaign". */
export type Campaign_Order_By = {
  access_aggregate?: InputMaybe<Campaign_Access_Aggregate_Order_By>;
  archived?: InputMaybe<Order_By>;
  base_decks_aggregate?: InputMaybe<Base_Decks_Aggregate_Order_By>;
  campaignNotes?: InputMaybe<Order_By>;
  campaign_guide?: InputMaybe<Campaign_Guide_Order_By>;
  chaosBag?: InputMaybe<Order_By>;
  chaos_bag_result_aggregate?: InputMaybe<Chaos_Bag_Result_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  cycleCode?: InputMaybe<Order_By>;
  deleted?: InputMaybe<Order_By>;
  difficulty?: InputMaybe<Order_By>;
  guide_version?: InputMaybe<Order_By>;
  guided?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  investigator_data_aggregate?: InputMaybe<Investigator_Data_Aggregate_Order_By>;
  investigators_aggregate?: InputMaybe<Campaign_Investigator_Aggregate_Order_By>;
  latest_decks_aggregate?: InputMaybe<Latest_Decks_Aggregate_Order_By>;
  link_a_campaign?: InputMaybe<Campaign_Order_By>;
  link_a_campaign_id?: InputMaybe<Order_By>;
  link_b_campaign?: InputMaybe<Campaign_Order_By>;
  link_b_campaign_id?: InputMaybe<Order_By>;
  link_campaign_id?: InputMaybe<Order_By>;
  linked_campaign?: InputMaybe<Campaign_Order_By>;
  name?: InputMaybe<Order_By>;
  owner?: InputMaybe<Users_Order_By>;
  owner_id?: InputMaybe<Order_By>;
  scenarioResults?: InputMaybe<Order_By>;
  showInterludes?: InputMaybe<Order_By>;
  standaloneId?: InputMaybe<Order_By>;
  tarot_reading?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  weaknessSet?: InputMaybe<Order_By>;
};

/** primary key columns input for table: campaign */
export type Campaign_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Campaign_Prepend_Input = {
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  tarot_reading?: InputMaybe<Scalars['jsonb']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "campaign" */
export enum Campaign_Select_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  CampaignNotes = 'campaignNotes',
  /** column name */
  ChaosBag = 'chaosBag',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CycleCode = 'cycleCode',
  /** column name */
  Deleted = 'deleted',
  /** column name */
  Difficulty = 'difficulty',
  /** column name */
  GuideVersion = 'guide_version',
  /** column name */
  Guided = 'guided',
  /** column name */
  Id = 'id',
  /** column name */
  LinkACampaignId = 'link_a_campaign_id',
  /** column name */
  LinkBCampaignId = 'link_b_campaign_id',
  /** column name */
  LinkCampaignId = 'link_campaign_id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  ScenarioResults = 'scenarioResults',
  /** column name */
  ShowInterludes = 'showInterludes',
  /** column name */
  StandaloneId = 'standaloneId',
  /** column name */
  TarotReading = 'tarot_reading',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WeaknessSet = 'weaknessSet'
}

/** input type for updating data in table "campaign" */
export type Campaign_Set_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cycleCode?: InputMaybe<Scalars['String']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  difficulty?: InputMaybe<Scalars['String']['input']>;
  guide_version?: InputMaybe<Scalars['Int']['input']>;
  guided?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  link_a_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_b_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  showInterludes?: InputMaybe<Scalars['Boolean']['input']>;
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  tarot_reading?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate stddev on columns */
export type Campaign_Stddev_Fields = {
  __typename?: 'campaign_stddev_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Campaign_Stddev_Pop_Fields = {
  __typename?: 'campaign_stddev_pop_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Campaign_Stddev_Samp_Fields = {
  __typename?: 'campaign_stddev_samp_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "campaign" */
export type Campaign_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Stream_Cursor_Value_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cycleCode?: InputMaybe<Scalars['String']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  difficulty?: InputMaybe<Scalars['String']['input']>;
  guide_version?: InputMaybe<Scalars['Int']['input']>;
  guided?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  link_a_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_b_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  showInterludes?: InputMaybe<Scalars['Boolean']['input']>;
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  tarot_reading?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate sum on columns */
export type Campaign_Sum_Fields = {
  __typename?: 'campaign_sum_fields';
  guide_version?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_campaign_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "campaign" */
export enum Campaign_Update_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  CampaignNotes = 'campaignNotes',
  /** column name */
  ChaosBag = 'chaosBag',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CycleCode = 'cycleCode',
  /** column name */
  Deleted = 'deleted',
  /** column name */
  Difficulty = 'difficulty',
  /** column name */
  GuideVersion = 'guide_version',
  /** column name */
  Guided = 'guided',
  /** column name */
  Id = 'id',
  /** column name */
  LinkACampaignId = 'link_a_campaign_id',
  /** column name */
  LinkBCampaignId = 'link_b_campaign_id',
  /** column name */
  LinkCampaignId = 'link_campaign_id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  ScenarioResults = 'scenarioResults',
  /** column name */
  ShowInterludes = 'showInterludes',
  /** column name */
  StandaloneId = 'standaloneId',
  /** column name */
  TarotReading = 'tarot_reading',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WeaknessSet = 'weaknessSet'
}

export type Campaign_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Campaign_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Campaign_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Campaign_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Campaign_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Campaign_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Campaign_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Campaign_Var_Pop_Fields = {
  __typename?: 'campaign_var_pop_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Campaign_Var_Samp_Fields = {
  __typename?: 'campaign_var_samp_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Campaign_Variance_Fields = {
  __typename?: 'campaign_variance_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "campaigns_by_cycle" */
export type Campaigns_By_Cycle = {
  __typename?: 'campaigns_by_cycle';
  count?: Maybe<Scalars['bigint']['output']>;
  cyclecode?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "campaigns_by_cycle" */
export type Campaigns_By_Cycle_Aggregate = {
  __typename?: 'campaigns_by_cycle_aggregate';
  aggregate?: Maybe<Campaigns_By_Cycle_Aggregate_Fields>;
  nodes: Array<Campaigns_By_Cycle>;
};

/** aggregate fields of "campaigns_by_cycle" */
export type Campaigns_By_Cycle_Aggregate_Fields = {
  __typename?: 'campaigns_by_cycle_aggregate_fields';
  avg?: Maybe<Campaigns_By_Cycle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaigns_By_Cycle_Max_Fields>;
  min?: Maybe<Campaigns_By_Cycle_Min_Fields>;
  stddev?: Maybe<Campaigns_By_Cycle_Stddev_Fields>;
  stddev_pop?: Maybe<Campaigns_By_Cycle_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaigns_By_Cycle_Stddev_Samp_Fields>;
  sum?: Maybe<Campaigns_By_Cycle_Sum_Fields>;
  var_pop?: Maybe<Campaigns_By_Cycle_Var_Pop_Fields>;
  var_samp?: Maybe<Campaigns_By_Cycle_Var_Samp_Fields>;
  variance?: Maybe<Campaigns_By_Cycle_Variance_Fields>;
};


/** aggregate fields of "campaigns_by_cycle" */
export type Campaigns_By_Cycle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaigns_By_Cycle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Campaigns_By_Cycle_Avg_Fields = {
  __typename?: 'campaigns_by_cycle_avg_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "campaigns_by_cycle". All fields are combined with a logical 'AND'. */
export type Campaigns_By_Cycle_Bool_Exp = {
  _and?: InputMaybe<Array<Campaigns_By_Cycle_Bool_Exp>>;
  _not?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
  _or?: InputMaybe<Array<Campaigns_By_Cycle_Bool_Exp>>;
  count?: InputMaybe<Bigint_Comparison_Exp>;
  cyclecode?: InputMaybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Campaigns_By_Cycle_Max_Fields = {
  __typename?: 'campaigns_by_cycle_max_fields';
  count?: Maybe<Scalars['bigint']['output']>;
  cyclecode?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Campaigns_By_Cycle_Min_Fields = {
  __typename?: 'campaigns_by_cycle_min_fields';
  count?: Maybe<Scalars['bigint']['output']>;
  cyclecode?: Maybe<Scalars['String']['output']>;
};

/** Ordering options when selecting data from "campaigns_by_cycle". */
export type Campaigns_By_Cycle_Order_By = {
  count?: InputMaybe<Order_By>;
  cyclecode?: InputMaybe<Order_By>;
};

/** select columns of table "campaigns_by_cycle" */
export enum Campaigns_By_Cycle_Select_Column {
  /** column name */
  Count = 'count',
  /** column name */
  Cyclecode = 'cyclecode'
}

/** aggregate stddev on columns */
export type Campaigns_By_Cycle_Stddev_Fields = {
  __typename?: 'campaigns_by_cycle_stddev_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Campaigns_By_Cycle_Stddev_Pop_Fields = {
  __typename?: 'campaigns_by_cycle_stddev_pop_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Campaigns_By_Cycle_Stddev_Samp_Fields = {
  __typename?: 'campaigns_by_cycle_stddev_samp_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "campaigns_by_cycle" */
export type Campaigns_By_Cycle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaigns_By_Cycle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaigns_By_Cycle_Stream_Cursor_Value_Input = {
  count?: InputMaybe<Scalars['bigint']['input']>;
  cyclecode?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Campaigns_By_Cycle_Sum_Fields = {
  __typename?: 'campaigns_by_cycle_sum_fields';
  count?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type Campaigns_By_Cycle_Var_Pop_Fields = {
  __typename?: 'campaigns_by_cycle_var_pop_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Campaigns_By_Cycle_Var_Samp_Fields = {
  __typename?: 'campaigns_by_cycle_var_samp_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Campaigns_By_Cycle_Variance_Fields = {
  __typename?: 'campaigns_by_cycle_variance_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "card" */
export type Card = {
  __typename?: 'card';
  back_link?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code: Scalars['String']['output'];
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  deck_options?: Maybe<Scalars['jsonb']['output']>;
  deck_requirements?: Maybe<Scalars['jsonb']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  double_sided?: Maybe<Scalars['Boolean']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  exceptional?: Maybe<Scalars['Boolean']['output']>;
  exile?: Maybe<Scalars['Boolean']['output']>;
  faction_code: Scalars['String']['output'];
  health?: Maybe<Scalars['Int']['output']>;
  hidden?: Maybe<Scalars['Boolean']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  is_unique?: Maybe<Scalars['Boolean']['output']>;
  myriad?: Maybe<Scalars['Boolean']['output']>;
  pack_code: Scalars['String']['output'];
  pack_position: Scalars['Int']['output'];
  /** An array relationship */
  packs: Array<Card_Pack>;
  /** An aggregate relationship */
  packs_aggregate: Card_Pack_Aggregate;
  permanent?: Maybe<Scalars['Boolean']['output']>;
  position: Scalars['Int']['output'];
  quantity: Scalars['Int']['output'];
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name: Scalars['String']['output'];
  real_pack_name: Scalars['String']['output'];
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  restrictions?: Maybe<Scalars['jsonb']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  translations: Array<Card_Text>;
  /** An aggregate relationship */
  translations_aggregate: Card_Text_Aggregate;
  type_code: Scalars['String']['output'];
  victory?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "card" */
export type CardDeck_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "card" */
export type CardDeck_RequirementsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "card" */
export type CardPacksArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "card" */
export type CardPacks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "card" */
export type CardRestrictionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "card" */
export type CardTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


/** columns and relationships of "card" */
export type CardTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};

/** aggregated selection of "card" */
export type Card_Aggregate = {
  __typename?: 'card_aggregate';
  aggregate?: Maybe<Card_Aggregate_Fields>;
  nodes: Array<Card>;
};

/** aggregate fields of "card" */
export type Card_Aggregate_Fields = {
  __typename?: 'card_aggregate_fields';
  avg?: Maybe<Card_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Max_Fields>;
  min?: Maybe<Card_Min_Fields>;
  stddev?: Maybe<Card_Stddev_Fields>;
  stddev_pop?: Maybe<Card_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Card_Stddev_Samp_Fields>;
  sum?: Maybe<Card_Sum_Fields>;
  var_pop?: Maybe<Card_Var_Pop_Fields>;
  var_samp?: Maybe<Card_Var_Samp_Fields>;
  variance?: Maybe<Card_Variance_Fields>;
};


/** aggregate fields of "card" */
export type Card_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Card_Append_Input = {
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Card_Avg_Fields = {
  __typename?: 'card_avg_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "card". All fields are combined with a logical 'AND'. */
export type Card_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Bool_Exp>>;
  _not?: InputMaybe<Card_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Bool_Exp>>;
  back_link?: InputMaybe<String_Comparison_Exp>;
  clues?: InputMaybe<Int_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  deck_limit?: InputMaybe<Int_Comparison_Exp>;
  deck_options?: InputMaybe<Jsonb_Comparison_Exp>;
  deck_requirements?: InputMaybe<Jsonb_Comparison_Exp>;
  doom?: InputMaybe<Int_Comparison_Exp>;
  double_sided?: InputMaybe<Boolean_Comparison_Exp>;
  encounter_code?: InputMaybe<String_Comparison_Exp>;
  encounter_position?: InputMaybe<Int_Comparison_Exp>;
  enemy_damage?: InputMaybe<Int_Comparison_Exp>;
  enemy_evade?: InputMaybe<Int_Comparison_Exp>;
  enemy_fight?: InputMaybe<Int_Comparison_Exp>;
  enemy_horror?: InputMaybe<Int_Comparison_Exp>;
  exceptional?: InputMaybe<Boolean_Comparison_Exp>;
  exile?: InputMaybe<Boolean_Comparison_Exp>;
  faction_code?: InputMaybe<String_Comparison_Exp>;
  health?: InputMaybe<Int_Comparison_Exp>;
  hidden?: InputMaybe<Boolean_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  is_unique?: InputMaybe<Boolean_Comparison_Exp>;
  myriad?: InputMaybe<Boolean_Comparison_Exp>;
  pack_code?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  packs?: InputMaybe<Card_Pack_Bool_Exp>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Bool_Exp>;
  permanent?: InputMaybe<Boolean_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  real_back_flavor?: InputMaybe<String_Comparison_Exp>;
  real_back_name?: InputMaybe<String_Comparison_Exp>;
  real_back_text?: InputMaybe<String_Comparison_Exp>;
  real_flavor?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_pack_name?: InputMaybe<String_Comparison_Exp>;
  real_slot?: InputMaybe<String_Comparison_Exp>;
  real_subname?: InputMaybe<String_Comparison_Exp>;
  real_text?: InputMaybe<String_Comparison_Exp>;
  real_traits?: InputMaybe<String_Comparison_Exp>;
  restrictions?: InputMaybe<Jsonb_Comparison_Exp>;
  sanity?: InputMaybe<Int_Comparison_Exp>;
  shroud?: InputMaybe<Int_Comparison_Exp>;
  skill_agility?: InputMaybe<Int_Comparison_Exp>;
  skill_combat?: InputMaybe<Int_Comparison_Exp>;
  skill_intellect?: InputMaybe<Int_Comparison_Exp>;
  skill_wild?: InputMaybe<Int_Comparison_Exp>;
  skill_willpower?: InputMaybe<Int_Comparison_Exp>;
  stage?: InputMaybe<Int_Comparison_Exp>;
  subtype_code?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Card_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Card_Text_Aggregate_Bool_Exp>;
  type_code?: InputMaybe<String_Comparison_Exp>;
  victory?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "card" */
export enum Card_Constraint {
  /** unique or primary key constraint on columns "code" */
  CardPkey = 'card_pkey'
}

/** columns and relationships of "card_cycle" */
export type Card_Cycle = {
  __typename?: 'card_cycle';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  official: Scalars['Boolean']['output'];
  /** An array relationship */
  packs: Array<Card_Pack>;
  /** An aggregate relationship */
  packs_aggregate: Card_Pack_Aggregate;
  position: Scalars['Int']['output'];
};


/** columns and relationships of "card_cycle" */
export type Card_CyclePacksArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "card_cycle" */
export type Card_CyclePacks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};

/** aggregated selection of "card_cycle" */
export type Card_Cycle_Aggregate = {
  __typename?: 'card_cycle_aggregate';
  aggregate?: Maybe<Card_Cycle_Aggregate_Fields>;
  nodes: Array<Card_Cycle>;
};

/** aggregate fields of "card_cycle" */
export type Card_Cycle_Aggregate_Fields = {
  __typename?: 'card_cycle_aggregate_fields';
  avg?: Maybe<Card_Cycle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Cycle_Max_Fields>;
  min?: Maybe<Card_Cycle_Min_Fields>;
  stddev?: Maybe<Card_Cycle_Stddev_Fields>;
  stddev_pop?: Maybe<Card_Cycle_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Card_Cycle_Stddev_Samp_Fields>;
  sum?: Maybe<Card_Cycle_Sum_Fields>;
  var_pop?: Maybe<Card_Cycle_Var_Pop_Fields>;
  var_samp?: Maybe<Card_Cycle_Var_Samp_Fields>;
  variance?: Maybe<Card_Cycle_Variance_Fields>;
};


/** aggregate fields of "card_cycle" */
export type Card_Cycle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Cycle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Card_Cycle_Avg_Fields = {
  __typename?: 'card_cycle_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "card_cycle". All fields are combined with a logical 'AND'. */
export type Card_Cycle_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Cycle_Bool_Exp>>;
  _not?: InputMaybe<Card_Cycle_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Cycle_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
  packs?: InputMaybe<Card_Pack_Bool_Exp>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Bool_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_cycle" */
export enum Card_Cycle_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CardCyclePkey = 'card_cycle_pkey'
}

/** input type for incrementing numeric columns in table "card_cycle" */
export type Card_Cycle_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "card_cycle" */
export type Card_Cycle_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  packs?: InputMaybe<Card_Pack_Arr_Rel_Insert_Input>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Card_Cycle_Max_Fields = {
  __typename?: 'card_cycle_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Card_Cycle_Min_Fields = {
  __typename?: 'card_cycle_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "card_cycle" */
export type Card_Cycle_Mutation_Response = {
  __typename?: 'card_cycle_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Cycle>;
};

/** input type for inserting object relation for remote table "card_cycle" */
export type Card_Cycle_Obj_Rel_Insert_Input = {
  data: Card_Cycle_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Card_Cycle_On_Conflict>;
};

/** on_conflict condition type for table "card_cycle" */
export type Card_Cycle_On_Conflict = {
  constraint: Card_Cycle_Constraint;
  update_columns?: Array<Card_Cycle_Update_Column>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};

/** Ordering options when selecting data from "card_cycle". */
export type Card_Cycle_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Order_By>;
  position?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_cycle */
export type Card_Cycle_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "card_cycle" */
export enum Card_Cycle_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position'
}

/** input type for updating data in table "card_cycle" */
export type Card_Cycle_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Card_Cycle_Stddev_Fields = {
  __typename?: 'card_cycle_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Card_Cycle_Stddev_Pop_Fields = {
  __typename?: 'card_cycle_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Card_Cycle_Stddev_Samp_Fields = {
  __typename?: 'card_cycle_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "card_cycle" */
export type Card_Cycle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Cycle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Cycle_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Card_Cycle_Sum_Fields = {
  __typename?: 'card_cycle_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "card_cycle" */
export enum Card_Cycle_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position'
}

export type Card_Cycle_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Card_Cycle_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Cycle_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Cycle_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Card_Cycle_Var_Pop_Fields = {
  __typename?: 'card_cycle_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Card_Cycle_Var_Samp_Fields = {
  __typename?: 'card_cycle_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Card_Cycle_Variance_Fields = {
  __typename?: 'card_cycle_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Card_Delete_At_Path_Input = {
  deck_options?: InputMaybe<Array<Scalars['String']['input']>>;
  deck_requirements?: InputMaybe<Array<Scalars['String']['input']>>;
  restrictions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Card_Delete_Elem_Input = {
  deck_options?: InputMaybe<Scalars['Int']['input']>;
  deck_requirements?: InputMaybe<Scalars['Int']['input']>;
  restrictions?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Card_Delete_Key_Input = {
  deck_options?: InputMaybe<Scalars['String']['input']>;
  deck_requirements?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "card_encounter_set" */
export type Card_Encounter_Set = {
  __typename?: 'card_encounter_set';
  /** An array relationship */
  cards: Array<All_Card>;
  /** An aggregate relationship */
  cards_aggregate: All_Card_Aggregate;
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  official: Scalars['Boolean']['output'];
};


/** columns and relationships of "card_encounter_set" */
export type Card_Encounter_SetCardsArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


/** columns and relationships of "card_encounter_set" */
export type Card_Encounter_SetCards_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};

/** aggregated selection of "card_encounter_set" */
export type Card_Encounter_Set_Aggregate = {
  __typename?: 'card_encounter_set_aggregate';
  aggregate?: Maybe<Card_Encounter_Set_Aggregate_Fields>;
  nodes: Array<Card_Encounter_Set>;
};

export type Card_Encounter_Set_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Card_Encounter_Set_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Card_Encounter_Set_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Card_Encounter_Set_Aggregate_Bool_Exp_Count>;
};

export type Card_Encounter_Set_Aggregate_Bool_Exp_Bool_And = {
  arguments: Card_Encounter_Set_Select_Column_Card_Encounter_Set_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Card_Encounter_Set_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Card_Encounter_Set_Select_Column_Card_Encounter_Set_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Card_Encounter_Set_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "card_encounter_set" */
export type Card_Encounter_Set_Aggregate_Fields = {
  __typename?: 'card_encounter_set_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Encounter_Set_Max_Fields>;
  min?: Maybe<Card_Encounter_Set_Min_Fields>;
};


/** aggregate fields of "card_encounter_set" */
export type Card_Encounter_Set_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "card_encounter_set" */
export type Card_Encounter_Set_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Card_Encounter_Set_Max_Order_By>;
  min?: InputMaybe<Card_Encounter_Set_Min_Order_By>;
};

/** input type for inserting array relation for remote table "card_encounter_set" */
export type Card_Encounter_Set_Arr_Rel_Insert_Input = {
  data: Array<Card_Encounter_Set_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Card_Encounter_Set_On_Conflict>;
};

/** Boolean expression to filter rows from the table "card_encounter_set". All fields are combined with a logical 'AND'. */
export type Card_Encounter_Set_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Encounter_Set_Bool_Exp>>;
  _not?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Encounter_Set_Bool_Exp>>;
  cards?: InputMaybe<All_Card_Bool_Exp>;
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_encounter_set" */
export enum Card_Encounter_Set_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CardEncounterSetPkey = 'card_encounter_set_pkey'
}

/** input type for inserting data into table "card_encounter_set" */
export type Card_Encounter_Set_Insert_Input = {
  cards?: InputMaybe<All_Card_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate max on columns */
export type Card_Encounter_Set_Max_Fields = {
  __typename?: 'card_encounter_set_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "card_encounter_set" */
export type Card_Encounter_Set_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Card_Encounter_Set_Min_Fields = {
  __typename?: 'card_encounter_set_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "card_encounter_set" */
export type Card_Encounter_Set_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "card_encounter_set" */
export type Card_Encounter_Set_Mutation_Response = {
  __typename?: 'card_encounter_set_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Encounter_Set>;
};

/** on_conflict condition type for table "card_encounter_set" */
export type Card_Encounter_Set_On_Conflict = {
  constraint: Card_Encounter_Set_Constraint;
  update_columns?: Array<Card_Encounter_Set_Update_Column>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};

/** Ordering options when selecting data from "card_encounter_set". */
export type Card_Encounter_Set_Order_By = {
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_encounter_set */
export type Card_Encounter_Set_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "card_encounter_set" */
export enum Card_Encounter_Set_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official'
}

/** select "card_encounter_set_aggregate_bool_exp_bool_and_arguments_columns" columns of table "card_encounter_set" */
export enum Card_Encounter_Set_Select_Column_Card_Encounter_Set_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** select "card_encounter_set_aggregate_bool_exp_bool_or_arguments_columns" columns of table "card_encounter_set" */
export enum Card_Encounter_Set_Select_Column_Card_Encounter_Set_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** input type for updating data in table "card_encounter_set" */
export type Card_Encounter_Set_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Streaming cursor of the table "card_encounter_set" */
export type Card_Encounter_Set_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Encounter_Set_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Encounter_Set_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
};

/** update columns of table "card_encounter_set" */
export enum Card_Encounter_Set_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official'
}

export type Card_Encounter_Set_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Encounter_Set_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Encounter_Set_Bool_Exp;
};

/** input type for incrementing numeric columns in table "card" */
export type Card_Inc_Input = {
  clues?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "card" */
export type Card_Insert_Input = {
  back_link?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  packs?: InputMaybe<Card_Pack_Arr_Rel_Insert_Input>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Card_Text_Arr_Rel_Insert_Input>;
  type_code?: InputMaybe<Scalars['String']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Card_Max_Fields = {
  __typename?: 'card_max_fields';
  back_link?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  type_code?: Maybe<Scalars['String']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Card_Min_Fields = {
  __typename?: 'card_min_fields';
  back_link?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  type_code?: Maybe<Scalars['String']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "card" */
export type Card_Mutation_Response = {
  __typename?: 'card_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card>;
};

/** on_conflict condition type for table "card" */
export type Card_On_Conflict = {
  constraint: Card_Constraint;
  update_columns?: Array<Card_Update_Column>;
  where?: InputMaybe<Card_Bool_Exp>;
};

/** Ordering options when selecting data from "card". */
export type Card_Order_By = {
  back_link?: InputMaybe<Order_By>;
  clues?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  deck_options?: InputMaybe<Order_By>;
  deck_requirements?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  double_sided?: InputMaybe<Order_By>;
  encounter_code?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  exceptional?: InputMaybe<Order_By>;
  exile?: InputMaybe<Order_By>;
  faction_code?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  hidden?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  is_unique?: InputMaybe<Order_By>;
  myriad?: InputMaybe<Order_By>;
  pack_code?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Order_By>;
  permanent?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_name?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_pack_name?: InputMaybe<Order_By>;
  real_slot?: InputMaybe<Order_By>;
  real_subname?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  restrictions?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  subtype_code?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Card_Text_Aggregate_Order_By>;
  type_code?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
};

/** columns and relationships of "card_pack" */
export type Card_Pack = {
  __typename?: 'card_pack';
  code: Scalars['String']['output'];
  /** An object relationship */
  cycle?: Maybe<Card_Cycle>;
  cycle_code?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  official: Scalars['Boolean']['output'];
  position?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "card_pack" */
export type Card_Pack_Aggregate = {
  __typename?: 'card_pack_aggregate';
  aggregate?: Maybe<Card_Pack_Aggregate_Fields>;
  nodes: Array<Card_Pack>;
};

export type Card_Pack_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Card_Pack_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Card_Pack_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Card_Pack_Aggregate_Bool_Exp_Count>;
};

export type Card_Pack_Aggregate_Bool_Exp_Bool_And = {
  arguments: Card_Pack_Select_Column_Card_Pack_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Pack_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Card_Pack_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Card_Pack_Select_Column_Card_Pack_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Pack_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Card_Pack_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Card_Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Pack_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "card_pack" */
export type Card_Pack_Aggregate_Fields = {
  __typename?: 'card_pack_aggregate_fields';
  avg?: Maybe<Card_Pack_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Pack_Max_Fields>;
  min?: Maybe<Card_Pack_Min_Fields>;
  stddev?: Maybe<Card_Pack_Stddev_Fields>;
  stddev_pop?: Maybe<Card_Pack_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Card_Pack_Stddev_Samp_Fields>;
  sum?: Maybe<Card_Pack_Sum_Fields>;
  var_pop?: Maybe<Card_Pack_Var_Pop_Fields>;
  var_samp?: Maybe<Card_Pack_Var_Samp_Fields>;
  variance?: Maybe<Card_Pack_Variance_Fields>;
};


/** aggregate fields of "card_pack" */
export type Card_Pack_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "card_pack" */
export type Card_Pack_Aggregate_Order_By = {
  avg?: InputMaybe<Card_Pack_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Card_Pack_Max_Order_By>;
  min?: InputMaybe<Card_Pack_Min_Order_By>;
  stddev?: InputMaybe<Card_Pack_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Card_Pack_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Card_Pack_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Card_Pack_Sum_Order_By>;
  var_pop?: InputMaybe<Card_Pack_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Card_Pack_Var_Samp_Order_By>;
  variance?: InputMaybe<Card_Pack_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "card_pack" */
export type Card_Pack_Arr_Rel_Insert_Input = {
  data: Array<Card_Pack_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Card_Pack_On_Conflict>;
};

/** aggregate avg on columns */
export type Card_Pack_Avg_Fields = {
  __typename?: 'card_pack_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "card_pack" */
export type Card_Pack_Avg_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "card_pack". All fields are combined with a logical 'AND'. */
export type Card_Pack_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Pack_Bool_Exp>>;
  _not?: InputMaybe<Card_Pack_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Pack_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  cycle?: InputMaybe<Card_Cycle_Bool_Exp>;
  cycle_code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_pack" */
export enum Card_Pack_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CardPackPkey = 'card_pack_pkey'
}

/** input type for incrementing numeric columns in table "card_pack" */
export type Card_Pack_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "card_pack" */
export type Card_Pack_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  cycle?: InputMaybe<Card_Cycle_Obj_Rel_Insert_Input>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Card_Pack_Max_Fields = {
  __typename?: 'card_pack_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  cycle_code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "card_pack" */
export type Card_Pack_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Card_Pack_Min_Fields = {
  __typename?: 'card_pack_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  cycle_code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "card_pack" */
export type Card_Pack_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "card_pack" */
export type Card_Pack_Mutation_Response = {
  __typename?: 'card_pack_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Pack>;
};

/** on_conflict condition type for table "card_pack" */
export type Card_Pack_On_Conflict = {
  constraint: Card_Pack_Constraint;
  update_columns?: Array<Card_Pack_Update_Column>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};

/** Ordering options when selecting data from "card_pack". */
export type Card_Pack_Order_By = {
  code?: InputMaybe<Order_By>;
  cycle?: InputMaybe<Card_Cycle_Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_pack */
export type Card_Pack_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "card_pack" */
export enum Card_Pack_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CycleCode = 'cycle_code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position'
}

/** select "card_pack_aggregate_bool_exp_bool_and_arguments_columns" columns of table "card_pack" */
export enum Card_Pack_Select_Column_Card_Pack_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** select "card_pack_aggregate_bool_exp_bool_or_arguments_columns" columns of table "card_pack" */
export enum Card_Pack_Select_Column_Card_Pack_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** input type for updating data in table "card_pack" */
export type Card_Pack_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Card_Pack_Stddev_Fields = {
  __typename?: 'card_pack_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "card_pack" */
export type Card_Pack_Stddev_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Card_Pack_Stddev_Pop_Fields = {
  __typename?: 'card_pack_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "card_pack" */
export type Card_Pack_Stddev_Pop_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Card_Pack_Stddev_Samp_Fields = {
  __typename?: 'card_pack_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "card_pack" */
export type Card_Pack_Stddev_Samp_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "card_pack" */
export type Card_Pack_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Pack_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Pack_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Card_Pack_Sum_Fields = {
  __typename?: 'card_pack_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "card_pack" */
export type Card_Pack_Sum_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** update columns of table "card_pack" */
export enum Card_Pack_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CycleCode = 'cycle_code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position'
}

export type Card_Pack_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Card_Pack_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Pack_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Pack_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Card_Pack_Var_Pop_Fields = {
  __typename?: 'card_pack_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "card_pack" */
export type Card_Pack_Var_Pop_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Card_Pack_Var_Samp_Fields = {
  __typename?: 'card_pack_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "card_pack" */
export type Card_Pack_Var_Samp_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Card_Pack_Variance_Fields = {
  __typename?: 'card_pack_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "card_pack" */
export type Card_Pack_Variance_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card */
export type Card_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Card_Prepend_Input = {
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "card" */
export enum Card_Select_Column {
  /** column name */
  BackLink = 'back_link',
  /** column name */
  Clues = 'clues',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Health = 'health',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  Victory = 'victory'
}

/** input type for updating data in table "card" */
export type Card_Set_Input = {
  back_link?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  type_code?: InputMaybe<Scalars['String']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Card_Stddev_Fields = {
  __typename?: 'card_stddev_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Card_Stddev_Pop_Fields = {
  __typename?: 'card_stddev_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Card_Stddev_Samp_Fields = {
  __typename?: 'card_stddev_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "card" */
export type Card_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Stream_Cursor_Value_Input = {
  back_link?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  type_code?: InputMaybe<Scalars['String']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
};

/** columns and relationships of "card_subtype_name" */
export type Card_Subtype_Name = {
  __typename?: 'card_subtype_name';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** aggregated selection of "card_subtype_name" */
export type Card_Subtype_Name_Aggregate = {
  __typename?: 'card_subtype_name_aggregate';
  aggregate?: Maybe<Card_Subtype_Name_Aggregate_Fields>;
  nodes: Array<Card_Subtype_Name>;
};

/** aggregate fields of "card_subtype_name" */
export type Card_Subtype_Name_Aggregate_Fields = {
  __typename?: 'card_subtype_name_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Subtype_Name_Max_Fields>;
  min?: Maybe<Card_Subtype_Name_Min_Fields>;
};


/** aggregate fields of "card_subtype_name" */
export type Card_Subtype_Name_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Subtype_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "card_subtype_name". All fields are combined with a logical 'AND'. */
export type Card_Subtype_Name_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Subtype_Name_Bool_Exp>>;
  _not?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Subtype_Name_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_subtype_name" */
export enum Card_Subtype_Name_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CardSubtypeNamePkey = 'card_subtype_name_pkey'
}

/** input type for inserting data into table "card_subtype_name" */
export type Card_Subtype_Name_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Card_Subtype_Name_Max_Fields = {
  __typename?: 'card_subtype_name_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Card_Subtype_Name_Min_Fields = {
  __typename?: 'card_subtype_name_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "card_subtype_name" */
export type Card_Subtype_Name_Mutation_Response = {
  __typename?: 'card_subtype_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Subtype_Name>;
};

/** on_conflict condition type for table "card_subtype_name" */
export type Card_Subtype_Name_On_Conflict = {
  constraint: Card_Subtype_Name_Constraint;
  update_columns?: Array<Card_Subtype_Name_Update_Column>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};

/** Ordering options when selecting data from "card_subtype_name". */
export type Card_Subtype_Name_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_subtype_name */
export type Card_Subtype_Name_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "card_subtype_name" */
export enum Card_Subtype_Name_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "card_subtype_name" */
export type Card_Subtype_Name_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "card_subtype_name" */
export type Card_Subtype_Name_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Subtype_Name_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Subtype_Name_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "card_subtype_name" */
export enum Card_Subtype_Name_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

export type Card_Subtype_Name_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Subtype_Name_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Subtype_Name_Bool_Exp;
};

/** aggregate sum on columns */
export type Card_Sum_Fields = {
  __typename?: 'card_sum_fields';
  clues?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "card_text" */
export type Card_Text = {
  __typename?: 'card_text';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "card_text" */
export type Card_Text_Aggregate = {
  __typename?: 'card_text_aggregate';
  aggregate?: Maybe<Card_Text_Aggregate_Fields>;
  nodes: Array<Card_Text>;
};

export type Card_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Card_Text_Aggregate_Bool_Exp_Count>;
};

export type Card_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "card_text" */
export type Card_Text_Aggregate_Fields = {
  __typename?: 'card_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Text_Max_Fields>;
  min?: Maybe<Card_Text_Min_Fields>;
};


/** aggregate fields of "card_text" */
export type Card_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "card_text" */
export type Card_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Card_Text_Max_Order_By>;
  min?: InputMaybe<Card_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "card_text" */
export type Card_Text_Arr_Rel_Insert_Input = {
  data: Array<Card_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Card_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "card_text". All fields are combined with a logical 'AND'. */
export type Card_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Text_Bool_Exp>>;
  _not?: InputMaybe<Card_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Text_Bool_Exp>>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_name?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  encounter_name?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  slot?: InputMaybe<String_Comparison_Exp>;
  subname?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_text" */
export enum Card_Text_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CardTextCodeLocaleKey = 'card_text_code_locale_key',
  /** unique or primary key constraint on columns "locale", "code" */
  CardTextPkey = 'card_text_pkey'
}

/** input type for inserting data into table "card_text" */
export type Card_Text_Insert_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Card_Text_Max_Fields = {
  __typename?: 'card_text_max_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "card_text" */
export type Card_Text_Max_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Card_Text_Min_Fields = {
  __typename?: 'card_text_min_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "card_text" */
export type Card_Text_Min_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "card_text" */
export type Card_Text_Mutation_Response = {
  __typename?: 'card_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Text>;
};

/** on_conflict condition type for table "card_text" */
export type Card_Text_On_Conflict = {
  constraint: Card_Text_Constraint;
  update_columns?: Array<Card_Text_Update_Column>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "card_text". */
export type Card_Text_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_text */
export type Card_Text_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "card_text" */
export enum Card_Text_Select_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  Code = 'code',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits'
}

/** input type for updating data in table "card_text" */
export type Card_Text_Set_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "card_text" */
export type Card_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Text_Stream_Cursor_Value_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "card_text" */
export enum Card_Text_Update_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  Code = 'code',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits'
}

export type Card_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Text_Bool_Exp;
};

/** columns and relationships of "card_type_code" */
export type Card_Type_Code = {
  __typename?: 'card_type_code';
  code: Scalars['String']['output'];
};

/** aggregated selection of "card_type_code" */
export type Card_Type_Code_Aggregate = {
  __typename?: 'card_type_code_aggregate';
  aggregate?: Maybe<Card_Type_Code_Aggregate_Fields>;
  nodes: Array<Card_Type_Code>;
};

/** aggregate fields of "card_type_code" */
export type Card_Type_Code_Aggregate_Fields = {
  __typename?: 'card_type_code_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Type_Code_Max_Fields>;
  min?: Maybe<Card_Type_Code_Min_Fields>;
};


/** aggregate fields of "card_type_code" */
export type Card_Type_Code_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Type_Code_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "card_type_code". All fields are combined with a logical 'AND'. */
export type Card_Type_Code_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Type_Code_Bool_Exp>>;
  _not?: InputMaybe<Card_Type_Code_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Type_Code_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_type_code" */
export enum Card_Type_Code_Constraint {
  /** unique or primary key constraint on columns "code" */
  CardTypeCodePkey = 'card_type_code_pkey'
}

export enum Card_Type_Code_Enum {
  Act = 'act',
  Agenda = 'agenda',
  Asset = 'asset',
  Enemy = 'enemy',
  EnemyLocation = 'enemy_location',
  Event = 'event',
  Investigator = 'investigator',
  Key = 'key',
  Location = 'location',
  Scenario = 'scenario',
  Skill = 'skill',
  Story = 'story',
  Treachery = 'treachery'
}

/** Boolean expression to compare columns of type "card_type_code_enum". All fields are combined with logical 'AND'. */
export type Card_Type_Code_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Card_Type_Code_Enum>;
  _in?: InputMaybe<Array<Card_Type_Code_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Card_Type_Code_Enum>;
  _nin?: InputMaybe<Array<Card_Type_Code_Enum>>;
};

/** input type for inserting data into table "card_type_code" */
export type Card_Type_Code_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Card_Type_Code_Max_Fields = {
  __typename?: 'card_type_code_max_fields';
  code?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Card_Type_Code_Min_Fields = {
  __typename?: 'card_type_code_min_fields';
  code?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "card_type_code" */
export type Card_Type_Code_Mutation_Response = {
  __typename?: 'card_type_code_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Type_Code>;
};

/** input type for inserting object relation for remote table "card_type_code" */
export type Card_Type_Code_Obj_Rel_Insert_Input = {
  data: Card_Type_Code_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Card_Type_Code_On_Conflict>;
};

/** on_conflict condition type for table "card_type_code" */
export type Card_Type_Code_On_Conflict = {
  constraint: Card_Type_Code_Constraint;
  update_columns?: Array<Card_Type_Code_Update_Column>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};

/** Ordering options when selecting data from "card_type_code". */
export type Card_Type_Code_Order_By = {
  code?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_type_code */
export type Card_Type_Code_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** select columns of table "card_type_code" */
export enum Card_Type_Code_Select_Column {
  /** column name */
  Code = 'code'
}

/** input type for updating data in table "card_type_code" */
export type Card_Type_Code_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "card_type_code" */
export type Card_Type_Code_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Type_Code_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Type_Code_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "card_type_code" */
export enum Card_Type_Code_Update_Column {
  /** column name */
  Code = 'code'
}

export type Card_Type_Code_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Type_Code_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Type_Code_Bool_Exp;
};

/** columns and relationships of "card_type_name" */
export type Card_Type_Name = {
  __typename?: 'card_type_name';
  code: Card_Type_Code_Enum;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** aggregated selection of "card_type_name" */
export type Card_Type_Name_Aggregate = {
  __typename?: 'card_type_name_aggregate';
  aggregate?: Maybe<Card_Type_Name_Aggregate_Fields>;
  nodes: Array<Card_Type_Name>;
};

/** aggregate fields of "card_type_name" */
export type Card_Type_Name_Aggregate_Fields = {
  __typename?: 'card_type_name_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Type_Name_Max_Fields>;
  min?: Maybe<Card_Type_Name_Min_Fields>;
};


/** aggregate fields of "card_type_name" */
export type Card_Type_Name_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Type_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "card_type_name". All fields are combined with a logical 'AND'. */
export type Card_Type_Name_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Type_Name_Bool_Exp>>;
  _not?: InputMaybe<Card_Type_Name_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Type_Name_Bool_Exp>>;
  code?: InputMaybe<Card_Type_Code_Enum_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_type_name" */
export enum Card_Type_Name_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  TypeNamePkey = 'type_name_pkey'
}

/** input type for inserting data into table "card_type_name" */
export type Card_Type_Name_Insert_Input = {
  code?: InputMaybe<Card_Type_Code_Enum>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Card_Type_Name_Max_Fields = {
  __typename?: 'card_type_name_max_fields';
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Card_Type_Name_Min_Fields = {
  __typename?: 'card_type_name_min_fields';
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "card_type_name" */
export type Card_Type_Name_Mutation_Response = {
  __typename?: 'card_type_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Type_Name>;
};

/** on_conflict condition type for table "card_type_name" */
export type Card_Type_Name_On_Conflict = {
  constraint: Card_Type_Name_Constraint;
  update_columns?: Array<Card_Type_Name_Update_Column>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};

/** Ordering options when selecting data from "card_type_name". */
export type Card_Type_Name_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_type_name */
export type Card_Type_Name_Pk_Columns_Input = {
  code: Card_Type_Code_Enum;
  locale: Scalars['String']['input'];
};

/** select columns of table "card_type_name" */
export enum Card_Type_Name_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "card_type_name" */
export type Card_Type_Name_Set_Input = {
  code?: InputMaybe<Card_Type_Code_Enum>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "card_type_name" */
export type Card_Type_Name_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Type_Name_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Type_Name_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Card_Type_Code_Enum>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "card_type_name" */
export enum Card_Type_Name_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

export type Card_Type_Name_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Type_Name_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Type_Name_Bool_Exp;
};

/** update columns of table "card" */
export enum Card_Update_Column {
  /** column name */
  BackLink = 'back_link',
  /** column name */
  Clues = 'clues',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Health = 'health',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  Victory = 'victory'
}

export type Card_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Card_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Card_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Card_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Card_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Card_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Card_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Card_Var_Pop_Fields = {
  __typename?: 'card_var_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Card_Var_Samp_Fields = {
  __typename?: 'card_var_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Card_Variance_Fields = {
  __typename?: 'card_variance_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "chaos_bag_result" */
export type Chaos_Bag_Result = {
  __typename?: 'chaos_bag_result';
  bless: Scalars['Int']['output'];
  /** An object relationship */
  campaign: Campaign;
  created_at: Scalars['timestamptz']['output'];
  curse: Scalars['Int']['output'];
  difficulty?: Maybe<Campaign_Difficulty_Enum>;
  drawn: Scalars['jsonb']['output'];
  history: Scalars['jsonb']['output'];
  id: Scalars['Int']['output'];
  sealed: Scalars['jsonb']['output'];
  tarot?: Maybe<Chaos_Bag_Tarot_Mode_Enum>;
  /** An object relationship */
  tarot_mode?: Maybe<Chaos_Bag_Tarot_Mode>;
  totalDrawn?: Maybe<Scalars['Int']['output']>;
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "chaos_bag_result" */
export type Chaos_Bag_ResultDrawnArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "chaos_bag_result" */
export type Chaos_Bag_ResultHistoryArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "chaos_bag_result" */
export type Chaos_Bag_ResultSealedArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "chaos_bag_result" */
export type Chaos_Bag_Result_Aggregate = {
  __typename?: 'chaos_bag_result_aggregate';
  aggregate?: Maybe<Chaos_Bag_Result_Aggregate_Fields>;
  nodes: Array<Chaos_Bag_Result>;
};

export type Chaos_Bag_Result_Aggregate_Bool_Exp = {
  count?: InputMaybe<Chaos_Bag_Result_Aggregate_Bool_Exp_Count>;
};

export type Chaos_Bag_Result_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "chaos_bag_result" */
export type Chaos_Bag_Result_Aggregate_Fields = {
  __typename?: 'chaos_bag_result_aggregate_fields';
  avg?: Maybe<Chaos_Bag_Result_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Chaos_Bag_Result_Max_Fields>;
  min?: Maybe<Chaos_Bag_Result_Min_Fields>;
  stddev?: Maybe<Chaos_Bag_Result_Stddev_Fields>;
  stddev_pop?: Maybe<Chaos_Bag_Result_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Chaos_Bag_Result_Stddev_Samp_Fields>;
  sum?: Maybe<Chaos_Bag_Result_Sum_Fields>;
  var_pop?: Maybe<Chaos_Bag_Result_Var_Pop_Fields>;
  var_samp?: Maybe<Chaos_Bag_Result_Var_Samp_Fields>;
  variance?: Maybe<Chaos_Bag_Result_Variance_Fields>;
};


/** aggregate fields of "chaos_bag_result" */
export type Chaos_Bag_Result_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "chaos_bag_result" */
export type Chaos_Bag_Result_Aggregate_Order_By = {
  avg?: InputMaybe<Chaos_Bag_Result_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Chaos_Bag_Result_Max_Order_By>;
  min?: InputMaybe<Chaos_Bag_Result_Min_Order_By>;
  stddev?: InputMaybe<Chaos_Bag_Result_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Chaos_Bag_Result_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Chaos_Bag_Result_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Chaos_Bag_Result_Sum_Order_By>;
  var_pop?: InputMaybe<Chaos_Bag_Result_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Chaos_Bag_Result_Var_Samp_Order_By>;
  variance?: InputMaybe<Chaos_Bag_Result_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chaos_Bag_Result_Append_Input = {
  drawn?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  sealed?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "chaos_bag_result" */
export type Chaos_Bag_Result_Arr_Rel_Insert_Input = {
  data: Array<Chaos_Bag_Result_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Chaos_Bag_Result_On_Conflict>;
};

/** aggregate avg on columns */
export type Chaos_Bag_Result_Avg_Fields = {
  __typename?: 'chaos_bag_result_avg_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Avg_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chaos_bag_result". All fields are combined with a logical 'AND'. */
export type Chaos_Bag_Result_Bool_Exp = {
  _and?: InputMaybe<Array<Chaos_Bag_Result_Bool_Exp>>;
  _not?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
  _or?: InputMaybe<Array<Chaos_Bag_Result_Bool_Exp>>;
  bless?: InputMaybe<Int_Comparison_Exp>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  curse?: InputMaybe<Int_Comparison_Exp>;
  difficulty?: InputMaybe<Campaign_Difficulty_Enum_Comparison_Exp>;
  drawn?: InputMaybe<Jsonb_Comparison_Exp>;
  history?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  sealed?: InputMaybe<Jsonb_Comparison_Exp>;
  tarot?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum_Comparison_Exp>;
  tarot_mode?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
  totalDrawn?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chaos_bag_result" */
export enum Chaos_Bag_Result_Constraint {
  /** unique or primary key constraint on columns "id" */
  ChaosBagPkey = 'chaos_bag_pkey',
  /** unique or primary key constraint on columns "id" */
  ChaosBagResultsCampaignIdKey = 'chaos_bag_results_campaign_id_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chaos_Bag_Result_Delete_At_Path_Input = {
  drawn?: InputMaybe<Array<Scalars['String']['input']>>;
  history?: InputMaybe<Array<Scalars['String']['input']>>;
  sealed?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chaos_Bag_Result_Delete_Elem_Input = {
  drawn?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<Scalars['Int']['input']>;
  sealed?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chaos_Bag_Result_Delete_Key_Input = {
  drawn?: InputMaybe<Scalars['String']['input']>;
  history?: InputMaybe<Scalars['String']['input']>;
  sealed?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "chaos_bag_result" */
export type Chaos_Bag_Result_Inc_Input = {
  bless?: InputMaybe<Scalars['Int']['input']>;
  curse?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  totalDrawn?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "chaos_bag_result" */
export type Chaos_Bag_Result_Insert_Input = {
  bless?: InputMaybe<Scalars['Int']['input']>;
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  curse?: InputMaybe<Scalars['Int']['input']>;
  difficulty?: InputMaybe<Campaign_Difficulty_Enum>;
  drawn?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sealed?: InputMaybe<Scalars['jsonb']['input']>;
  tarot?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  tarot_mode?: InputMaybe<Chaos_Bag_Tarot_Mode_Obj_Rel_Insert_Input>;
  totalDrawn?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Chaos_Bag_Result_Max_Fields = {
  __typename?: 'chaos_bag_result_max_fields';
  bless?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  curse?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  totalDrawn?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Max_Order_By = {
  bless?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Chaos_Bag_Result_Min_Fields = {
  __typename?: 'chaos_bag_result_min_fields';
  bless?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  curse?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  totalDrawn?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Min_Order_By = {
  bless?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "chaos_bag_result" */
export type Chaos_Bag_Result_Mutation_Response = {
  __typename?: 'chaos_bag_result_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Chaos_Bag_Result>;
};

/** on_conflict condition type for table "chaos_bag_result" */
export type Chaos_Bag_Result_On_Conflict = {
  constraint: Chaos_Bag_Result_Constraint;
  update_columns?: Array<Chaos_Bag_Result_Update_Column>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};

/** Ordering options when selecting data from "chaos_bag_result". */
export type Chaos_Bag_Result_Order_By = {
  bless?: InputMaybe<Order_By>;
  campaign?: InputMaybe<Campaign_Order_By>;
  created_at?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  difficulty?: InputMaybe<Order_By>;
  drawn?: InputMaybe<Order_By>;
  history?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  sealed?: InputMaybe<Order_By>;
  tarot?: InputMaybe<Order_By>;
  tarot_mode?: InputMaybe<Chaos_Bag_Tarot_Mode_Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: chaos_bag_result */
export type Chaos_Bag_Result_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chaos_Bag_Result_Prepend_Input = {
  drawn?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  sealed?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "chaos_bag_result" */
export enum Chaos_Bag_Result_Select_Column {
  /** column name */
  Bless = 'bless',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Curse = 'curse',
  /** column name */
  Difficulty = 'difficulty',
  /** column name */
  Drawn = 'drawn',
  /** column name */
  History = 'history',
  /** column name */
  Id = 'id',
  /** column name */
  Sealed = 'sealed',
  /** column name */
  Tarot = 'tarot',
  /** column name */
  TotalDrawn = 'totalDrawn',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chaos_bag_result" */
export type Chaos_Bag_Result_Set_Input = {
  bless?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  curse?: InputMaybe<Scalars['Int']['input']>;
  difficulty?: InputMaybe<Campaign_Difficulty_Enum>;
  drawn?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sealed?: InputMaybe<Scalars['jsonb']['input']>;
  tarot?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  totalDrawn?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Chaos_Bag_Result_Stddev_Fields = {
  __typename?: 'chaos_bag_result_stddev_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Stddev_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chaos_Bag_Result_Stddev_Pop_Fields = {
  __typename?: 'chaos_bag_result_stddev_pop_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Stddev_Pop_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chaos_Bag_Result_Stddev_Samp_Fields = {
  __typename?: 'chaos_bag_result_stddev_samp_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Stddev_Samp_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "chaos_bag_result" */
export type Chaos_Bag_Result_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Chaos_Bag_Result_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Chaos_Bag_Result_Stream_Cursor_Value_Input = {
  bless?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  curse?: InputMaybe<Scalars['Int']['input']>;
  difficulty?: InputMaybe<Campaign_Difficulty_Enum>;
  drawn?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sealed?: InputMaybe<Scalars['jsonb']['input']>;
  tarot?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  totalDrawn?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Chaos_Bag_Result_Sum_Fields = {
  __typename?: 'chaos_bag_result_sum_fields';
  bless?: Maybe<Scalars['Int']['output']>;
  curse?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  totalDrawn?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Sum_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** update columns of table "chaos_bag_result" */
export enum Chaos_Bag_Result_Update_Column {
  /** column name */
  Bless = 'bless',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Curse = 'curse',
  /** column name */
  Difficulty = 'difficulty',
  /** column name */
  Drawn = 'drawn',
  /** column name */
  History = 'history',
  /** column name */
  Id = 'id',
  /** column name */
  Sealed = 'sealed',
  /** column name */
  Tarot = 'tarot',
  /** column name */
  TotalDrawn = 'totalDrawn',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Chaos_Bag_Result_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Chaos_Bag_Result_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Chaos_Bag_Result_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Chaos_Bag_Result_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Chaos_Bag_Result_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Chaos_Bag_Result_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Chaos_Bag_Result_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Chaos_Bag_Result_Set_Input>;
  /** filter the rows which have to be updated */
  where: Chaos_Bag_Result_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Chaos_Bag_Result_Var_Pop_Fields = {
  __typename?: 'chaos_bag_result_var_pop_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Var_Pop_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chaos_Bag_Result_Var_Samp_Fields = {
  __typename?: 'chaos_bag_result_var_samp_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Var_Samp_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Chaos_Bag_Result_Variance_Fields = {
  __typename?: 'chaos_bag_result_variance_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Variance_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** columns and relationships of "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode = {
  __typename?: 'chaos_bag_tarot_mode';
  value: Scalars['String']['output'];
};

/** aggregated selection of "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Aggregate = {
  __typename?: 'chaos_bag_tarot_mode_aggregate';
  aggregate?: Maybe<Chaos_Bag_Tarot_Mode_Aggregate_Fields>;
  nodes: Array<Chaos_Bag_Tarot_Mode>;
};

/** aggregate fields of "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Aggregate_Fields = {
  __typename?: 'chaos_bag_tarot_mode_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Chaos_Bag_Tarot_Mode_Max_Fields>;
  min?: Maybe<Chaos_Bag_Tarot_Mode_Min_Fields>;
};


/** aggregate fields of "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "chaos_bag_tarot_mode". All fields are combined with a logical 'AND'. */
export type Chaos_Bag_Tarot_Mode_Bool_Exp = {
  _and?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Bool_Exp>>;
  _not?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
  _or?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Bool_Exp>>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chaos_bag_tarot_mode" */
export enum Chaos_Bag_Tarot_Mode_Constraint {
  /** unique or primary key constraint on columns "value" */
  ChaosBagTarotModePkey = 'chaos_bag_tarot_mode_pkey'
}

export enum Chaos_Bag_Tarot_Mode_Enum {
  Judgement = 'judgement',
  JudgementInverted = 'judgement_inverted'
}

/** Boolean expression to compare columns of type "chaos_bag_tarot_mode_enum". All fields are combined with logical 'AND'. */
export type Chaos_Bag_Tarot_Mode_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  _in?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  _nin?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Enum>>;
};

/** input type for inserting data into table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Insert_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Chaos_Bag_Tarot_Mode_Max_Fields = {
  __typename?: 'chaos_bag_tarot_mode_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Chaos_Bag_Tarot_Mode_Min_Fields = {
  __typename?: 'chaos_bag_tarot_mode_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Mutation_Response = {
  __typename?: 'chaos_bag_tarot_mode_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Chaos_Bag_Tarot_Mode>;
};

/** input type for inserting object relation for remote table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Obj_Rel_Insert_Input = {
  data: Chaos_Bag_Tarot_Mode_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Chaos_Bag_Tarot_Mode_On_Conflict>;
};

/** on_conflict condition type for table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_On_Conflict = {
  constraint: Chaos_Bag_Tarot_Mode_Constraint;
  update_columns?: Array<Chaos_Bag_Tarot_Mode_Update_Column>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};

/** Ordering options when selecting data from "chaos_bag_tarot_mode". */
export type Chaos_Bag_Tarot_Mode_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: chaos_bag_tarot_mode */
export type Chaos_Bag_Tarot_Mode_Pk_Columns_Input = {
  value: Scalars['String']['input'];
};

/** select columns of table "chaos_bag_tarot_mode" */
export enum Chaos_Bag_Tarot_Mode_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Set_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Chaos_Bag_Tarot_Mode_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Chaos_Bag_Tarot_Mode_Stream_Cursor_Value_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "chaos_bag_tarot_mode" */
export enum Chaos_Bag_Tarot_Mode_Update_Column {
  /** column name */
  Value = 'value'
}

export type Chaos_Bag_Tarot_Mode_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Chaos_Bag_Tarot_Mode_Set_Input>;
  /** filter the rows which have to be updated */
  where: Chaos_Bag_Tarot_Mode_Bool_Exp;
};

/** columns and relationships of "conquest.card" */
export type Conquest_Card = {
  __typename?: 'conquest_card';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  back_tts_sheet_url?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_rules?: Maybe<Scalars['jsonb']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  horizontal?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['String']['output'];
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  pack_id: Scalars['String']['output'];
  position: Scalars['Int']['output'];
  preparation: Scalars['Boolean']['output'];
  quantity?: Maybe<Scalars['Int']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id: Scalars['String']['output'];
  unique: Scalars['Boolean']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "conquest.card" */
export type Conquest_CardDeck_RulesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "conquest.card" */
export type Conquest_Card_Aggregate = {
  __typename?: 'conquest_card_aggregate';
  aggregate?: Maybe<Conquest_Card_Aggregate_Fields>;
  nodes: Array<Conquest_Card>;
};

/** aggregate fields of "conquest.card" */
export type Conquest_Card_Aggregate_Fields = {
  __typename?: 'conquest_card_aggregate_fields';
  avg?: Maybe<Conquest_Card_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Card_Max_Fields>;
  min?: Maybe<Conquest_Card_Min_Fields>;
  stddev?: Maybe<Conquest_Card_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Card_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Card_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Card_Sum_Fields>;
  var_pop?: Maybe<Conquest_Card_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Card_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Card_Variance_Fields>;
};


/** aggregate fields of "conquest.card" */
export type Conquest_Card_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Conquest_Card_Append_Input = {
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Card_Avg_Fields = {
  __typename?: 'conquest_card_avg_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.card". All fields are combined with a logical 'AND'. */
export type Conquest_Card_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Card_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Card_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Card_Bool_Exp>>;
  attack?: InputMaybe<Int_Comparison_Exp>;
  back_attack?: InputMaybe<Int_Comparison_Exp>;
  back_card_id?: InputMaybe<String_Comparison_Exp>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_health?: InputMaybe<Int_Comparison_Exp>;
  back_imagesrc?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  back_traits?: InputMaybe<String_Comparison_Exp>;
  back_tts_sheet_url?: InputMaybe<String_Comparison_Exp>;
  command_hammers?: InputMaybe<Int_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  deck_rules?: InputMaybe<Jsonb_Comparison_Exp>;
  faction_id?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  health?: InputMaybe<Int_Comparison_Exp>;
  horizontal?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  keywords?: InputMaybe<String_Comparison_Exp>;
  loyalty_id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  pack_id?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  preparation?: InputMaybe<Boolean_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  shields?: InputMaybe<Int_Comparison_Exp>;
  signature_id?: InputMaybe<Int_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  tts_sheet_position?: InputMaybe<Int_Comparison_Exp>;
  tts_sheet_url?: InputMaybe<String_Comparison_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  unique?: InputMaybe<Boolean_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.card" */
export enum Conquest_Card_Constraint {
  /** unique or primary key constraint on columns "id" */
  CardPkey = 'card_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Conquest_Card_Delete_At_Path_Input = {
  deck_rules?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Conquest_Card_Delete_Elem_Input = {
  deck_rules?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Conquest_Card_Delete_Key_Input = {
  deck_rules?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "conquest.card" */
export type Conquest_Card_Inc_Input = {
  attack?: InputMaybe<Scalars['Int']['input']>;
  back_attack?: InputMaybe<Scalars['Int']['input']>;
  back_health?: InputMaybe<Scalars['Int']['input']>;
  command_hammers?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  shields?: InputMaybe<Scalars['Int']['input']>;
  signature_id?: InputMaybe<Scalars['Int']['input']>;
  tts_sheet_position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.card" */
export type Conquest_Card_Insert_Input = {
  attack?: InputMaybe<Scalars['Int']['input']>;
  back_attack?: InputMaybe<Scalars['Int']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_health?: InputMaybe<Scalars['Int']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  back_tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  command_hammers?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
  faction_id?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  horizontal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  loyalty_id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preparation?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  shields?: InputMaybe<Scalars['Int']['input']>;
  signature_id?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  tts_sheet_position?: InputMaybe<Scalars['Int']['input']>;
  tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  unique?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "conquest.card_localized" */
export type Conquest_Card_Localized = {
  __typename?: 'conquest_card_localized';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_rules?: Maybe<Scalars['jsonb']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  faction_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  horizontal?: Maybe<Scalars['Boolean']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  loyalty_name?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_cycle_id?: Maybe<Scalars['String']['output']>;
  pack_cycle_name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  preparation?: Maybe<Scalars['Boolean']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_imagesrc?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_keywords?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  unique?: Maybe<Scalars['Boolean']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "conquest.card_localized" */
export type Conquest_Card_LocalizedDeck_RulesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "conquest.card_localized" */
export type Conquest_Card_Localized_Aggregate = {
  __typename?: 'conquest_card_localized_aggregate';
  aggregate?: Maybe<Conquest_Card_Localized_Aggregate_Fields>;
  nodes: Array<Conquest_Card_Localized>;
};

/** aggregate fields of "conquest.card_localized" */
export type Conquest_Card_Localized_Aggregate_Fields = {
  __typename?: 'conquest_card_localized_aggregate_fields';
  avg?: Maybe<Conquest_Card_Localized_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Card_Localized_Max_Fields>;
  min?: Maybe<Conquest_Card_Localized_Min_Fields>;
  stddev?: Maybe<Conquest_Card_Localized_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Card_Localized_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Card_Localized_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Card_Localized_Sum_Fields>;
  var_pop?: Maybe<Conquest_Card_Localized_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Card_Localized_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Card_Localized_Variance_Fields>;
};


/** aggregate fields of "conquest.card_localized" */
export type Conquest_Card_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Card_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Card_Localized_Avg_Fields = {
  __typename?: 'conquest_card_localized_avg_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.card_localized". All fields are combined with a logical 'AND'. */
export type Conquest_Card_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Card_Localized_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Card_Localized_Bool_Exp>>;
  attack?: InputMaybe<Int_Comparison_Exp>;
  back_attack?: InputMaybe<Int_Comparison_Exp>;
  back_card_id?: InputMaybe<String_Comparison_Exp>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_health?: InputMaybe<Int_Comparison_Exp>;
  back_imagesrc?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  back_traits?: InputMaybe<String_Comparison_Exp>;
  command_hammers?: InputMaybe<Int_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  deck_rules?: InputMaybe<Jsonb_Comparison_Exp>;
  faction_id?: InputMaybe<String_Comparison_Exp>;
  faction_name?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  health?: InputMaybe<Int_Comparison_Exp>;
  horizontal?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  keywords?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  loyalty_id?: InputMaybe<String_Comparison_Exp>;
  loyalty_name?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  pack_cycle_id?: InputMaybe<String_Comparison_Exp>;
  pack_cycle_name?: InputMaybe<String_Comparison_Exp>;
  pack_id?: InputMaybe<String_Comparison_Exp>;
  pack_name?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  preparation?: InputMaybe<Boolean_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  real_back_flavor?: InputMaybe<String_Comparison_Exp>;
  real_back_imagesrc?: InputMaybe<String_Comparison_Exp>;
  real_back_text?: InputMaybe<String_Comparison_Exp>;
  real_back_traits?: InputMaybe<String_Comparison_Exp>;
  real_flavor?: InputMaybe<String_Comparison_Exp>;
  real_imagesrc?: InputMaybe<String_Comparison_Exp>;
  real_keywords?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_text?: InputMaybe<String_Comparison_Exp>;
  real_traits?: InputMaybe<String_Comparison_Exp>;
  shields?: InputMaybe<Int_Comparison_Exp>;
  signature_id?: InputMaybe<Int_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  tts_sheet_position?: InputMaybe<Int_Comparison_Exp>;
  tts_sheet_url?: InputMaybe<String_Comparison_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  type_name?: InputMaybe<String_Comparison_Exp>;
  unique?: InputMaybe<Boolean_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Conquest_Card_Localized_Max_Fields = {
  __typename?: 'conquest_card_localized_max_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  faction_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  loyalty_name?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_cycle_id?: Maybe<Scalars['String']['output']>;
  pack_cycle_name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_imagesrc?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_keywords?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Card_Localized_Min_Fields = {
  __typename?: 'conquest_card_localized_min_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  faction_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  loyalty_name?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_cycle_id?: Maybe<Scalars['String']['output']>;
  pack_cycle_name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_imagesrc?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_keywords?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "conquest.card_localized". */
export type Conquest_Card_Localized_Order_By = {
  attack?: InputMaybe<Order_By>;
  back_attack?: InputMaybe<Order_By>;
  back_card_id?: InputMaybe<Order_By>;
  back_flavor?: InputMaybe<Order_By>;
  back_health?: InputMaybe<Order_By>;
  back_imagesrc?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  command_hammers?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_rules?: InputMaybe<Order_By>;
  faction_id?: InputMaybe<Order_By>;
  faction_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  horizontal?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  keywords?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  loyalty_id?: InputMaybe<Order_By>;
  loyalty_name?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  pack_cycle_id?: InputMaybe<Order_By>;
  pack_cycle_name?: InputMaybe<Order_By>;
  pack_id?: InputMaybe<Order_By>;
  pack_name?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  preparation?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_imagesrc?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_back_traits?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_imagesrc?: InputMaybe<Order_By>;
  real_keywords?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  shields?: InputMaybe<Order_By>;
  signature_id?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  tts_sheet_position?: InputMaybe<Order_By>;
  tts_sheet_url?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  type_name?: InputMaybe<Order_By>;
  unique?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "conquest.card_localized" */
export enum Conquest_Card_Localized_Select_Column {
  /** column name */
  Attack = 'attack',
  /** column name */
  BackAttack = 'back_attack',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackHealth = 'back_health',
  /** column name */
  BackImagesrc = 'back_imagesrc',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  CommandHammers = 'command_hammers',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckRules = 'deck_rules',
  /** column name */
  FactionId = 'faction_id',
  /** column name */
  FactionName = 'faction_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Health = 'health',
  /** column name */
  Horizontal = 'horizontal',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Keywords = 'keywords',
  /** column name */
  Locale = 'locale',
  /** column name */
  LoyaltyId = 'loyalty_id',
  /** column name */
  LoyaltyName = 'loyalty_name',
  /** column name */
  Name = 'name',
  /** column name */
  PackCycleId = 'pack_cycle_id',
  /** column name */
  PackCycleName = 'pack_cycle_name',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  PackName = 'pack_name',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Position = 'position',
  /** column name */
  Preparation = 'preparation',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackImagesrc = 'real_back_imagesrc',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealBackTraits = 'real_back_traits',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealImagesrc = 'real_imagesrc',
  /** column name */
  RealKeywords = 'real_keywords',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Shields = 'shields',
  /** column name */
  SignatureId = 'signature_id',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  TtsSheetPosition = 'tts_sheet_position',
  /** column name */
  TtsSheetUrl = 'tts_sheet_url',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  TypeName = 'type_name',
  /** column name */
  Unique = 'unique',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Conquest_Card_Localized_Stddev_Fields = {
  __typename?: 'conquest_card_localized_stddev_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Card_Localized_Stddev_Pop_Fields = {
  __typename?: 'conquest_card_localized_stddev_pop_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Card_Localized_Stddev_Samp_Fields = {
  __typename?: 'conquest_card_localized_stddev_samp_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_card_localized" */
export type Conquest_Card_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Card_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Card_Localized_Stream_Cursor_Value_Input = {
  attack?: InputMaybe<Scalars['Int']['input']>;
  back_attack?: InputMaybe<Scalars['Int']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_health?: InputMaybe<Scalars['Int']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  command_hammers?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
  faction_id?: InputMaybe<Scalars['String']['input']>;
  faction_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  horizontal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  loyalty_id?: InputMaybe<Scalars['String']['input']>;
  loyalty_name?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_cycle_id?: InputMaybe<Scalars['String']['input']>;
  pack_cycle_name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  pack_name?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preparation?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_back_traits?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_imagesrc?: InputMaybe<Scalars['String']['input']>;
  real_keywords?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  shields?: InputMaybe<Scalars['Int']['input']>;
  signature_id?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  tts_sheet_position?: InputMaybe<Scalars['Int']['input']>;
  tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  type_name?: InputMaybe<Scalars['String']['input']>;
  unique?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Card_Localized_Sum_Fields = {
  __typename?: 'conquest_card_localized_sum_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
};

/** aggregate var_pop on columns */
export type Conquest_Card_Localized_Var_Pop_Fields = {
  __typename?: 'conquest_card_localized_var_pop_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Card_Localized_Var_Samp_Fields = {
  __typename?: 'conquest_card_localized_var_samp_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Card_Localized_Variance_Fields = {
  __typename?: 'conquest_card_localized_variance_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type Conquest_Card_Max_Fields = {
  __typename?: 'conquest_card_max_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  back_tts_sheet_url?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Card_Min_Fields = {
  __typename?: 'conquest_card_min_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  back_tts_sheet_url?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.card" */
export type Conquest_Card_Mutation_Response = {
  __typename?: 'conquest_card_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Card>;
};

/** on_conflict condition type for table "conquest.card" */
export type Conquest_Card_On_Conflict = {
  constraint: Conquest_Card_Constraint;
  update_columns?: Array<Conquest_Card_Update_Column>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.card". */
export type Conquest_Card_Order_By = {
  attack?: InputMaybe<Order_By>;
  back_attack?: InputMaybe<Order_By>;
  back_card_id?: InputMaybe<Order_By>;
  back_flavor?: InputMaybe<Order_By>;
  back_health?: InputMaybe<Order_By>;
  back_imagesrc?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  back_tts_sheet_url?: InputMaybe<Order_By>;
  command_hammers?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_rules?: InputMaybe<Order_By>;
  faction_id?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  horizontal?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  keywords?: InputMaybe<Order_By>;
  loyalty_id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  pack_id?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  preparation?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  shields?: InputMaybe<Order_By>;
  signature_id?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  tts_sheet_position?: InputMaybe<Order_By>;
  tts_sheet_url?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  unique?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.card */
export type Conquest_Card_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Conquest_Card_Prepend_Input = {
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "conquest.card" */
export enum Conquest_Card_Select_Column {
  /** column name */
  Attack = 'attack',
  /** column name */
  BackAttack = 'back_attack',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackHealth = 'back_health',
  /** column name */
  BackImagesrc = 'back_imagesrc',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  BackTtsSheetUrl = 'back_tts_sheet_url',
  /** column name */
  CommandHammers = 'command_hammers',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckRules = 'deck_rules',
  /** column name */
  FactionId = 'faction_id',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Health = 'health',
  /** column name */
  Horizontal = 'horizontal',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Keywords = 'keywords',
  /** column name */
  LoyaltyId = 'loyalty_id',
  /** column name */
  Name = 'name',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  Position = 'position',
  /** column name */
  Preparation = 'preparation',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  Shields = 'shields',
  /** column name */
  SignatureId = 'signature_id',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  TtsSheetPosition = 'tts_sheet_position',
  /** column name */
  TtsSheetUrl = 'tts_sheet_url',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  Unique = 'unique',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.card" */
export type Conquest_Card_Set_Input = {
  attack?: InputMaybe<Scalars['Int']['input']>;
  back_attack?: InputMaybe<Scalars['Int']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_health?: InputMaybe<Scalars['Int']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  back_tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  command_hammers?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
  faction_id?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  horizontal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  loyalty_id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preparation?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  shields?: InputMaybe<Scalars['Int']['input']>;
  signature_id?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  tts_sheet_position?: InputMaybe<Scalars['Int']['input']>;
  tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  unique?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Card_Stddev_Fields = {
  __typename?: 'conquest_card_stddev_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Card_Stddev_Pop_Fields = {
  __typename?: 'conquest_card_stddev_pop_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Card_Stddev_Samp_Fields = {
  __typename?: 'conquest_card_stddev_samp_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_card" */
export type Conquest_Card_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Card_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Card_Stream_Cursor_Value_Input = {
  attack?: InputMaybe<Scalars['Int']['input']>;
  back_attack?: InputMaybe<Scalars['Int']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_health?: InputMaybe<Scalars['Int']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  back_tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  command_hammers?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
  faction_id?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  horizontal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  loyalty_id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preparation?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  shields?: InputMaybe<Scalars['Int']['input']>;
  signature_id?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  tts_sheet_position?: InputMaybe<Scalars['Int']['input']>;
  tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  unique?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Card_Sum_Fields = {
  __typename?: 'conquest_card_sum_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "conquest.card_text" */
export type Conquest_Card_Text = {
  __typename?: 'conquest_card_text';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.card_text" */
export type Conquest_Card_Text_Aggregate = {
  __typename?: 'conquest_card_text_aggregate';
  aggregate?: Maybe<Conquest_Card_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Card_Text>;
};

/** aggregate fields of "conquest.card_text" */
export type Conquest_Card_Text_Aggregate_Fields = {
  __typename?: 'conquest_card_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Card_Text_Max_Fields>;
  min?: Maybe<Conquest_Card_Text_Min_Fields>;
};


/** aggregate fields of "conquest.card_text" */
export type Conquest_Card_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.card_text". All fields are combined with a logical 'AND'. */
export type Conquest_Card_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Card_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Card_Text_Bool_Exp>>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_imagesrc?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  back_traits?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  keywords?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.card_text" */
export enum Conquest_Card_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  CardTextPkey = 'card_text_pkey'
}

/** input type for inserting data into table "conquest.card_text" */
export type Conquest_Card_Text_Insert_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Card_Text_Max_Fields = {
  __typename?: 'conquest_card_text_max_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Card_Text_Min_Fields = {
  __typename?: 'conquest_card_text_min_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.card_text" */
export type Conquest_Card_Text_Mutation_Response = {
  __typename?: 'conquest_card_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Card_Text>;
};

/** on_conflict condition type for table "conquest.card_text" */
export type Conquest_Card_Text_On_Conflict = {
  constraint: Conquest_Card_Text_Constraint;
  update_columns?: Array<Conquest_Card_Text_Update_Column>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.card_text". */
export type Conquest_Card_Text_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_imagesrc?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  keywords?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.card_text */
export type Conquest_Card_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.card_text" */
export enum Conquest_Card_Text_Select_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackImagesrc = 'back_imagesrc',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Keywords = 'keywords',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.card_text" */
export type Conquest_Card_Text_Set_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_card_text" */
export type Conquest_Card_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Card_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Card_Text_Stream_Cursor_Value_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.card_text" */
export enum Conquest_Card_Text_Update_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackImagesrc = 'back_imagesrc',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Keywords = 'keywords',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Card_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Card_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Card_Text_Bool_Exp;
};

/** update columns of table "conquest.card" */
export enum Conquest_Card_Update_Column {
  /** column name */
  Attack = 'attack',
  /** column name */
  BackAttack = 'back_attack',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackHealth = 'back_health',
  /** column name */
  BackImagesrc = 'back_imagesrc',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  BackTtsSheetUrl = 'back_tts_sheet_url',
  /** column name */
  CommandHammers = 'command_hammers',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckRules = 'deck_rules',
  /** column name */
  FactionId = 'faction_id',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Health = 'health',
  /** column name */
  Horizontal = 'horizontal',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Keywords = 'keywords',
  /** column name */
  LoyaltyId = 'loyalty_id',
  /** column name */
  Name = 'name',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  Position = 'position',
  /** column name */
  Preparation = 'preparation',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  Shields = 'shields',
  /** column name */
  SignatureId = 'signature_id',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  TtsSheetPosition = 'tts_sheet_position',
  /** column name */
  TtsSheetUrl = 'tts_sheet_url',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  Unique = 'unique',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "conquest.card_updated" */
export type Conquest_Card_Updated = {
  __typename?: 'conquest_card_updated';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.card_updated" */
export type Conquest_Card_Updated_Aggregate = {
  __typename?: 'conquest_card_updated_aggregate';
  aggregate?: Maybe<Conquest_Card_Updated_Aggregate_Fields>;
  nodes: Array<Conquest_Card_Updated>;
};

/** aggregate fields of "conquest.card_updated" */
export type Conquest_Card_Updated_Aggregate_Fields = {
  __typename?: 'conquest_card_updated_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Card_Updated_Max_Fields>;
  min?: Maybe<Conquest_Card_Updated_Min_Fields>;
};


/** aggregate fields of "conquest.card_updated" */
export type Conquest_Card_Updated_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Card_Updated_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.card_updated". All fields are combined with a logical 'AND'. */
export type Conquest_Card_Updated_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Card_Updated_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Card_Updated_Bool_Exp>>;
  locale?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Conquest_Card_Updated_Max_Fields = {
  __typename?: 'conquest_card_updated_max_fields';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Card_Updated_Min_Fields = {
  __typename?: 'conquest_card_updated_min_fields';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "conquest.card_updated". */
export type Conquest_Card_Updated_Order_By = {
  locale?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "conquest.card_updated" */
export enum Conquest_Card_Updated_Select_Column {
  /** column name */
  Locale = 'locale',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "conquest_card_updated" */
export type Conquest_Card_Updated_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Card_Updated_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Card_Updated_Stream_Cursor_Value_Input = {
  locale?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

export type Conquest_Card_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Conquest_Card_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Conquest_Card_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Conquest_Card_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Conquest_Card_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Card_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Conquest_Card_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Card_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Card_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Card_Var_Pop_Fields = {
  __typename?: 'conquest_card_var_pop_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Card_Var_Samp_Fields = {
  __typename?: 'conquest_card_var_samp_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Card_Variance_Fields = {
  __typename?: 'conquest_card_variance_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "conquest.comment" */
export type Conquest_Comment = {
  __typename?: 'conquest_comment';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  deck?: Maybe<Conquest_Deck>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id: Scalars['uuid']['output'];
  response_count: Scalars['Int']['output'];
  /** An array relationship */
  responses: Array<Conquest_Comment>;
  /** An aggregate relationship */
  responses_aggregate: Conquest_Comment_Aggregate;
  text?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Conquest_Users;
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "conquest.comment" */
export type Conquest_CommentResponsesArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


/** columns and relationships of "conquest.comment" */
export type Conquest_CommentResponses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};

/** aggregated selection of "conquest.comment" */
export type Conquest_Comment_Aggregate = {
  __typename?: 'conquest_comment_aggregate';
  aggregate?: Maybe<Conquest_Comment_Aggregate_Fields>;
  nodes: Array<Conquest_Comment>;
};

export type Conquest_Comment_Aggregate_Bool_Exp = {
  count?: InputMaybe<Conquest_Comment_Aggregate_Bool_Exp_Count>;
};

export type Conquest_Comment_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Conquest_Comment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "conquest.comment" */
export type Conquest_Comment_Aggregate_Fields = {
  __typename?: 'conquest_comment_aggregate_fields';
  avg?: Maybe<Conquest_Comment_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Comment_Max_Fields>;
  min?: Maybe<Conquest_Comment_Min_Fields>;
  stddev?: Maybe<Conquest_Comment_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Comment_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Comment_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Comment_Sum_Fields>;
  var_pop?: Maybe<Conquest_Comment_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Comment_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Comment_Variance_Fields>;
};


/** aggregate fields of "conquest.comment" */
export type Conquest_Comment_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "conquest.comment" */
export type Conquest_Comment_Aggregate_Order_By = {
  avg?: InputMaybe<Conquest_Comment_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Conquest_Comment_Max_Order_By>;
  min?: InputMaybe<Conquest_Comment_Min_Order_By>;
  stddev?: InputMaybe<Conquest_Comment_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Conquest_Comment_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Conquest_Comment_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Conquest_Comment_Sum_Order_By>;
  var_pop?: InputMaybe<Conquest_Comment_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Conquest_Comment_Var_Samp_Order_By>;
  variance?: InputMaybe<Conquest_Comment_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "conquest.comment" */
export type Conquest_Comment_Arr_Rel_Insert_Input = {
  data: Array<Conquest_Comment_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Conquest_Comment_On_Conflict>;
};

/** aggregate avg on columns */
export type Conquest_Comment_Avg_Fields = {
  __typename?: 'conquest_comment_avg_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "conquest.comment" */
export type Conquest_Comment_Avg_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "conquest.comment". All fields are combined with a logical 'AND'. */
export type Conquest_Comment_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Comment_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Comment_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Comment_Bool_Exp>>;
  comment_id?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck?: InputMaybe<Conquest_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  response_count?: InputMaybe<Int_Comparison_Exp>;
  responses?: InputMaybe<Conquest_Comment_Bool_Exp>;
  responses_aggregate?: InputMaybe<Conquest_Comment_Aggregate_Bool_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Conquest_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.comment" */
export enum Conquest_Comment_Constraint {
  /** unique or primary key constraint on columns "id" */
  CommentPkey = 'comment_pkey'
}

/** input type for incrementing numeric columns in table "conquest.comment" */
export type Conquest_Comment_Inc_Input = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.comment" */
export type Conquest_Comment_Insert_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck?: InputMaybe<Conquest_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  responses?: InputMaybe<Conquest_Comment_Arr_Rel_Insert_Input>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Conquest_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Conquest_Comment_Max_Fields = {
  __typename?: 'conquest_comment_max_fields';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "conquest.comment" */
export type Conquest_Comment_Max_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Conquest_Comment_Min_Fields = {
  __typename?: 'conquest_comment_min_fields';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "conquest.comment" */
export type Conquest_Comment_Min_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "conquest.comment" */
export type Conquest_Comment_Mutation_Response = {
  __typename?: 'conquest_comment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Comment>;
};

/** on_conflict condition type for table "conquest.comment" */
export type Conquest_Comment_On_Conflict = {
  constraint: Conquest_Comment_Constraint;
  update_columns?: Array<Conquest_Comment_Update_Column>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.comment". */
export type Conquest_Comment_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck?: InputMaybe<Conquest_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
  responses_aggregate?: InputMaybe<Conquest_Comment_Aggregate_Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Conquest_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.comment */
export type Conquest_Comment_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "conquest.comment" */
export enum Conquest_Comment_Select_Column {
  /** column name */
  CommentId = 'comment_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Id = 'id',
  /** column name */
  ResponseCount = 'response_count',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "conquest.comment" */
export type Conquest_Comment_Set_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Comment_Stddev_Fields = {
  __typename?: 'conquest_comment_stddev_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "conquest.comment" */
export type Conquest_Comment_Stddev_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Comment_Stddev_Pop_Fields = {
  __typename?: 'conquest_comment_stddev_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "conquest.comment" */
export type Conquest_Comment_Stddev_Pop_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Comment_Stddev_Samp_Fields = {
  __typename?: 'conquest_comment_stddev_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "conquest.comment" */
export type Conquest_Comment_Stddev_Samp_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "conquest_comment" */
export type Conquest_Comment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Comment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Comment_Stream_Cursor_Value_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Comment_Sum_Fields = {
  __typename?: 'conquest_comment_sum_fields';
  deck_id?: Maybe<Scalars['Int']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "conquest.comment" */
export type Conquest_Comment_Sum_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** update columns of table "conquest.comment" */
export enum Conquest_Comment_Update_Column {
  /** column name */
  CommentId = 'comment_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Id = 'id',
  /** column name */
  ResponseCount = 'response_count',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Conquest_Comment_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Comment_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Comment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Comment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Comment_Var_Pop_Fields = {
  __typename?: 'conquest_comment_var_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "conquest.comment" */
export type Conquest_Comment_Var_Pop_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Conquest_Comment_Var_Samp_Fields = {
  __typename?: 'conquest_comment_var_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "conquest.comment" */
export type Conquest_Comment_Var_Samp_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Conquest_Comment_Variance_Fields = {
  __typename?: 'conquest_comment_variance_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "conquest.comment" */
export type Conquest_Comment_Variance_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** columns and relationships of "conquest.cycle" */
export type Conquest_Cycle = {
  __typename?: 'conquest_cycle';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  position: Scalars['Int']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.cycle" */
export type Conquest_Cycle_Aggregate = {
  __typename?: 'conquest_cycle_aggregate';
  aggregate?: Maybe<Conquest_Cycle_Aggregate_Fields>;
  nodes: Array<Conquest_Cycle>;
};

/** aggregate fields of "conquest.cycle" */
export type Conquest_Cycle_Aggregate_Fields = {
  __typename?: 'conquest_cycle_aggregate_fields';
  avg?: Maybe<Conquest_Cycle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Cycle_Max_Fields>;
  min?: Maybe<Conquest_Cycle_Min_Fields>;
  stddev?: Maybe<Conquest_Cycle_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Cycle_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Cycle_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Cycle_Sum_Fields>;
  var_pop?: Maybe<Conquest_Cycle_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Cycle_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Cycle_Variance_Fields>;
};


/** aggregate fields of "conquest.cycle" */
export type Conquest_Cycle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Cycle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Cycle_Avg_Fields = {
  __typename?: 'conquest_cycle_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.cycle". All fields are combined with a logical 'AND'. */
export type Conquest_Cycle_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Cycle_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Cycle_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Cycle_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.cycle" */
export enum Conquest_Cycle_Constraint {
  /** unique or primary key constraint on columns "id" */
  CyclePkey = 'cycle_pkey'
}

/** input type for incrementing numeric columns in table "conquest.cycle" */
export type Conquest_Cycle_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.cycle" */
export type Conquest_Cycle_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Cycle_Max_Fields = {
  __typename?: 'conquest_cycle_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Cycle_Min_Fields = {
  __typename?: 'conquest_cycle_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.cycle" */
export type Conquest_Cycle_Mutation_Response = {
  __typename?: 'conquest_cycle_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Cycle>;
};

/** on_conflict condition type for table "conquest.cycle" */
export type Conquest_Cycle_On_Conflict = {
  constraint: Conquest_Cycle_Constraint;
  update_columns?: Array<Conquest_Cycle_Update_Column>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.cycle". */
export type Conquest_Cycle_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.cycle */
export type Conquest_Cycle_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.cycle" */
export enum Conquest_Cycle_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.cycle" */
export type Conquest_Cycle_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Cycle_Stddev_Fields = {
  __typename?: 'conquest_cycle_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Cycle_Stddev_Pop_Fields = {
  __typename?: 'conquest_cycle_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Cycle_Stddev_Samp_Fields = {
  __typename?: 'conquest_cycle_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_cycle" */
export type Conquest_Cycle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Cycle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Cycle_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Cycle_Sum_Fields = {
  __typename?: 'conquest_cycle_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "conquest.cycle_text" */
export type Conquest_Cycle_Text = {
  __typename?: 'conquest_cycle_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.cycle_text" */
export type Conquest_Cycle_Text_Aggregate = {
  __typename?: 'conquest_cycle_text_aggregate';
  aggregate?: Maybe<Conquest_Cycle_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Cycle_Text>;
};

/** aggregate fields of "conquest.cycle_text" */
export type Conquest_Cycle_Text_Aggregate_Fields = {
  __typename?: 'conquest_cycle_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Cycle_Text_Max_Fields>;
  min?: Maybe<Conquest_Cycle_Text_Min_Fields>;
};


/** aggregate fields of "conquest.cycle_text" */
export type Conquest_Cycle_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Cycle_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.cycle_text". All fields are combined with a logical 'AND'. */
export type Conquest_Cycle_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Cycle_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Cycle_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.cycle_text" */
export enum Conquest_Cycle_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  CycleTextPkey = 'cycle_text_pkey'
}

/** input type for inserting data into table "conquest.cycle_text" */
export type Conquest_Cycle_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Cycle_Text_Max_Fields = {
  __typename?: 'conquest_cycle_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Cycle_Text_Min_Fields = {
  __typename?: 'conquest_cycle_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.cycle_text" */
export type Conquest_Cycle_Text_Mutation_Response = {
  __typename?: 'conquest_cycle_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Cycle_Text>;
};

/** on_conflict condition type for table "conquest.cycle_text" */
export type Conquest_Cycle_Text_On_Conflict = {
  constraint: Conquest_Cycle_Text_Constraint;
  update_columns?: Array<Conquest_Cycle_Text_Update_Column>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.cycle_text". */
export type Conquest_Cycle_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.cycle_text */
export type Conquest_Cycle_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.cycle_text" */
export enum Conquest_Cycle_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.cycle_text" */
export type Conquest_Cycle_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_cycle_text" */
export type Conquest_Cycle_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Cycle_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Cycle_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.cycle_text" */
export enum Conquest_Cycle_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Cycle_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Cycle_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Cycle_Text_Bool_Exp;
};

/** update columns of table "conquest.cycle" */
export enum Conquest_Cycle_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Cycle_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Cycle_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Cycle_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Cycle_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Cycle_Var_Pop_Fields = {
  __typename?: 'conquest_cycle_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Cycle_Var_Samp_Fields = {
  __typename?: 'conquest_cycle_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Cycle_Variance_Fields = {
  __typename?: 'conquest_cycle_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "conquest.deck" */
export type Conquest_Deck = {
  __typename?: 'conquest_deck';
  comment_count: Scalars['Int']['output'];
  /** An array relationship */
  comments: Array<Conquest_Comment>;
  /** An aggregate relationship */
  comments_aggregate: Conquest_Comment_Aggregate;
  copy_count: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  like_count: Scalars['Int']['output'];
  /** A computed field, executes function "conquest.deck_liked_by_user" */
  liked_by_user?: Maybe<Scalars['Boolean']['output']>;
  meta: Scalars['jsonb']['output'];
  name: Scalars['String']['output'];
  /** An object relationship */
  original_deck?: Maybe<Conquest_Deck_Copy>;
  published?: Maybe<Scalars['Boolean']['output']>;
  side_slots: Scalars['jsonb']['output'];
  slots: Scalars['jsonb']['output'];
  tags: Scalars['jsonb']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Conquest_Users;
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckCommentsArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckComments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckMetaArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckSide_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckSlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "conquest.deck" */
export type Conquest_Deck_Aggregate = {
  __typename?: 'conquest_deck_aggregate';
  aggregate?: Maybe<Conquest_Deck_Aggregate_Fields>;
  nodes: Array<Conquest_Deck>;
};

/** aggregate fields of "conquest.deck" */
export type Conquest_Deck_Aggregate_Fields = {
  __typename?: 'conquest_deck_aggregate_fields';
  avg?: Maybe<Conquest_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Deck_Max_Fields>;
  min?: Maybe<Conquest_Deck_Min_Fields>;
  stddev?: Maybe<Conquest_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Deck_Sum_Fields>;
  var_pop?: Maybe<Conquest_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Deck_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Deck_Variance_Fields>;
};


/** aggregate fields of "conquest.deck" */
export type Conquest_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Conquest_Deck_Append_Input = {
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Deck_Avg_Fields = {
  __typename?: 'conquest_deck_avg_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.deck". All fields are combined with a logical 'AND'. */
export type Conquest_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Deck_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Deck_Bool_Exp>>;
  comment_count?: InputMaybe<Int_Comparison_Exp>;
  comments?: InputMaybe<Conquest_Comment_Bool_Exp>;
  comments_aggregate?: InputMaybe<Conquest_Comment_Aggregate_Bool_Exp>;
  copy_count?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  like_count?: InputMaybe<Int_Comparison_Exp>;
  liked_by_user?: InputMaybe<Boolean_Comparison_Exp>;
  meta?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  original_deck?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
  published?: InputMaybe<Boolean_Comparison_Exp>;
  side_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  slots?: InputMaybe<Jsonb_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Conquest_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.deck" */
export enum Conquest_Deck_Constraint {
  /** unique or primary key constraint on columns "id" */
  DeckPkey = 'deck_pkey'
}

/** columns and relationships of "conquest.deck_copy" */
export type Conquest_Deck_Copy = {
  __typename?: 'conquest_deck_copy';
  copy_deck_id: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  deck: Conquest_Deck;
  /** An object relationship */
  deck_copy: Conquest_Deck;
  deck_id: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Conquest_Users;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "conquest.deck_copy" */
export type Conquest_Deck_Copy_Aggregate = {
  __typename?: 'conquest_deck_copy_aggregate';
  aggregate?: Maybe<Conquest_Deck_Copy_Aggregate_Fields>;
  nodes: Array<Conquest_Deck_Copy>;
};

/** aggregate fields of "conquest.deck_copy" */
export type Conquest_Deck_Copy_Aggregate_Fields = {
  __typename?: 'conquest_deck_copy_aggregate_fields';
  avg?: Maybe<Conquest_Deck_Copy_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Deck_Copy_Max_Fields>;
  min?: Maybe<Conquest_Deck_Copy_Min_Fields>;
  stddev?: Maybe<Conquest_Deck_Copy_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Deck_Copy_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Deck_Copy_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Deck_Copy_Sum_Fields>;
  var_pop?: Maybe<Conquest_Deck_Copy_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Deck_Copy_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Deck_Copy_Variance_Fields>;
};


/** aggregate fields of "conquest.deck_copy" */
export type Conquest_Deck_Copy_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Deck_Copy_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Deck_Copy_Avg_Fields = {
  __typename?: 'conquest_deck_copy_avg_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.deck_copy". All fields are combined with a logical 'AND'. */
export type Conquest_Deck_Copy_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Deck_Copy_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Deck_Copy_Bool_Exp>>;
  copy_deck_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck?: InputMaybe<Conquest_Deck_Bool_Exp>;
  deck_copy?: InputMaybe<Conquest_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Conquest_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.deck_copy" */
export enum Conquest_Deck_Copy_Constraint {
  /** unique or primary key constraint on columns "copy_deck_id" */
  DeckCopyPkey = 'deck_copy_pkey'
}

/** input type for incrementing numeric columns in table "conquest.deck_copy" */
export type Conquest_Deck_Copy_Inc_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.deck_copy" */
export type Conquest_Deck_Copy_Insert_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck?: InputMaybe<Conquest_Deck_Obj_Rel_Insert_Input>;
  deck_copy?: InputMaybe<Conquest_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Conquest_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Conquest_Deck_Copy_Max_Fields = {
  __typename?: 'conquest_deck_copy_max_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Conquest_Deck_Copy_Min_Fields = {
  __typename?: 'conquest_deck_copy_min_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "conquest.deck_copy" */
export type Conquest_Deck_Copy_Mutation_Response = {
  __typename?: 'conquest_deck_copy_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Deck_Copy>;
};

/** input type for inserting object relation for remote table "conquest.deck_copy" */
export type Conquest_Deck_Copy_Obj_Rel_Insert_Input = {
  data: Conquest_Deck_Copy_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Conquest_Deck_Copy_On_Conflict>;
};

/** on_conflict condition type for table "conquest.deck_copy" */
export type Conquest_Deck_Copy_On_Conflict = {
  constraint: Conquest_Deck_Copy_Constraint;
  update_columns?: Array<Conquest_Deck_Copy_Update_Column>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.deck_copy". */
export type Conquest_Deck_Copy_Order_By = {
  copy_deck_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck?: InputMaybe<Conquest_Deck_Order_By>;
  deck_copy?: InputMaybe<Conquest_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Conquest_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.deck_copy */
export type Conquest_Deck_Copy_Pk_Columns_Input = {
  copy_deck_id: Scalars['Int']['input'];
};

/** select columns of table "conquest.deck_copy" */
export enum Conquest_Deck_Copy_Select_Column {
  /** column name */
  CopyDeckId = 'copy_deck_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "conquest.deck_copy" */
export type Conquest_Deck_Copy_Set_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Deck_Copy_Stddev_Fields = {
  __typename?: 'conquest_deck_copy_stddev_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Deck_Copy_Stddev_Pop_Fields = {
  __typename?: 'conquest_deck_copy_stddev_pop_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Deck_Copy_Stddev_Samp_Fields = {
  __typename?: 'conquest_deck_copy_stddev_samp_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_deck_copy" */
export type Conquest_Deck_Copy_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Deck_Copy_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Deck_Copy_Stream_Cursor_Value_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Deck_Copy_Sum_Fields = {
  __typename?: 'conquest_deck_copy_sum_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "conquest.deck_copy" */
export enum Conquest_Deck_Copy_Update_Column {
  /** column name */
  CopyDeckId = 'copy_deck_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Conquest_Deck_Copy_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Deck_Copy_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Deck_Copy_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Deck_Copy_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Deck_Copy_Var_Pop_Fields = {
  __typename?: 'conquest_deck_copy_var_pop_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Deck_Copy_Var_Samp_Fields = {
  __typename?: 'conquest_deck_copy_var_samp_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Deck_Copy_Variance_Fields = {
  __typename?: 'conquest_deck_copy_variance_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Conquest_Deck_Delete_At_Path_Input = {
  meta?: InputMaybe<Array<Scalars['String']['input']>>;
  side_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  slots?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Conquest_Deck_Delete_Elem_Input = {
  meta?: InputMaybe<Scalars['Int']['input']>;
  side_slots?: InputMaybe<Scalars['Int']['input']>;
  slots?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Conquest_Deck_Delete_Key_Input = {
  meta?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['String']['input']>;
  slots?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "conquest.deck" */
export type Conquest_Deck_Inc_Input = {
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.deck" */
export type Conquest_Deck_Insert_Input = {
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  comments?: InputMaybe<Conquest_Comment_Arr_Rel_Insert_Input>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  original_deck?: InputMaybe<Conquest_Deck_Copy_Obj_Rel_Insert_Input>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Conquest_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "conquest.deck_like" */
export type Conquest_Deck_Like = {
  __typename?: 'conquest_deck_like';
  created_at: Scalars['timestamptz']['output'];
  deck_id: Scalars['Int']['output'];
  liked: Scalars['Boolean']['output'];
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "conquest.deck_like" */
export type Conquest_Deck_Like_Aggregate = {
  __typename?: 'conquest_deck_like_aggregate';
  aggregate?: Maybe<Conquest_Deck_Like_Aggregate_Fields>;
  nodes: Array<Conquest_Deck_Like>;
};

/** aggregate fields of "conquest.deck_like" */
export type Conquest_Deck_Like_Aggregate_Fields = {
  __typename?: 'conquest_deck_like_aggregate_fields';
  avg?: Maybe<Conquest_Deck_Like_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Deck_Like_Max_Fields>;
  min?: Maybe<Conquest_Deck_Like_Min_Fields>;
  stddev?: Maybe<Conquest_Deck_Like_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Deck_Like_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Deck_Like_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Deck_Like_Sum_Fields>;
  var_pop?: Maybe<Conquest_Deck_Like_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Deck_Like_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Deck_Like_Variance_Fields>;
};


/** aggregate fields of "conquest.deck_like" */
export type Conquest_Deck_Like_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Deck_Like_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Deck_Like_Avg_Fields = {
  __typename?: 'conquest_deck_like_avg_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.deck_like". All fields are combined with a logical 'AND'. */
export type Conquest_Deck_Like_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Deck_Like_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Deck_Like_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  liked?: InputMaybe<Boolean_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.deck_like" */
export enum Conquest_Deck_Like_Constraint {
  /** unique or primary key constraint on columns "user_id", "deck_id" */
  DeckLikePkey = 'deck_like_pkey'
}

/** input type for incrementing numeric columns in table "conquest.deck_like" */
export type Conquest_Deck_Like_Inc_Input = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.deck_like" */
export type Conquest_Deck_Like_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Conquest_Deck_Like_Max_Fields = {
  __typename?: 'conquest_deck_like_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Conquest_Deck_Like_Min_Fields = {
  __typename?: 'conquest_deck_like_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "conquest.deck_like" */
export type Conquest_Deck_Like_Mutation_Response = {
  __typename?: 'conquest_deck_like_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Deck_Like>;
};

/** on_conflict condition type for table "conquest.deck_like" */
export type Conquest_Deck_Like_On_Conflict = {
  constraint: Conquest_Deck_Like_Constraint;
  update_columns?: Array<Conquest_Deck_Like_Update_Column>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.deck_like". */
export type Conquest_Deck_Like_Order_By = {
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  liked?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.deck_like */
export type Conquest_Deck_Like_Pk_Columns_Input = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};

/** select columns of table "conquest.deck_like" */
export enum Conquest_Deck_Like_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Liked = 'liked',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "conquest.deck_like" */
export type Conquest_Deck_Like_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Deck_Like_Stddev_Fields = {
  __typename?: 'conquest_deck_like_stddev_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Deck_Like_Stddev_Pop_Fields = {
  __typename?: 'conquest_deck_like_stddev_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Deck_Like_Stddev_Samp_Fields = {
  __typename?: 'conquest_deck_like_stddev_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_deck_like" */
export type Conquest_Deck_Like_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Deck_Like_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Deck_Like_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Deck_Like_Sum_Fields = {
  __typename?: 'conquest_deck_like_sum_fields';
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "conquest.deck_like" */
export enum Conquest_Deck_Like_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Liked = 'liked',
  /** column name */
  UserId = 'user_id'
}

export type Conquest_Deck_Like_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Deck_Like_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Deck_Like_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Deck_Like_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Deck_Like_Var_Pop_Fields = {
  __typename?: 'conquest_deck_like_var_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Deck_Like_Var_Samp_Fields = {
  __typename?: 'conquest_deck_like_var_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Deck_Like_Variance_Fields = {
  __typename?: 'conquest_deck_like_variance_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type Conquest_Deck_Max_Fields = {
  __typename?: 'conquest_deck_max_fields';
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Conquest_Deck_Min_Fields = {
  __typename?: 'conquest_deck_min_fields';
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "conquest.deck" */
export type Conquest_Deck_Mutation_Response = {
  __typename?: 'conquest_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Deck>;
};

/** input type for inserting object relation for remote table "conquest.deck" */
export type Conquest_Deck_Obj_Rel_Insert_Input = {
  data: Conquest_Deck_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Conquest_Deck_On_Conflict>;
};

/** on_conflict condition type for table "conquest.deck" */
export type Conquest_Deck_On_Conflict = {
  constraint: Conquest_Deck_Constraint;
  update_columns?: Array<Conquest_Deck_Update_Column>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.deck". */
export type Conquest_Deck_Order_By = {
  comment_count?: InputMaybe<Order_By>;
  comments_aggregate?: InputMaybe<Conquest_Comment_Aggregate_Order_By>;
  copy_count?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  like_count?: InputMaybe<Order_By>;
  liked_by_user?: InputMaybe<Order_By>;
  meta?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  original_deck?: InputMaybe<Conquest_Deck_Copy_Order_By>;
  published?: InputMaybe<Order_By>;
  side_slots?: InputMaybe<Order_By>;
  slots?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Conquest_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.deck */
export type Conquest_Deck_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Conquest_Deck_Prepend_Input = {
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "conquest.deck" */
export enum Conquest_Deck_Select_Column {
  /** column name */
  CommentCount = 'comment_count',
  /** column name */
  CopyCount = 'copy_count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  Published = 'published',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "conquest.deck" */
export type Conquest_Deck_Set_Input = {
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Deck_Stddev_Fields = {
  __typename?: 'conquest_deck_stddev_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Deck_Stddev_Pop_Fields = {
  __typename?: 'conquest_deck_stddev_pop_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Deck_Stddev_Samp_Fields = {
  __typename?: 'conquest_deck_stddev_samp_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_deck" */
export type Conquest_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Deck_Stream_Cursor_Value_Input = {
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Deck_Sum_Fields = {
  __typename?: 'conquest_deck_sum_fields';
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "conquest.deck" */
export enum Conquest_Deck_Update_Column {
  /** column name */
  CommentCount = 'comment_count',
  /** column name */
  CopyCount = 'copy_count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  Published = 'published',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Conquest_Deck_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Conquest_Deck_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Conquest_Deck_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Conquest_Deck_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Conquest_Deck_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Deck_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Conquest_Deck_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Deck_Var_Pop_Fields = {
  __typename?: 'conquest_deck_var_pop_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Deck_Var_Samp_Fields = {
  __typename?: 'conquest_deck_var_samp_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Deck_Variance_Fields = {
  __typename?: 'conquest_deck_variance_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "conquest.faction" */
export type Conquest_Faction = {
  __typename?: 'conquest_faction';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.faction" */
export type Conquest_Faction_Aggregate = {
  __typename?: 'conquest_faction_aggregate';
  aggregate?: Maybe<Conquest_Faction_Aggregate_Fields>;
  nodes: Array<Conquest_Faction>;
};

/** aggregate fields of "conquest.faction" */
export type Conquest_Faction_Aggregate_Fields = {
  __typename?: 'conquest_faction_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Faction_Max_Fields>;
  min?: Maybe<Conquest_Faction_Min_Fields>;
};


/** aggregate fields of "conquest.faction" */
export type Conquest_Faction_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Faction_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.faction". All fields are combined with a logical 'AND'. */
export type Conquest_Faction_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Faction_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Faction_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Faction_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.faction" */
export enum Conquest_Faction_Constraint {
  /** unique or primary key constraint on columns "id" */
  FactionPkey = 'faction_pkey'
}

/** input type for inserting data into table "conquest.faction" */
export type Conquest_Faction_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Faction_Max_Fields = {
  __typename?: 'conquest_faction_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Faction_Min_Fields = {
  __typename?: 'conquest_faction_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.faction" */
export type Conquest_Faction_Mutation_Response = {
  __typename?: 'conquest_faction_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Faction>;
};

/** on_conflict condition type for table "conquest.faction" */
export type Conquest_Faction_On_Conflict = {
  constraint: Conquest_Faction_Constraint;
  update_columns?: Array<Conquest_Faction_Update_Column>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.faction". */
export type Conquest_Faction_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.faction */
export type Conquest_Faction_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.faction" */
export enum Conquest_Faction_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.faction" */
export type Conquest_Faction_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_faction" */
export type Conquest_Faction_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Faction_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Faction_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "conquest.faction_text" */
export type Conquest_Faction_Text = {
  __typename?: 'conquest_faction_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "conquest.faction_text" */
export type Conquest_Faction_Text_Aggregate = {
  __typename?: 'conquest_faction_text_aggregate';
  aggregate?: Maybe<Conquest_Faction_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Faction_Text>;
};

/** aggregate fields of "conquest.faction_text" */
export type Conquest_Faction_Text_Aggregate_Fields = {
  __typename?: 'conquest_faction_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Faction_Text_Max_Fields>;
  min?: Maybe<Conquest_Faction_Text_Min_Fields>;
};


/** aggregate fields of "conquest.faction_text" */
export type Conquest_Faction_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Faction_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.faction_text". All fields are combined with a logical 'AND'. */
export type Conquest_Faction_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Faction_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Faction_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.faction_text" */
export enum Conquest_Faction_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  FactionTextPkey = 'faction_text_pkey'
}

/** input type for inserting data into table "conquest.faction_text" */
export type Conquest_Faction_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Faction_Text_Max_Fields = {
  __typename?: 'conquest_faction_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Faction_Text_Min_Fields = {
  __typename?: 'conquest_faction_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.faction_text" */
export type Conquest_Faction_Text_Mutation_Response = {
  __typename?: 'conquest_faction_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Faction_Text>;
};

/** on_conflict condition type for table "conquest.faction_text" */
export type Conquest_Faction_Text_On_Conflict = {
  constraint: Conquest_Faction_Text_Constraint;
  update_columns?: Array<Conquest_Faction_Text_Update_Column>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.faction_text". */
export type Conquest_Faction_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.faction_text */
export type Conquest_Faction_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.faction_text" */
export enum Conquest_Faction_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.faction_text" */
export type Conquest_Faction_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_faction_text" */
export type Conquest_Faction_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Faction_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Faction_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.faction_text" */
export enum Conquest_Faction_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Faction_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Faction_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Faction_Text_Bool_Exp;
};

/** update columns of table "conquest.faction" */
export enum Conquest_Faction_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Faction_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Faction_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Faction_Bool_Exp;
};

/** columns and relationships of "conquest.loyalty" */
export type Conquest_Loyalty = {
  __typename?: 'conquest_loyalty';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.loyalty" */
export type Conquest_Loyalty_Aggregate = {
  __typename?: 'conquest_loyalty_aggregate';
  aggregate?: Maybe<Conquest_Loyalty_Aggregate_Fields>;
  nodes: Array<Conquest_Loyalty>;
};

/** aggregate fields of "conquest.loyalty" */
export type Conquest_Loyalty_Aggregate_Fields = {
  __typename?: 'conquest_loyalty_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Loyalty_Max_Fields>;
  min?: Maybe<Conquest_Loyalty_Min_Fields>;
};


/** aggregate fields of "conquest.loyalty" */
export type Conquest_Loyalty_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Loyalty_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.loyalty". All fields are combined with a logical 'AND'. */
export type Conquest_Loyalty_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Loyalty_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Loyalty_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.loyalty" */
export enum Conquest_Loyalty_Constraint {
  /** unique or primary key constraint on columns "id" */
  LoyaltyPkey = 'loyalty_pkey'
}

/** input type for inserting data into table "conquest.loyalty" */
export type Conquest_Loyalty_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Loyalty_Max_Fields = {
  __typename?: 'conquest_loyalty_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Loyalty_Min_Fields = {
  __typename?: 'conquest_loyalty_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.loyalty" */
export type Conquest_Loyalty_Mutation_Response = {
  __typename?: 'conquest_loyalty_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Loyalty>;
};

/** on_conflict condition type for table "conquest.loyalty" */
export type Conquest_Loyalty_On_Conflict = {
  constraint: Conquest_Loyalty_Constraint;
  update_columns?: Array<Conquest_Loyalty_Update_Column>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.loyalty". */
export type Conquest_Loyalty_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.loyalty */
export type Conquest_Loyalty_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.loyalty" */
export enum Conquest_Loyalty_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.loyalty" */
export type Conquest_Loyalty_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_loyalty" */
export type Conquest_Loyalty_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Loyalty_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Loyalty_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "conquest.loyalty_text" */
export type Conquest_Loyalty_Text = {
  __typename?: 'conquest_loyalty_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Aggregate = {
  __typename?: 'conquest_loyalty_text_aggregate';
  aggregate?: Maybe<Conquest_Loyalty_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Loyalty_Text>;
};

/** aggregate fields of "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Aggregate_Fields = {
  __typename?: 'conquest_loyalty_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Loyalty_Text_Max_Fields>;
  min?: Maybe<Conquest_Loyalty_Text_Min_Fields>;
};


/** aggregate fields of "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Loyalty_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.loyalty_text". All fields are combined with a logical 'AND'. */
export type Conquest_Loyalty_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Loyalty_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Loyalty_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.loyalty_text" */
export enum Conquest_Loyalty_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  LoyaltyTextPkey = 'loyalty_text_pkey'
}

/** input type for inserting data into table "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Loyalty_Text_Max_Fields = {
  __typename?: 'conquest_loyalty_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Loyalty_Text_Min_Fields = {
  __typename?: 'conquest_loyalty_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Mutation_Response = {
  __typename?: 'conquest_loyalty_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Loyalty_Text>;
};

/** on_conflict condition type for table "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_On_Conflict = {
  constraint: Conquest_Loyalty_Text_Constraint;
  update_columns?: Array<Conquest_Loyalty_Text_Update_Column>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.loyalty_text". */
export type Conquest_Loyalty_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.loyalty_text */
export type Conquest_Loyalty_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.loyalty_text" */
export enum Conquest_Loyalty_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_loyalty_text" */
export type Conquest_Loyalty_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Loyalty_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Loyalty_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.loyalty_text" */
export enum Conquest_Loyalty_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Loyalty_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Loyalty_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Loyalty_Text_Bool_Exp;
};

/** update columns of table "conquest.loyalty" */
export enum Conquest_Loyalty_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Loyalty_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Loyalty_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Loyalty_Bool_Exp;
};

/** columns and relationships of "conquest.pack" */
export type Conquest_Pack = {
  __typename?: 'conquest_pack';
  cycle_id: Scalars['String']['output'];
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  position: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "conquest.pack" */
export type Conquest_Pack_Aggregate = {
  __typename?: 'conquest_pack_aggregate';
  aggregate?: Maybe<Conquest_Pack_Aggregate_Fields>;
  nodes: Array<Conquest_Pack>;
};

/** aggregate fields of "conquest.pack" */
export type Conquest_Pack_Aggregate_Fields = {
  __typename?: 'conquest_pack_aggregate_fields';
  avg?: Maybe<Conquest_Pack_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Pack_Max_Fields>;
  min?: Maybe<Conquest_Pack_Min_Fields>;
  stddev?: Maybe<Conquest_Pack_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Pack_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Pack_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Pack_Sum_Fields>;
  var_pop?: Maybe<Conquest_Pack_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Pack_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Pack_Variance_Fields>;
};


/** aggregate fields of "conquest.pack" */
export type Conquest_Pack_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Pack_Avg_Fields = {
  __typename?: 'conquest_pack_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.pack". All fields are combined with a logical 'AND'. */
export type Conquest_Pack_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Pack_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Pack_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Pack_Bool_Exp>>;
  cycle_id?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.pack" */
export enum Conquest_Pack_Constraint {
  /** unique or primary key constraint on columns "id" */
  PackPkey = 'pack_pkey'
}

/** input type for incrementing numeric columns in table "conquest.pack" */
export type Conquest_Pack_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.pack" */
export type Conquest_Pack_Insert_Input = {
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Pack_Max_Fields = {
  __typename?: 'conquest_pack_max_fields';
  cycle_id?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Pack_Min_Fields = {
  __typename?: 'conquest_pack_min_fields';
  cycle_id?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.pack" */
export type Conquest_Pack_Mutation_Response = {
  __typename?: 'conquest_pack_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Pack>;
};

/** on_conflict condition type for table "conquest.pack" */
export type Conquest_Pack_On_Conflict = {
  constraint: Conquest_Pack_Constraint;
  update_columns?: Array<Conquest_Pack_Update_Column>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.pack". */
export type Conquest_Pack_Order_By = {
  cycle_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.pack */
export type Conquest_Pack_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.pack" */
export enum Conquest_Pack_Select_Column {
  /** column name */
  CycleId = 'cycle_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.pack" */
export type Conquest_Pack_Set_Input = {
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Pack_Stddev_Fields = {
  __typename?: 'conquest_pack_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Pack_Stddev_Pop_Fields = {
  __typename?: 'conquest_pack_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Pack_Stddev_Samp_Fields = {
  __typename?: 'conquest_pack_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_pack" */
export type Conquest_Pack_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Pack_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Pack_Stream_Cursor_Value_Input = {
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Pack_Sum_Fields = {
  __typename?: 'conquest_pack_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "conquest.pack_text" */
export type Conquest_Pack_Text = {
  __typename?: 'conquest_pack_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "conquest.pack_text" */
export type Conquest_Pack_Text_Aggregate = {
  __typename?: 'conquest_pack_text_aggregate';
  aggregate?: Maybe<Conquest_Pack_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Pack_Text>;
};

/** aggregate fields of "conquest.pack_text" */
export type Conquest_Pack_Text_Aggregate_Fields = {
  __typename?: 'conquest_pack_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Pack_Text_Max_Fields>;
  min?: Maybe<Conquest_Pack_Text_Min_Fields>;
};


/** aggregate fields of "conquest.pack_text" */
export type Conquest_Pack_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Pack_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.pack_text". All fields are combined with a logical 'AND'. */
export type Conquest_Pack_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Pack_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Pack_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.pack_text" */
export enum Conquest_Pack_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  PackTextPkey = 'pack_text_pkey'
}

/** input type for inserting data into table "conquest.pack_text" */
export type Conquest_Pack_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Pack_Text_Max_Fields = {
  __typename?: 'conquest_pack_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Pack_Text_Min_Fields = {
  __typename?: 'conquest_pack_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.pack_text" */
export type Conquest_Pack_Text_Mutation_Response = {
  __typename?: 'conquest_pack_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Pack_Text>;
};

/** on_conflict condition type for table "conquest.pack_text" */
export type Conquest_Pack_Text_On_Conflict = {
  constraint: Conquest_Pack_Text_Constraint;
  update_columns?: Array<Conquest_Pack_Text_Update_Column>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.pack_text". */
export type Conquest_Pack_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.pack_text */
export type Conquest_Pack_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.pack_text" */
export enum Conquest_Pack_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.pack_text" */
export type Conquest_Pack_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_pack_text" */
export type Conquest_Pack_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Pack_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Pack_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.pack_text" */
export enum Conquest_Pack_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Pack_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Pack_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Pack_Text_Bool_Exp;
};

/** update columns of table "conquest.pack" */
export enum Conquest_Pack_Update_Column {
  /** column name */
  CycleId = 'cycle_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Pack_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Pack_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Pack_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Pack_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Pack_Var_Pop_Fields = {
  __typename?: 'conquest_pack_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Pack_Var_Samp_Fields = {
  __typename?: 'conquest_pack_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Pack_Variance_Fields = {
  __typename?: 'conquest_pack_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

export type Conquest_Publish_Deck_Args = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** columns and relationships of "conquest.type" */
export type Conquest_Type = {
  __typename?: 'conquest_type';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.type" */
export type Conquest_Type_Aggregate = {
  __typename?: 'conquest_type_aggregate';
  aggregate?: Maybe<Conquest_Type_Aggregate_Fields>;
  nodes: Array<Conquest_Type>;
};

/** aggregate fields of "conquest.type" */
export type Conquest_Type_Aggregate_Fields = {
  __typename?: 'conquest_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Type_Max_Fields>;
  min?: Maybe<Conquest_Type_Min_Fields>;
};


/** aggregate fields of "conquest.type" */
export type Conquest_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.type". All fields are combined with a logical 'AND'. */
export type Conquest_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Type_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Type_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.type" */
export enum Conquest_Type_Constraint {
  /** unique or primary key constraint on columns "id" */
  TypePkey = 'type_pkey'
}

/** input type for inserting data into table "conquest.type" */
export type Conquest_Type_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Type_Max_Fields = {
  __typename?: 'conquest_type_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Type_Min_Fields = {
  __typename?: 'conquest_type_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.type" */
export type Conquest_Type_Mutation_Response = {
  __typename?: 'conquest_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Type>;
};

/** on_conflict condition type for table "conquest.type" */
export type Conquest_Type_On_Conflict = {
  constraint: Conquest_Type_Constraint;
  update_columns?: Array<Conquest_Type_Update_Column>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.type". */
export type Conquest_Type_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.type */
export type Conquest_Type_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.type" */
export enum Conquest_Type_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.type" */
export type Conquest_Type_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_type" */
export type Conquest_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Type_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "conquest.type_text" */
export type Conquest_Type_Text = {
  __typename?: 'conquest_type_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "conquest.type_text" */
export type Conquest_Type_Text_Aggregate = {
  __typename?: 'conquest_type_text_aggregate';
  aggregate?: Maybe<Conquest_Type_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Type_Text>;
};

/** aggregate fields of "conquest.type_text" */
export type Conquest_Type_Text_Aggregate_Fields = {
  __typename?: 'conquest_type_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Type_Text_Max_Fields>;
  min?: Maybe<Conquest_Type_Text_Min_Fields>;
};


/** aggregate fields of "conquest.type_text" */
export type Conquest_Type_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Type_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.type_text". All fields are combined with a logical 'AND'. */
export type Conquest_Type_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Type_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Type_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.type_text" */
export enum Conquest_Type_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  TypeTextPkey = 'type_text_pkey'
}

/** input type for inserting data into table "conquest.type_text" */
export type Conquest_Type_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Type_Text_Max_Fields = {
  __typename?: 'conquest_type_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Type_Text_Min_Fields = {
  __typename?: 'conquest_type_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.type_text" */
export type Conquest_Type_Text_Mutation_Response = {
  __typename?: 'conquest_type_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Type_Text>;
};

/** on_conflict condition type for table "conquest.type_text" */
export type Conquest_Type_Text_On_Conflict = {
  constraint: Conquest_Type_Text_Constraint;
  update_columns?: Array<Conquest_Type_Text_Update_Column>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.type_text". */
export type Conquest_Type_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.type_text */
export type Conquest_Type_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.type_text" */
export enum Conquest_Type_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.type_text" */
export type Conquest_Type_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_type_text" */
export type Conquest_Type_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Type_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Type_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.type_text" */
export enum Conquest_Type_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Type_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Type_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Type_Text_Bool_Exp;
};

/** update columns of table "conquest.type" */
export enum Conquest_Type_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Type_Bool_Exp;
};

/** columns and relationships of "conquest.user_role" */
export type Conquest_User_Role = {
  __typename?: 'conquest_user_role';
  id: Scalars['String']['output'];
};

/** aggregated selection of "conquest.user_role" */
export type Conquest_User_Role_Aggregate = {
  __typename?: 'conquest_user_role_aggregate';
  aggregate?: Maybe<Conquest_User_Role_Aggregate_Fields>;
  nodes: Array<Conquest_User_Role>;
};

/** aggregate fields of "conquest.user_role" */
export type Conquest_User_Role_Aggregate_Fields = {
  __typename?: 'conquest_user_role_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_User_Role_Max_Fields>;
  min?: Maybe<Conquest_User_Role_Min_Fields>;
};


/** aggregate fields of "conquest.user_role" */
export type Conquest_User_Role_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_User_Role_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.user_role". All fields are combined with a logical 'AND'. */
export type Conquest_User_Role_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_User_Role_Bool_Exp>>;
  _not?: InputMaybe<Conquest_User_Role_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_User_Role_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.user_role" */
export enum Conquest_User_Role_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserRolePkey = 'user_role_pkey'
}

export enum Conquest_User_Role_Enum {
  Admin = 'admin',
  Moderator = 'moderator'
}

/** Boolean expression to compare columns of type "conquest_user_role_enum". All fields are combined with logical 'AND'. */
export type Conquest_User_Role_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Conquest_User_Role_Enum>;
  _in?: InputMaybe<Array<Conquest_User_Role_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Conquest_User_Role_Enum>;
  _nin?: InputMaybe<Array<Conquest_User_Role_Enum>>;
};

/** input type for inserting data into table "conquest.user_role" */
export type Conquest_User_Role_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Conquest_User_Role_Max_Fields = {
  __typename?: 'conquest_user_role_max_fields';
  id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Conquest_User_Role_Min_Fields = {
  __typename?: 'conquest_user_role_min_fields';
  id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "conquest.user_role" */
export type Conquest_User_Role_Mutation_Response = {
  __typename?: 'conquest_user_role_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_User_Role>;
};

/** on_conflict condition type for table "conquest.user_role" */
export type Conquest_User_Role_On_Conflict = {
  constraint: Conquest_User_Role_Constraint;
  update_columns?: Array<Conquest_User_Role_Update_Column>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.user_role". */
export type Conquest_User_Role_Order_By = {
  id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.user_role */
export type Conquest_User_Role_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.user_role" */
export enum Conquest_User_Role_Select_Column {
  /** column name */
  Id = 'id'
}

/** input type for updating data in table "conquest.user_role" */
export type Conquest_User_Role_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "conquest_user_role" */
export type Conquest_User_Role_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_User_Role_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_User_Role_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "conquest.user_role" */
export enum Conquest_User_Role_Update_Column {
  /** column name */
  Id = 'id'
}

export type Conquest_User_Role_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_User_Role_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_User_Role_Bool_Exp;
};

/** columns and relationships of "conquest.user_settings" */
export type Conquest_User_Settings = {
  __typename?: 'conquest_user_settings';
  private_decks: Scalars['Boolean']['output'];
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "conquest.user_settings" */
export type Conquest_User_Settings_Aggregate = {
  __typename?: 'conquest_user_settings_aggregate';
  aggregate?: Maybe<Conquest_User_Settings_Aggregate_Fields>;
  nodes: Array<Conquest_User_Settings>;
};

export type Conquest_User_Settings_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Conquest_User_Settings_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Conquest_User_Settings_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Conquest_User_Settings_Aggregate_Bool_Exp_Count>;
};

export type Conquest_User_Settings_Aggregate_Bool_Exp_Bool_And = {
  arguments: Conquest_User_Settings_Select_Column_Conquest_User_Settings_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Conquest_User_Settings_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Conquest_User_Settings_Select_Column_Conquest_User_Settings_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Conquest_User_Settings_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "conquest.user_settings" */
export type Conquest_User_Settings_Aggregate_Fields = {
  __typename?: 'conquest_user_settings_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_User_Settings_Max_Fields>;
  min?: Maybe<Conquest_User_Settings_Min_Fields>;
};


/** aggregate fields of "conquest.user_settings" */
export type Conquest_User_Settings_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "conquest.user_settings" */
export type Conquest_User_Settings_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Conquest_User_Settings_Max_Order_By>;
  min?: InputMaybe<Conquest_User_Settings_Min_Order_By>;
};

/** input type for inserting array relation for remote table "conquest.user_settings" */
export type Conquest_User_Settings_Arr_Rel_Insert_Input = {
  data: Array<Conquest_User_Settings_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Conquest_User_Settings_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conquest.user_settings". All fields are combined with a logical 'AND'. */
export type Conquest_User_Settings_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_User_Settings_Bool_Exp>>;
  _not?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_User_Settings_Bool_Exp>>;
  private_decks?: InputMaybe<Boolean_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.user_settings" */
export enum Conquest_User_Settings_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  UserSettingsPkey = 'user_settings_pkey'
}

/** input type for inserting data into table "conquest.user_settings" */
export type Conquest_User_Settings_Insert_Input = {
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Conquest_User_Settings_Max_Fields = {
  __typename?: 'conquest_user_settings_max_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "conquest.user_settings" */
export type Conquest_User_Settings_Max_Order_By = {
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Conquest_User_Settings_Min_Fields = {
  __typename?: 'conquest_user_settings_min_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "conquest.user_settings" */
export type Conquest_User_Settings_Min_Order_By = {
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "conquest.user_settings" */
export type Conquest_User_Settings_Mutation_Response = {
  __typename?: 'conquest_user_settings_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_User_Settings>;
};

/** on_conflict condition type for table "conquest.user_settings" */
export type Conquest_User_Settings_On_Conflict = {
  constraint: Conquest_User_Settings_Constraint;
  update_columns?: Array<Conquest_User_Settings_Update_Column>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.user_settings". */
export type Conquest_User_Settings_Order_By = {
  private_decks?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.user_settings */
export type Conquest_User_Settings_Pk_Columns_Input = {
  user_id: Scalars['String']['input'];
};

/** select columns of table "conquest.user_settings" */
export enum Conquest_User_Settings_Select_Column {
  /** column name */
  PrivateDecks = 'private_decks',
  /** column name */
  UserId = 'user_id'
}

/** select "conquest_user_settings_aggregate_bool_exp_bool_and_arguments_columns" columns of table "conquest.user_settings" */
export enum Conquest_User_Settings_Select_Column_Conquest_User_Settings_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  PrivateDecks = 'private_decks'
}

/** select "conquest_user_settings_aggregate_bool_exp_bool_or_arguments_columns" columns of table "conquest.user_settings" */
export enum Conquest_User_Settings_Select_Column_Conquest_User_Settings_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  PrivateDecks = 'private_decks'
}

/** input type for updating data in table "conquest.user_settings" */
export type Conquest_User_Settings_Set_Input = {
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "conquest_user_settings" */
export type Conquest_User_Settings_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_User_Settings_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_User_Settings_Stream_Cursor_Value_Input = {
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "conquest.user_settings" */
export enum Conquest_User_Settings_Update_Column {
  /** column name */
  PrivateDecks = 'private_decks',
  /** column name */
  UserId = 'user_id'
}

export type Conquest_User_Settings_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_User_Settings_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_User_Settings_Bool_Exp;
};

/** columns and relationships of "conquest.users" */
export type Conquest_Users = {
  __typename?: 'conquest_users';
  created_at: Scalars['timestamptz']['output'];
  handle?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  normalized_handle?: Maybe<Scalars['String']['output']>;
  role?: Maybe<Conquest_User_Role_Enum>;
  /** An array relationship */
  settings: Array<Conquest_User_Settings>;
  /** An aggregate relationship */
  settings_aggregate: Conquest_User_Settings_Aggregate;
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "conquest.users" */
export type Conquest_UsersSettingsArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


/** columns and relationships of "conquest.users" */
export type Conquest_UsersSettings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};

/** aggregated selection of "conquest.users" */
export type Conquest_Users_Aggregate = {
  __typename?: 'conquest_users_aggregate';
  aggregate?: Maybe<Conquest_Users_Aggregate_Fields>;
  nodes: Array<Conquest_Users>;
};

/** aggregate fields of "conquest.users" */
export type Conquest_Users_Aggregate_Fields = {
  __typename?: 'conquest_users_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Users_Max_Fields>;
  min?: Maybe<Conquest_Users_Min_Fields>;
};


/** aggregate fields of "conquest.users" */
export type Conquest_Users_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.users". All fields are combined with a logical 'AND'. */
export type Conquest_Users_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Users_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Users_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Users_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  handle?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  normalized_handle?: InputMaybe<String_Comparison_Exp>;
  role?: InputMaybe<Conquest_User_Role_Enum_Comparison_Exp>;
  settings?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
  settings_aggregate?: InputMaybe<Conquest_User_Settings_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.users" */
export enum Conquest_Users_Constraint {
  /** unique or primary key constraint on columns "normalized_handle" */
  UsersNormalizedHandleKey = 'users_normalized_handle_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey'
}

/** input type for inserting data into table "conquest.users" */
export type Conquest_Users_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Conquest_User_Role_Enum>;
  settings?: InputMaybe<Conquest_User_Settings_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Users_Max_Fields = {
  __typename?: 'conquest_users_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Users_Min_Fields = {
  __typename?: 'conquest_users_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.users" */
export type Conquest_Users_Mutation_Response = {
  __typename?: 'conquest_users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Users>;
};

/** input type for inserting object relation for remote table "conquest.users" */
export type Conquest_Users_Obj_Rel_Insert_Input = {
  data: Conquest_Users_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Conquest_Users_On_Conflict>;
};

/** on_conflict condition type for table "conquest.users" */
export type Conquest_Users_On_Conflict = {
  constraint: Conquest_Users_Constraint;
  update_columns?: Array<Conquest_Users_Update_Column>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.users". */
export type Conquest_Users_Order_By = {
  created_at?: InputMaybe<Order_By>;
  handle?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  normalized_handle?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  settings_aggregate?: InputMaybe<Conquest_User_Settings_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.users */
export type Conquest_Users_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.users" */
export enum Conquest_Users_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  Role = 'role',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.users" */
export type Conquest_Users_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Conquest_User_Role_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_users" */
export type Conquest_Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Users_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Conquest_User_Role_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.users" */
export enum Conquest_Users_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  Role = 'role',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Users_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Users_Bool_Exp;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** columns and relationships of "cycle" */
export type Cycle = {
  __typename?: 'cycle';
  code: Scalars['String']['output'];
  official: Scalars['Boolean']['output'];
  /** An array relationship */
  packs: Array<Pack>;
  /** An aggregate relationship */
  packs_aggregate: Pack_Aggregate;
  position: Scalars['Int']['output'];
  real_name: Scalars['String']['output'];
  /** An array relationship */
  translations: Array<Cycle_Name>;
  /** An aggregate relationship */
  translations_aggregate: Cycle_Name_Aggregate;
};


/** columns and relationships of "cycle" */
export type CyclePacksArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


/** columns and relationships of "cycle" */
export type CyclePacks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


/** columns and relationships of "cycle" */
export type CycleTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


/** columns and relationships of "cycle" */
export type CycleTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};

/** aggregated selection of "cycle" */
export type Cycle_Aggregate = {
  __typename?: 'cycle_aggregate';
  aggregate?: Maybe<Cycle_Aggregate_Fields>;
  nodes: Array<Cycle>;
};

/** aggregate fields of "cycle" */
export type Cycle_Aggregate_Fields = {
  __typename?: 'cycle_aggregate_fields';
  avg?: Maybe<Cycle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Cycle_Max_Fields>;
  min?: Maybe<Cycle_Min_Fields>;
  stddev?: Maybe<Cycle_Stddev_Fields>;
  stddev_pop?: Maybe<Cycle_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Cycle_Stddev_Samp_Fields>;
  sum?: Maybe<Cycle_Sum_Fields>;
  var_pop?: Maybe<Cycle_Var_Pop_Fields>;
  var_samp?: Maybe<Cycle_Var_Samp_Fields>;
  variance?: Maybe<Cycle_Variance_Fields>;
};


/** aggregate fields of "cycle" */
export type Cycle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Cycle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Cycle_Avg_Fields = {
  __typename?: 'cycle_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "cycle". All fields are combined with a logical 'AND'. */
export type Cycle_Bool_Exp = {
  _and?: InputMaybe<Array<Cycle_Bool_Exp>>;
  _not?: InputMaybe<Cycle_Bool_Exp>;
  _or?: InputMaybe<Array<Cycle_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
  packs?: InputMaybe<Pack_Bool_Exp>;
  packs_aggregate?: InputMaybe<Pack_Aggregate_Bool_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Cycle_Name_Bool_Exp>;
  translations_aggregate?: InputMaybe<Cycle_Name_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "cycle" */
export enum Cycle_Constraint {
  /** unique or primary key constraint on columns "code" */
  CyclePkey = 'cycle_pkey'
}

/** input type for incrementing numeric columns in table "cycle" */
export type Cycle_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "cycle" */
export type Cycle_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  packs?: InputMaybe<Pack_Arr_Rel_Insert_Input>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Cycle_Name_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Cycle_Max_Fields = {
  __typename?: 'cycle_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Cycle_Min_Fields = {
  __typename?: 'cycle_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "cycle" */
export type Cycle_Mutation_Response = {
  __typename?: 'cycle_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Cycle>;
};

/** columns and relationships of "cycle_name" */
export type Cycle_Name = {
  __typename?: 'cycle_name';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "cycle_name" */
export type Cycle_Name_Aggregate = {
  __typename?: 'cycle_name_aggregate';
  aggregate?: Maybe<Cycle_Name_Aggregate_Fields>;
  nodes: Array<Cycle_Name>;
};

export type Cycle_Name_Aggregate_Bool_Exp = {
  count?: InputMaybe<Cycle_Name_Aggregate_Bool_Exp_Count>;
};

export type Cycle_Name_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Cycle_Name_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "cycle_name" */
export type Cycle_Name_Aggregate_Fields = {
  __typename?: 'cycle_name_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Cycle_Name_Max_Fields>;
  min?: Maybe<Cycle_Name_Min_Fields>;
};


/** aggregate fields of "cycle_name" */
export type Cycle_Name_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "cycle_name" */
export type Cycle_Name_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Cycle_Name_Max_Order_By>;
  min?: InputMaybe<Cycle_Name_Min_Order_By>;
};

/** input type for inserting array relation for remote table "cycle_name" */
export type Cycle_Name_Arr_Rel_Insert_Input = {
  data: Array<Cycle_Name_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Cycle_Name_On_Conflict>;
};

/** Boolean expression to filter rows from the table "cycle_name". All fields are combined with a logical 'AND'. */
export type Cycle_Name_Bool_Exp = {
  _and?: InputMaybe<Array<Cycle_Name_Bool_Exp>>;
  _not?: InputMaybe<Cycle_Name_Bool_Exp>;
  _or?: InputMaybe<Array<Cycle_Name_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "cycle_name" */
export enum Cycle_Name_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CycleNamePkey = 'cycle_name_pkey'
}

/** input type for inserting data into table "cycle_name" */
export type Cycle_Name_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Cycle_Name_Max_Fields = {
  __typename?: 'cycle_name_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "cycle_name" */
export type Cycle_Name_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Cycle_Name_Min_Fields = {
  __typename?: 'cycle_name_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "cycle_name" */
export type Cycle_Name_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "cycle_name" */
export type Cycle_Name_Mutation_Response = {
  __typename?: 'cycle_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Cycle_Name>;
};

/** on_conflict condition type for table "cycle_name" */
export type Cycle_Name_On_Conflict = {
  constraint: Cycle_Name_Constraint;
  update_columns?: Array<Cycle_Name_Update_Column>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};

/** Ordering options when selecting data from "cycle_name". */
export type Cycle_Name_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: cycle_name */
export type Cycle_Name_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "cycle_name" */
export enum Cycle_Name_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "cycle_name" */
export type Cycle_Name_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "cycle_name" */
export type Cycle_Name_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cycle_Name_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cycle_Name_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "cycle_name" */
export enum Cycle_Name_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Cycle_Name_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Cycle_Name_Set_Input>;
  /** filter the rows which have to be updated */
  where: Cycle_Name_Bool_Exp;
};

/** input type for inserting object relation for remote table "cycle" */
export type Cycle_Obj_Rel_Insert_Input = {
  data: Cycle_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Cycle_On_Conflict>;
};

/** on_conflict condition type for table "cycle" */
export type Cycle_On_Conflict = {
  constraint: Cycle_Constraint;
  update_columns?: Array<Cycle_Update_Column>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};

/** Ordering options when selecting data from "cycle". */
export type Cycle_Order_By = {
  code?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
  packs_aggregate?: InputMaybe<Pack_Aggregate_Order_By>;
  position?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Cycle_Name_Aggregate_Order_By>;
};

/** primary key columns input for table: cycle */
export type Cycle_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** select columns of table "cycle" */
export enum Cycle_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position',
  /** column name */
  RealName = 'real_name'
}

/** input type for updating data in table "cycle" */
export type Cycle_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Cycle_Stddev_Fields = {
  __typename?: 'cycle_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Cycle_Stddev_Pop_Fields = {
  __typename?: 'cycle_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Cycle_Stddev_Samp_Fields = {
  __typename?: 'cycle_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "cycle" */
export type Cycle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cycle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cycle_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Cycle_Sum_Fields = {
  __typename?: 'cycle_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "cycle" */
export enum Cycle_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position',
  /** column name */
  RealName = 'real_name'
}

export type Cycle_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Cycle_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Cycle_Set_Input>;
  /** filter the rows which have to be updated */
  where: Cycle_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Cycle_Var_Pop_Fields = {
  __typename?: 'cycle_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Cycle_Var_Samp_Fields = {
  __typename?: 'cycle_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Cycle_Variance_Fields = {
  __typename?: 'cycle_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "faction_name" */
export type Faction_Name = {
  __typename?: 'faction_name';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** aggregated selection of "faction_name" */
export type Faction_Name_Aggregate = {
  __typename?: 'faction_name_aggregate';
  aggregate?: Maybe<Faction_Name_Aggregate_Fields>;
  nodes: Array<Faction_Name>;
};

/** aggregate fields of "faction_name" */
export type Faction_Name_Aggregate_Fields = {
  __typename?: 'faction_name_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Faction_Name_Max_Fields>;
  min?: Maybe<Faction_Name_Min_Fields>;
};


/** aggregate fields of "faction_name" */
export type Faction_Name_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Faction_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "faction_name". All fields are combined with a logical 'AND'. */
export type Faction_Name_Bool_Exp = {
  _and?: InputMaybe<Array<Faction_Name_Bool_Exp>>;
  _not?: InputMaybe<Faction_Name_Bool_Exp>;
  _or?: InputMaybe<Array<Faction_Name_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "faction_name" */
export enum Faction_Name_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  FactionNamePkey = 'faction_name_pkey'
}

/** input type for inserting data into table "faction_name" */
export type Faction_Name_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Faction_Name_Max_Fields = {
  __typename?: 'faction_name_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Faction_Name_Min_Fields = {
  __typename?: 'faction_name_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "faction_name" */
export type Faction_Name_Mutation_Response = {
  __typename?: 'faction_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Faction_Name>;
};

/** on_conflict condition type for table "faction_name" */
export type Faction_Name_On_Conflict = {
  constraint: Faction_Name_Constraint;
  update_columns?: Array<Faction_Name_Update_Column>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};

/** Ordering options when selecting data from "faction_name". */
export type Faction_Name_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: faction_name */
export type Faction_Name_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "faction_name" */
export enum Faction_Name_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "faction_name" */
export type Faction_Name_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "faction_name" */
export type Faction_Name_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Faction_Name_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Faction_Name_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "faction_name" */
export enum Faction_Name_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

export type Faction_Name_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Faction_Name_Set_Input>;
  /** filter the rows which have to be updated */
  where: Faction_Name_Bool_Exp;
};

/** columns and relationships of "faq" */
export type Faq = {
  __typename?: 'faq';
  code: Scalars['String']['output'];
  /** An array relationship */
  faq_texts: Array<Faq_Text>;
  /** An aggregate relationship */
  faq_texts_aggregate: Faq_Text_Aggregate;
  text: Scalars['String']['output'];
};


/** columns and relationships of "faq" */
export type FaqFaq_TextsArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


/** columns and relationships of "faq" */
export type FaqFaq_Texts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};

/** aggregated selection of "faq" */
export type Faq_Aggregate = {
  __typename?: 'faq_aggregate';
  aggregate?: Maybe<Faq_Aggregate_Fields>;
  nodes: Array<Faq>;
};

/** aggregate fields of "faq" */
export type Faq_Aggregate_Fields = {
  __typename?: 'faq_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Faq_Max_Fields>;
  min?: Maybe<Faq_Min_Fields>;
};


/** aggregate fields of "faq" */
export type Faq_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Faq_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "faq". All fields are combined with a logical 'AND'. */
export type Faq_Bool_Exp = {
  _and?: InputMaybe<Array<Faq_Bool_Exp>>;
  _not?: InputMaybe<Faq_Bool_Exp>;
  _or?: InputMaybe<Array<Faq_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  faq_texts?: InputMaybe<Faq_Text_Bool_Exp>;
  faq_texts_aggregate?: InputMaybe<Faq_Text_Aggregate_Bool_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "faq" */
export enum Faq_Constraint {
  /** unique or primary key constraint on columns "code" */
  FaqPkey = 'faq_pkey'
}

/** input type for inserting data into table "faq" */
export type Faq_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  faq_texts?: InputMaybe<Faq_Text_Arr_Rel_Insert_Input>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Faq_Max_Fields = {
  __typename?: 'faq_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Faq_Min_Fields = {
  __typename?: 'faq_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "faq" */
export type Faq_Mutation_Response = {
  __typename?: 'faq_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Faq>;
};

/** on_conflict condition type for table "faq" */
export type Faq_On_Conflict = {
  constraint: Faq_Constraint;
  update_columns?: Array<Faq_Update_Column>;
  where?: InputMaybe<Faq_Bool_Exp>;
};

/** Ordering options when selecting data from "faq". */
export type Faq_Order_By = {
  code?: InputMaybe<Order_By>;
  faq_texts_aggregate?: InputMaybe<Faq_Text_Aggregate_Order_By>;
  text?: InputMaybe<Order_By>;
};

/** primary key columns input for table: faq */
export type Faq_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** select columns of table "faq" */
export enum Faq_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Text = 'text'
}

/** input type for updating data in table "faq" */
export type Faq_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "faq" */
export type Faq_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Faq_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Faq_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "faq_text" */
export type Faq_Text = {
  __typename?: 'faq_text';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  text: Scalars['String']['output'];
};

/** aggregated selection of "faq_text" */
export type Faq_Text_Aggregate = {
  __typename?: 'faq_text_aggregate';
  aggregate?: Maybe<Faq_Text_Aggregate_Fields>;
  nodes: Array<Faq_Text>;
};

export type Faq_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Faq_Text_Aggregate_Bool_Exp_Count>;
};

export type Faq_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Faq_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Faq_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "faq_text" */
export type Faq_Text_Aggregate_Fields = {
  __typename?: 'faq_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Faq_Text_Max_Fields>;
  min?: Maybe<Faq_Text_Min_Fields>;
};


/** aggregate fields of "faq_text" */
export type Faq_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Faq_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "faq_text" */
export type Faq_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Faq_Text_Max_Order_By>;
  min?: InputMaybe<Faq_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "faq_text" */
export type Faq_Text_Arr_Rel_Insert_Input = {
  data: Array<Faq_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Faq_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "faq_text". All fields are combined with a logical 'AND'. */
export type Faq_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Faq_Text_Bool_Exp>>;
  _not?: InputMaybe<Faq_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Faq_Text_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "faq_text" */
export enum Faq_Text_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  FaqTextPkey = 'faq_text_pkey'
}

/** input type for inserting data into table "faq_text" */
export type Faq_Text_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Faq_Text_Max_Fields = {
  __typename?: 'faq_text_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "faq_text" */
export type Faq_Text_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Faq_Text_Min_Fields = {
  __typename?: 'faq_text_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "faq_text" */
export type Faq_Text_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "faq_text" */
export type Faq_Text_Mutation_Response = {
  __typename?: 'faq_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Faq_Text>;
};

/** on_conflict condition type for table "faq_text" */
export type Faq_Text_On_Conflict = {
  constraint: Faq_Text_Constraint;
  update_columns?: Array<Faq_Text_Update_Column>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "faq_text". */
export type Faq_Text_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
};

/** primary key columns input for table: faq_text */
export type Faq_Text_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "faq_text" */
export enum Faq_Text_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Text = 'text'
}

/** input type for updating data in table "faq_text" */
export type Faq_Text_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "faq_text" */
export type Faq_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Faq_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Faq_Text_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "faq_text" */
export enum Faq_Text_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Text = 'text'
}

export type Faq_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Faq_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Faq_Text_Bool_Exp;
};

/** update columns of table "faq" */
export enum Faq_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Text = 'text'
}

export type Faq_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Faq_Set_Input>;
  /** filter the rows which have to be updated */
  where: Faq_Bool_Exp;
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['float8']['input']>;
  _gt?: InputMaybe<Scalars['float8']['input']>;
  _gte?: InputMaybe<Scalars['float8']['input']>;
  _in?: InputMaybe<Array<Scalars['float8']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['float8']['input']>;
  _lte?: InputMaybe<Scalars['float8']['input']>;
  _neq?: InputMaybe<Scalars['float8']['input']>;
  _nin?: InputMaybe<Array<Scalars['float8']['input']>>;
};

/** columns and relationships of "friend_status" */
export type Friend_Status = {
  __typename?: 'friend_status';
  /** A computed field, executes function "friend_status_id" */
  id?: Maybe<Scalars['String']['output']>;
  status: Friend_Status_Type_Enum;
  user_id_a: Scalars['String']['output'];
  user_id_b: Scalars['String']['output'];
};

/** aggregated selection of "friend_status" */
export type Friend_Status_Aggregate = {
  __typename?: 'friend_status_aggregate';
  aggregate?: Maybe<Friend_Status_Aggregate_Fields>;
  nodes: Array<Friend_Status>;
};

/** aggregate fields of "friend_status" */
export type Friend_Status_Aggregate_Fields = {
  __typename?: 'friend_status_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Friend_Status_Max_Fields>;
  min?: Maybe<Friend_Status_Min_Fields>;
};


/** aggregate fields of "friend_status" */
export type Friend_Status_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Friend_Status_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "friend_status". All fields are combined with a logical 'AND'. */
export type Friend_Status_Bool_Exp = {
  _and?: InputMaybe<Array<Friend_Status_Bool_Exp>>;
  _not?: InputMaybe<Friend_Status_Bool_Exp>;
  _or?: InputMaybe<Array<Friend_Status_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<Friend_Status_Type_Enum_Comparison_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "friend_status" */
export enum Friend_Status_Constraint {
  /** unique or primary key constraint on columns "user_id_b", "user_id_a" */
  FriendStatusPkey = 'friend_status_pkey'
}

/** input type for inserting data into table "friend_status" */
export type Friend_Status_Insert_Input = {
  status?: InputMaybe<Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Friend_Status_Max_Fields = {
  __typename?: 'friend_status_max_fields';
  /** A computed field, executes function "friend_status_id" */
  id?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Friend_Status_Min_Fields = {
  __typename?: 'friend_status_min_fields';
  /** A computed field, executes function "friend_status_id" */
  id?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "friend_status" */
export type Friend_Status_Mutation_Response = {
  __typename?: 'friend_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Friend_Status>;
};

/** on_conflict condition type for table "friend_status" */
export type Friend_Status_On_Conflict = {
  constraint: Friend_Status_Constraint;
  update_columns?: Array<Friend_Status_Update_Column>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "friend_status". */
export type Friend_Status_Order_By = {
  id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** primary key columns input for table: friend_status */
export type Friend_Status_Pk_Columns_Input = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};

/** select columns of table "friend_status" */
export enum Friend_Status_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "friend_status" */
export type Friend_Status_Set_Input = {
  status?: InputMaybe<Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "friend_status" */
export type Friend_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Friend_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Friend_Status_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "friend_status_type" */
export type Friend_Status_Type = {
  __typename?: 'friend_status_type';
  value: Scalars['String']['output'];
};

/** aggregated selection of "friend_status_type" */
export type Friend_Status_Type_Aggregate = {
  __typename?: 'friend_status_type_aggregate';
  aggregate?: Maybe<Friend_Status_Type_Aggregate_Fields>;
  nodes: Array<Friend_Status_Type>;
};

/** aggregate fields of "friend_status_type" */
export type Friend_Status_Type_Aggregate_Fields = {
  __typename?: 'friend_status_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Friend_Status_Type_Max_Fields>;
  min?: Maybe<Friend_Status_Type_Min_Fields>;
};


/** aggregate fields of "friend_status_type" */
export type Friend_Status_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Friend_Status_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "friend_status_type". All fields are combined with a logical 'AND'. */
export type Friend_Status_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Friend_Status_Type_Bool_Exp>>;
  _not?: InputMaybe<Friend_Status_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Friend_Status_Type_Bool_Exp>>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "friend_status_type" */
export enum Friend_Status_Type_Constraint {
  /** unique or primary key constraint on columns "value" */
  FriendStatusTypePkey = 'friend_status_type_pkey'
}

export enum Friend_Status_Type_Enum {
  Friend = 'friend',
  None = 'none',
  Received = 'received',
  Sent = 'sent'
}

/** Boolean expression to compare columns of type "friend_status_type_enum". All fields are combined with logical 'AND'. */
export type Friend_Status_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Friend_Status_Type_Enum>;
  _in?: InputMaybe<Array<Friend_Status_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Friend_Status_Type_Enum>;
  _nin?: InputMaybe<Array<Friend_Status_Type_Enum>>;
};

/** input type for inserting data into table "friend_status_type" */
export type Friend_Status_Type_Insert_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Friend_Status_Type_Max_Fields = {
  __typename?: 'friend_status_type_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Friend_Status_Type_Min_Fields = {
  __typename?: 'friend_status_type_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "friend_status_type" */
export type Friend_Status_Type_Mutation_Response = {
  __typename?: 'friend_status_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Friend_Status_Type>;
};

/** on_conflict condition type for table "friend_status_type" */
export type Friend_Status_Type_On_Conflict = {
  constraint: Friend_Status_Type_Constraint;
  update_columns?: Array<Friend_Status_Type_Update_Column>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "friend_status_type". */
export type Friend_Status_Type_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: friend_status_type */
export type Friend_Status_Type_Pk_Columns_Input = {
  value: Scalars['String']['input'];
};

/** select columns of table "friend_status_type" */
export enum Friend_Status_Type_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "friend_status_type" */
export type Friend_Status_Type_Set_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "friend_status_type" */
export type Friend_Status_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Friend_Status_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Friend_Status_Type_Stream_Cursor_Value_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "friend_status_type" */
export enum Friend_Status_Type_Update_Column {
  /** column name */
  Value = 'value'
}

export type Friend_Status_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Friend_Status_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Friend_Status_Type_Bool_Exp;
};

/** update columns of table "friend_status" */
export enum Friend_Status_Update_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

export type Friend_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Friend_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Friend_Status_Bool_Exp;
};

/** columns and relationships of "full_card" */
export type Full_Card = {
  __typename?: 'full_card';
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_link?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  clues_fixed?: Maybe<Scalars['Boolean']['output']>;
  code: Scalars['String']['output'];
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  deck_options?: Maybe<Scalars['jsonb']['output']>;
  deck_requirements?: Maybe<Scalars['jsonb']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  double_sided?: Maybe<Scalars['Boolean']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  encounter_sets: Array<Card_Encounter_Set>;
  /** An aggregate relationship */
  encounter_sets_aggregate: Card_Encounter_Set_Aggregate;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  exceptional?: Maybe<Scalars['Boolean']['output']>;
  exile?: Maybe<Scalars['Boolean']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code: Scalars['String']['output'];
  health?: Maybe<Scalars['Int']['output']>;
  health_per_investigator?: Maybe<Scalars['Boolean']['output']>;
  hidden?: Maybe<Scalars['Boolean']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  is_unique?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  linked_card?: Maybe<Full_Card>;
  myriad?: Maybe<Scalars['Boolean']['output']>;
  pack_code: Scalars['String']['output'];
  pack_position: Scalars['Int']['output'];
  /** An array relationship */
  packs: Array<Card_Pack>;
  /** An aggregate relationship */
  packs_aggregate: Card_Pack_Aggregate;
  permanent?: Maybe<Scalars['Boolean']['output']>;
  position: Scalars['Int']['output'];
  quantity: Scalars['Int']['output'];
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name: Scalars['String']['output'];
  real_pack_name: Scalars['String']['output'];
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  restrictions?: Maybe<Scalars['jsonb']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  translations: Array<Full_Card_Text>;
  /** An aggregate relationship */
  translations_aggregate: Full_Card_Text_Aggregate;
  type_code: Card_Type_Code_Enum;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version: Scalars['Int']['output'];
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "full_card" */
export type Full_CardDeck_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "full_card" */
export type Full_CardDeck_RequirementsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "full_card" */
export type Full_CardEncounter_SetsArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


/** columns and relationships of "full_card" */
export type Full_CardEncounter_Sets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


/** columns and relationships of "full_card" */
export type Full_CardPacksArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "full_card" */
export type Full_CardPacks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "full_card" */
export type Full_CardRestrictionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "full_card" */
export type Full_CardTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


/** columns and relationships of "full_card" */
export type Full_CardTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};

/** aggregated selection of "full_card" */
export type Full_Card_Aggregate = {
  __typename?: 'full_card_aggregate';
  aggregate?: Maybe<Full_Card_Aggregate_Fields>;
  nodes: Array<Full_Card>;
};

/** aggregate fields of "full_card" */
export type Full_Card_Aggregate_Fields = {
  __typename?: 'full_card_aggregate_fields';
  avg?: Maybe<Full_Card_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Full_Card_Max_Fields>;
  min?: Maybe<Full_Card_Min_Fields>;
  stddev?: Maybe<Full_Card_Stddev_Fields>;
  stddev_pop?: Maybe<Full_Card_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Full_Card_Stddev_Samp_Fields>;
  sum?: Maybe<Full_Card_Sum_Fields>;
  var_pop?: Maybe<Full_Card_Var_Pop_Fields>;
  var_samp?: Maybe<Full_Card_Var_Samp_Fields>;
  variance?: Maybe<Full_Card_Variance_Fields>;
};


/** aggregate fields of "full_card" */
export type Full_Card_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Full_Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Full_Card_Append_Input = {
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Full_Card_Avg_Fields = {
  __typename?: 'full_card_avg_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "full_card". All fields are combined with a logical 'AND'. */
export type Full_Card_Bool_Exp = {
  _and?: InputMaybe<Array<Full_Card_Bool_Exp>>;
  _not?: InputMaybe<Full_Card_Bool_Exp>;
  _or?: InputMaybe<Array<Full_Card_Bool_Exp>>;
  alternate_required_code?: InputMaybe<String_Comparison_Exp>;
  back_link?: InputMaybe<String_Comparison_Exp>;
  backimagesrc?: InputMaybe<String_Comparison_Exp>;
  clues?: InputMaybe<Int_Comparison_Exp>;
  clues_fixed?: InputMaybe<Boolean_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  deck_limit?: InputMaybe<Int_Comparison_Exp>;
  deck_options?: InputMaybe<Jsonb_Comparison_Exp>;
  deck_requirements?: InputMaybe<Jsonb_Comparison_Exp>;
  doom?: InputMaybe<Int_Comparison_Exp>;
  double_sided?: InputMaybe<Boolean_Comparison_Exp>;
  encounter_code?: InputMaybe<String_Comparison_Exp>;
  encounter_position?: InputMaybe<Int_Comparison_Exp>;
  encounter_sets?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  encounter_sets_aggregate?: InputMaybe<Card_Encounter_Set_Aggregate_Bool_Exp>;
  enemy_damage?: InputMaybe<Int_Comparison_Exp>;
  enemy_evade?: InputMaybe<Int_Comparison_Exp>;
  enemy_fight?: InputMaybe<Int_Comparison_Exp>;
  enemy_horror?: InputMaybe<Int_Comparison_Exp>;
  exceptional?: InputMaybe<Boolean_Comparison_Exp>;
  exile?: InputMaybe<Boolean_Comparison_Exp>;
  faction2_code?: InputMaybe<String_Comparison_Exp>;
  faction3_code?: InputMaybe<String_Comparison_Exp>;
  faction_code?: InputMaybe<String_Comparison_Exp>;
  health?: InputMaybe<Int_Comparison_Exp>;
  health_per_investigator?: InputMaybe<Boolean_Comparison_Exp>;
  hidden?: InputMaybe<Boolean_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  is_unique?: InputMaybe<Boolean_Comparison_Exp>;
  linked_card?: InputMaybe<Full_Card_Bool_Exp>;
  myriad?: InputMaybe<Boolean_Comparison_Exp>;
  pack_code?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  packs?: InputMaybe<Card_Pack_Bool_Exp>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Bool_Exp>;
  permanent?: InputMaybe<Boolean_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  real_back_flavor?: InputMaybe<String_Comparison_Exp>;
  real_back_name?: InputMaybe<String_Comparison_Exp>;
  real_back_text?: InputMaybe<String_Comparison_Exp>;
  real_encounter_set_name?: InputMaybe<String_Comparison_Exp>;
  real_flavor?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_pack_name?: InputMaybe<String_Comparison_Exp>;
  real_slot?: InputMaybe<String_Comparison_Exp>;
  real_subname?: InputMaybe<String_Comparison_Exp>;
  real_text?: InputMaybe<String_Comparison_Exp>;
  real_traits?: InputMaybe<String_Comparison_Exp>;
  restrictions?: InputMaybe<Jsonb_Comparison_Exp>;
  sanity?: InputMaybe<Int_Comparison_Exp>;
  shroud?: InputMaybe<Int_Comparison_Exp>;
  skill_agility?: InputMaybe<Int_Comparison_Exp>;
  skill_combat?: InputMaybe<Int_Comparison_Exp>;
  skill_intellect?: InputMaybe<Int_Comparison_Exp>;
  skill_wild?: InputMaybe<Int_Comparison_Exp>;
  skill_willpower?: InputMaybe<Int_Comparison_Exp>;
  stage?: InputMaybe<Int_Comparison_Exp>;
  subtype_code?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Full_Card_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Full_Card_Text_Aggregate_Bool_Exp>;
  type_code?: InputMaybe<Card_Type_Code_Enum_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  vengeance?: InputMaybe<Int_Comparison_Exp>;
  version?: InputMaybe<Int_Comparison_Exp>;
  victory?: InputMaybe<Int_Comparison_Exp>;
  xp?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "full_card" */
export enum Full_Card_Constraint {
  /** unique or primary key constraint on columns "code" */
  FullCardPkey = 'full_card_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Full_Card_Delete_At_Path_Input = {
  deck_options?: InputMaybe<Array<Scalars['String']['input']>>;
  deck_requirements?: InputMaybe<Array<Scalars['String']['input']>>;
  restrictions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Full_Card_Delete_Elem_Input = {
  deck_options?: InputMaybe<Scalars['Int']['input']>;
  deck_requirements?: InputMaybe<Scalars['Int']['input']>;
  restrictions?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Full_Card_Delete_Key_Input = {
  deck_options?: InputMaybe<Scalars['String']['input']>;
  deck_requirements?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "full_card" */
export type Full_Card_Inc_Input = {
  clues?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "full_card" */
export type Full_Card_Insert_Input = {
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_link?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  encounter_sets?: InputMaybe<Card_Encounter_Set_Arr_Rel_Insert_Input>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  linked_card?: InputMaybe<Full_Card_Obj_Rel_Insert_Input>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  packs?: InputMaybe<Card_Pack_Arr_Rel_Insert_Input>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Full_Card_Text_Arr_Rel_Insert_Input>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Full_Card_Max_Fields = {
  __typename?: 'full_card_max_fields';
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_link?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Full_Card_Min_Fields = {
  __typename?: 'full_card_min_fields';
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_link?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "full_card" */
export type Full_Card_Mutation_Response = {
  __typename?: 'full_card_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Full_Card>;
};

/** input type for inserting object relation for remote table "full_card" */
export type Full_Card_Obj_Rel_Insert_Input = {
  data: Full_Card_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Full_Card_On_Conflict>;
};

/** on_conflict condition type for table "full_card" */
export type Full_Card_On_Conflict = {
  constraint: Full_Card_Constraint;
  update_columns?: Array<Full_Card_Update_Column>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};

/** Ordering options when selecting data from "full_card". */
export type Full_Card_Order_By = {
  alternate_required_code?: InputMaybe<Order_By>;
  back_link?: InputMaybe<Order_By>;
  backimagesrc?: InputMaybe<Order_By>;
  clues?: InputMaybe<Order_By>;
  clues_fixed?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  deck_options?: InputMaybe<Order_By>;
  deck_requirements?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  double_sided?: InputMaybe<Order_By>;
  encounter_code?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  encounter_sets_aggregate?: InputMaybe<Card_Encounter_Set_Aggregate_Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  exceptional?: InputMaybe<Order_By>;
  exile?: InputMaybe<Order_By>;
  faction2_code?: InputMaybe<Order_By>;
  faction3_code?: InputMaybe<Order_By>;
  faction_code?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  health_per_investigator?: InputMaybe<Order_By>;
  hidden?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  is_unique?: InputMaybe<Order_By>;
  linked_card?: InputMaybe<Full_Card_Order_By>;
  myriad?: InputMaybe<Order_By>;
  pack_code?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Order_By>;
  permanent?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_name?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_encounter_set_name?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_pack_name?: InputMaybe<Order_By>;
  real_slot?: InputMaybe<Order_By>;
  real_subname?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  restrictions?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  subtype_code?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Full_Card_Text_Aggregate_Order_By>;
  type_code?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** primary key columns input for table: full_card */
export type Full_Card_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Full_Card_Prepend_Input = {
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "full_card" */
export enum Full_Card_Select_Column {
  /** column name */
  AlternateRequiredCode = 'alternate_required_code',
  /** column name */
  BackLink = 'back_link',
  /** column name */
  Backimagesrc = 'backimagesrc',
  /** column name */
  Clues = 'clues',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  Faction2Code = 'faction2_code',
  /** column name */
  Faction3Code = 'faction3_code',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Health = 'health',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealEncounterSetName = 'real_encounter_set_name',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Vengeance = 'vengeance',
  /** column name */
  Version = 'version',
  /** column name */
  Victory = 'victory',
  /** column name */
  Xp = 'xp'
}

/** input type for updating data in table "full_card" */
export type Full_Card_Set_Input = {
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_link?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Full_Card_Stddev_Fields = {
  __typename?: 'full_card_stddev_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Full_Card_Stddev_Pop_Fields = {
  __typename?: 'full_card_stddev_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Full_Card_Stddev_Samp_Fields = {
  __typename?: 'full_card_stddev_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "full_card" */
export type Full_Card_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Full_Card_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Full_Card_Stream_Cursor_Value_Input = {
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_link?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Full_Card_Sum_Fields = {
  __typename?: 'full_card_sum_fields';
  clues?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "full_card_text" */
export type Full_Card_Text = {
  __typename?: 'full_card_text';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "full_card_text" */
export type Full_Card_Text_Aggregate = {
  __typename?: 'full_card_text_aggregate';
  aggregate?: Maybe<Full_Card_Text_Aggregate_Fields>;
  nodes: Array<Full_Card_Text>;
};

export type Full_Card_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Full_Card_Text_Aggregate_Bool_Exp_Count>;
};

export type Full_Card_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Full_Card_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "full_card_text" */
export type Full_Card_Text_Aggregate_Fields = {
  __typename?: 'full_card_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Full_Card_Text_Max_Fields>;
  min?: Maybe<Full_Card_Text_Min_Fields>;
};


/** aggregate fields of "full_card_text" */
export type Full_Card_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "full_card_text" */
export type Full_Card_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Full_Card_Text_Max_Order_By>;
  min?: InputMaybe<Full_Card_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "full_card_text" */
export type Full_Card_Text_Arr_Rel_Insert_Input = {
  data: Array<Full_Card_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Full_Card_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "full_card_text". All fields are combined with a logical 'AND'. */
export type Full_Card_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Full_Card_Text_Bool_Exp>>;
  _not?: InputMaybe<Full_Card_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Full_Card_Text_Bool_Exp>>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_name?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  encounter_name?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  slot?: InputMaybe<String_Comparison_Exp>;
  subname?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "full_card_text" */
export enum Full_Card_Text_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  FullCardTextPkey = 'full_card_text_pkey'
}

/** input type for inserting data into table "full_card_text" */
export type Full_Card_Text_Insert_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Full_Card_Text_Max_Fields = {
  __typename?: 'full_card_text_max_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "full_card_text" */
export type Full_Card_Text_Max_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Full_Card_Text_Min_Fields = {
  __typename?: 'full_card_text_min_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "full_card_text" */
export type Full_Card_Text_Min_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "full_card_text" */
export type Full_Card_Text_Mutation_Response = {
  __typename?: 'full_card_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Full_Card_Text>;
};

/** on_conflict condition type for table "full_card_text" */
export type Full_Card_Text_On_Conflict = {
  constraint: Full_Card_Text_Constraint;
  update_columns?: Array<Full_Card_Text_Update_Column>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "full_card_text". */
export type Full_Card_Text_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** primary key columns input for table: full_card_text */
export type Full_Card_Text_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "full_card_text" */
export enum Full_Card_Text_Select_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  Code = 'code',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits'
}

/** input type for updating data in table "full_card_text" */
export type Full_Card_Text_Set_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "full_card_text" */
export type Full_Card_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Full_Card_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Full_Card_Text_Stream_Cursor_Value_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "full_card_text" */
export enum Full_Card_Text_Update_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  Code = 'code',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits'
}

export type Full_Card_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Full_Card_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Full_Card_Text_Bool_Exp;
};

/** update columns of table "full_card" */
export enum Full_Card_Update_Column {
  /** column name */
  AlternateRequiredCode = 'alternate_required_code',
  /** column name */
  BackLink = 'back_link',
  /** column name */
  Backimagesrc = 'backimagesrc',
  /** column name */
  Clues = 'clues',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  Faction2Code = 'faction2_code',
  /** column name */
  Faction3Code = 'faction3_code',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Health = 'health',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealEncounterSetName = 'real_encounter_set_name',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Vengeance = 'vengeance',
  /** column name */
  Version = 'version',
  /** column name */
  Victory = 'victory',
  /** column name */
  Xp = 'xp'
}

export type Full_Card_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Full_Card_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Full_Card_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Full_Card_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Full_Card_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Full_Card_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Full_Card_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Full_Card_Set_Input>;
  /** filter the rows which have to be updated */
  where: Full_Card_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Full_Card_Var_Pop_Fields = {
  __typename?: 'full_card_var_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Full_Card_Var_Samp_Fields = {
  __typename?: 'full_card_var_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Full_Card_Variance_Fields = {
  __typename?: 'full_card_variance_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "gender" */
export type Gender = {
  __typename?: 'gender';
  code: Scalars['String']['output'];
};

/** aggregated selection of "gender" */
export type Gender_Aggregate = {
  __typename?: 'gender_aggregate';
  aggregate?: Maybe<Gender_Aggregate_Fields>;
  nodes: Array<Gender>;
};

/** aggregate fields of "gender" */
export type Gender_Aggregate_Fields = {
  __typename?: 'gender_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Gender_Max_Fields>;
  min?: Maybe<Gender_Min_Fields>;
};


/** aggregate fields of "gender" */
export type Gender_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Gender_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "gender". All fields are combined with a logical 'AND'. */
export type Gender_Bool_Exp = {
  _and?: InputMaybe<Array<Gender_Bool_Exp>>;
  _not?: InputMaybe<Gender_Bool_Exp>;
  _or?: InputMaybe<Array<Gender_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "gender" */
export enum Gender_Constraint {
  /** unique or primary key constraint on columns "code" */
  GenderPkey = 'gender_pkey'
}

export enum Gender_Enum {
  F = 'f',
  M = 'm',
  Nb = 'nb'
}

/** Boolean expression to compare columns of type "gender_enum". All fields are combined with logical 'AND'. */
export type Gender_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Gender_Enum>;
  _in?: InputMaybe<Array<Gender_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Gender_Enum>;
  _nin?: InputMaybe<Array<Gender_Enum>>;
};

/** input type for inserting data into table "gender" */
export type Gender_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Gender_Max_Fields = {
  __typename?: 'gender_max_fields';
  code?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Gender_Min_Fields = {
  __typename?: 'gender_min_fields';
  code?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "gender" */
export type Gender_Mutation_Response = {
  __typename?: 'gender_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Gender>;
};

/** on_conflict condition type for table "gender" */
export type Gender_On_Conflict = {
  constraint: Gender_Constraint;
  update_columns?: Array<Gender_Update_Column>;
  where?: InputMaybe<Gender_Bool_Exp>;
};

/** Ordering options when selecting data from "gender". */
export type Gender_Order_By = {
  code?: InputMaybe<Order_By>;
};

/** primary key columns input for table: gender */
export type Gender_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** select columns of table "gender" */
export enum Gender_Select_Column {
  /** column name */
  Code = 'code'
}

/** input type for updating data in table "gender" */
export type Gender_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "gender" */
export type Gender_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Gender_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Gender_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "gender" */
export enum Gender_Update_Column {
  /** column name */
  Code = 'code'
}

export type Gender_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Gender_Set_Input>;
  /** filter the rows which have to be updated */
  where: Gender_Bool_Exp;
};

/** columns and relationships of "guide_achievement" */
export type Guide_Achievement = {
  __typename?: 'guide_achievement';
  bool_value?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  campaign: Campaign;
  campaign_id: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['String']['output'];
  type: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  value?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "guide_achievement" */
export type Guide_Achievement_Aggregate = {
  __typename?: 'guide_achievement_aggregate';
  aggregate?: Maybe<Guide_Achievement_Aggregate_Fields>;
  nodes: Array<Guide_Achievement>;
};

export type Guide_Achievement_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Guide_Achievement_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Guide_Achievement_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Guide_Achievement_Aggregate_Bool_Exp_Count>;
};

export type Guide_Achievement_Aggregate_Bool_Exp_Bool_And = {
  arguments: Guide_Achievement_Select_Column_Guide_Achievement_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Guide_Achievement_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Guide_Achievement_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Guide_Achievement_Select_Column_Guide_Achievement_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Guide_Achievement_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Guide_Achievement_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Guide_Achievement_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "guide_achievement" */
export type Guide_Achievement_Aggregate_Fields = {
  __typename?: 'guide_achievement_aggregate_fields';
  avg?: Maybe<Guide_Achievement_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Guide_Achievement_Max_Fields>;
  min?: Maybe<Guide_Achievement_Min_Fields>;
  stddev?: Maybe<Guide_Achievement_Stddev_Fields>;
  stddev_pop?: Maybe<Guide_Achievement_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Guide_Achievement_Stddev_Samp_Fields>;
  sum?: Maybe<Guide_Achievement_Sum_Fields>;
  var_pop?: Maybe<Guide_Achievement_Var_Pop_Fields>;
  var_samp?: Maybe<Guide_Achievement_Var_Samp_Fields>;
  variance?: Maybe<Guide_Achievement_Variance_Fields>;
};


/** aggregate fields of "guide_achievement" */
export type Guide_Achievement_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "guide_achievement" */
export type Guide_Achievement_Aggregate_Order_By = {
  avg?: InputMaybe<Guide_Achievement_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Guide_Achievement_Max_Order_By>;
  min?: InputMaybe<Guide_Achievement_Min_Order_By>;
  stddev?: InputMaybe<Guide_Achievement_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Guide_Achievement_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Guide_Achievement_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Guide_Achievement_Sum_Order_By>;
  var_pop?: InputMaybe<Guide_Achievement_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Guide_Achievement_Var_Samp_Order_By>;
  variance?: InputMaybe<Guide_Achievement_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "guide_achievement" */
export type Guide_Achievement_Arr_Rel_Insert_Input = {
  data: Array<Guide_Achievement_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Guide_Achievement_On_Conflict>;
};

/** aggregate avg on columns */
export type Guide_Achievement_Avg_Fields = {
  __typename?: 'guide_achievement_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "guide_achievement" */
export type Guide_Achievement_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "guide_achievement". All fields are combined with a logical 'AND'. */
export type Guide_Achievement_Bool_Exp = {
  _and?: InputMaybe<Array<Guide_Achievement_Bool_Exp>>;
  _not?: InputMaybe<Guide_Achievement_Bool_Exp>;
  _or?: InputMaybe<Array<Guide_Achievement_Bool_Exp>>;
  bool_value?: InputMaybe<Boolean_Comparison_Exp>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  value?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "guide_achievement" */
export enum Guide_Achievement_Constraint {
  /** unique or primary key constraint on columns "id", "campaign_id" */
  GuideAchievementPkey = 'guide_achievement_pkey'
}

/** input type for incrementing numeric columns in table "guide_achievement" */
export type Guide_Achievement_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "guide_achievement" */
export type Guide_Achievement_Insert_Input = {
  bool_value?: InputMaybe<Scalars['Boolean']['input']>;
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Guide_Achievement_Max_Fields = {
  __typename?: 'guide_achievement_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  value?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "guide_achievement" */
export type Guide_Achievement_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Guide_Achievement_Min_Fields = {
  __typename?: 'guide_achievement_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  value?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "guide_achievement" */
export type Guide_Achievement_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "guide_achievement" */
export type Guide_Achievement_Mutation_Response = {
  __typename?: 'guide_achievement_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Guide_Achievement>;
};

/** on_conflict condition type for table "guide_achievement" */
export type Guide_Achievement_On_Conflict = {
  constraint: Guide_Achievement_Constraint;
  update_columns?: Array<Guide_Achievement_Update_Column>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};

/** Ordering options when selecting data from "guide_achievement". */
export type Guide_Achievement_Order_By = {
  bool_value?: InputMaybe<Order_By>;
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: guide_achievement */
export type Guide_Achievement_Pk_Columns_Input = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};

/** select columns of table "guide_achievement" */
export enum Guide_Achievement_Select_Column {
  /** column name */
  BoolValue = 'bool_value',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

/** select "guide_achievement_aggregate_bool_exp_bool_and_arguments_columns" columns of table "guide_achievement" */
export enum Guide_Achievement_Select_Column_Guide_Achievement_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  BoolValue = 'bool_value'
}

/** select "guide_achievement_aggregate_bool_exp_bool_or_arguments_columns" columns of table "guide_achievement" */
export enum Guide_Achievement_Select_Column_Guide_Achievement_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  BoolValue = 'bool_value'
}

/** input type for updating data in table "guide_achievement" */
export type Guide_Achievement_Set_Input = {
  bool_value?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Guide_Achievement_Stddev_Fields = {
  __typename?: 'guide_achievement_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "guide_achievement" */
export type Guide_Achievement_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Guide_Achievement_Stddev_Pop_Fields = {
  __typename?: 'guide_achievement_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "guide_achievement" */
export type Guide_Achievement_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Guide_Achievement_Stddev_Samp_Fields = {
  __typename?: 'guide_achievement_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "guide_achievement" */
export type Guide_Achievement_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "guide_achievement" */
export type Guide_Achievement_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Guide_Achievement_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Guide_Achievement_Stream_Cursor_Value_Input = {
  bool_value?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Guide_Achievement_Sum_Fields = {
  __typename?: 'guide_achievement_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  value?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "guide_achievement" */
export type Guide_Achievement_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** update columns of table "guide_achievement" */
export enum Guide_Achievement_Update_Column {
  /** column name */
  BoolValue = 'bool_value',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

export type Guide_Achievement_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Guide_Achievement_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Guide_Achievement_Set_Input>;
  /** filter the rows which have to be updated */
  where: Guide_Achievement_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Guide_Achievement_Var_Pop_Fields = {
  __typename?: 'guide_achievement_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "guide_achievement" */
export type Guide_Achievement_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Guide_Achievement_Var_Samp_Fields = {
  __typename?: 'guide_achievement_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "guide_achievement" */
export type Guide_Achievement_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Guide_Achievement_Variance_Fields = {
  __typename?: 'guide_achievement_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "guide_achievement" */
export type Guide_Achievement_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** columns and relationships of "guide_input" */
export type Guide_Input = {
  __typename?: 'guide_input';
  /** An object relationship */
  campaign: Campaign;
  campaign_id: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['String']['output'];
  inserted_idx?: Maybe<Scalars['Int']['output']>;
  payload?: Maybe<Scalars['jsonb']['output']>;
  scenario?: Maybe<Scalars['String']['output']>;
  step?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "guide_input" */
export type Guide_InputPayloadArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "guide_input" */
export type Guide_Input_Aggregate = {
  __typename?: 'guide_input_aggregate';
  aggregate?: Maybe<Guide_Input_Aggregate_Fields>;
  nodes: Array<Guide_Input>;
};

export type Guide_Input_Aggregate_Bool_Exp = {
  count?: InputMaybe<Guide_Input_Aggregate_Bool_Exp_Count>;
};

export type Guide_Input_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Guide_Input_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Guide_Input_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "guide_input" */
export type Guide_Input_Aggregate_Fields = {
  __typename?: 'guide_input_aggregate_fields';
  avg?: Maybe<Guide_Input_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Guide_Input_Max_Fields>;
  min?: Maybe<Guide_Input_Min_Fields>;
  stddev?: Maybe<Guide_Input_Stddev_Fields>;
  stddev_pop?: Maybe<Guide_Input_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Guide_Input_Stddev_Samp_Fields>;
  sum?: Maybe<Guide_Input_Sum_Fields>;
  var_pop?: Maybe<Guide_Input_Var_Pop_Fields>;
  var_samp?: Maybe<Guide_Input_Var_Samp_Fields>;
  variance?: Maybe<Guide_Input_Variance_Fields>;
};


/** aggregate fields of "guide_input" */
export type Guide_Input_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Guide_Input_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "guide_input" */
export type Guide_Input_Aggregate_Order_By = {
  avg?: InputMaybe<Guide_Input_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Guide_Input_Max_Order_By>;
  min?: InputMaybe<Guide_Input_Min_Order_By>;
  stddev?: InputMaybe<Guide_Input_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Guide_Input_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Guide_Input_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Guide_Input_Sum_Order_By>;
  var_pop?: InputMaybe<Guide_Input_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Guide_Input_Var_Samp_Order_By>;
  variance?: InputMaybe<Guide_Input_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Guide_Input_Append_Input = {
  payload?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "guide_input" */
export type Guide_Input_Arr_Rel_Insert_Input = {
  data: Array<Guide_Input_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Guide_Input_On_Conflict>;
};

/** aggregate avg on columns */
export type Guide_Input_Avg_Fields = {
  __typename?: 'guide_input_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "guide_input" */
export type Guide_Input_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "guide_input". All fields are combined with a logical 'AND'. */
export type Guide_Input_Bool_Exp = {
  _and?: InputMaybe<Array<Guide_Input_Bool_Exp>>;
  _not?: InputMaybe<Guide_Input_Bool_Exp>;
  _or?: InputMaybe<Array<Guide_Input_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  inserted_idx?: InputMaybe<Int_Comparison_Exp>;
  payload?: InputMaybe<Jsonb_Comparison_Exp>;
  scenario?: InputMaybe<String_Comparison_Exp>;
  step?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "guide_input" */
export enum Guide_Input_Constraint {
  /** unique or primary key constraint on columns "id", "campaign_id" */
  GuideInputPkey = 'guide_input_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Guide_Input_Delete_At_Path_Input = {
  payload?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Guide_Input_Delete_Elem_Input = {
  payload?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Guide_Input_Delete_Key_Input = {
  payload?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "guide_input" */
export type Guide_Input_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  inserted_idx?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "guide_input" */
export type Guide_Input_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  inserted_idx?: InputMaybe<Scalars['Int']['input']>;
  payload?: InputMaybe<Scalars['jsonb']['input']>;
  scenario?: InputMaybe<Scalars['String']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Guide_Input_Max_Fields = {
  __typename?: 'guide_input_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  inserted_idx?: Maybe<Scalars['Int']['output']>;
  scenario?: Maybe<Scalars['String']['output']>;
  step?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "guide_input" */
export type Guide_Input_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
  scenario?: InputMaybe<Order_By>;
  step?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Guide_Input_Min_Fields = {
  __typename?: 'guide_input_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  inserted_idx?: Maybe<Scalars['Int']['output']>;
  scenario?: Maybe<Scalars['String']['output']>;
  step?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "guide_input" */
export type Guide_Input_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
  scenario?: InputMaybe<Order_By>;
  step?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "guide_input" */
export type Guide_Input_Mutation_Response = {
  __typename?: 'guide_input_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Guide_Input>;
};

/** on_conflict condition type for table "guide_input" */
export type Guide_Input_On_Conflict = {
  constraint: Guide_Input_Constraint;
  update_columns?: Array<Guide_Input_Update_Column>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};

/** Ordering options when selecting data from "guide_input". */
export type Guide_Input_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
  payload?: InputMaybe<Order_By>;
  scenario?: InputMaybe<Order_By>;
  step?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: guide_input */
export type Guide_Input_Pk_Columns_Input = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Guide_Input_Prepend_Input = {
  payload?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "guide_input" */
export enum Guide_Input_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  InsertedIdx = 'inserted_idx',
  /** column name */
  Payload = 'payload',
  /** column name */
  Scenario = 'scenario',
  /** column name */
  Step = 'step',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "guide_input" */
export type Guide_Input_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  inserted_idx?: InputMaybe<Scalars['Int']['input']>;
  payload?: InputMaybe<Scalars['jsonb']['input']>;
  scenario?: InputMaybe<Scalars['String']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Guide_Input_Stddev_Fields = {
  __typename?: 'guide_input_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "guide_input" */
export type Guide_Input_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Guide_Input_Stddev_Pop_Fields = {
  __typename?: 'guide_input_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "guide_input" */
export type Guide_Input_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Guide_Input_Stddev_Samp_Fields = {
  __typename?: 'guide_input_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "guide_input" */
export type Guide_Input_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "guide_input" */
export type Guide_Input_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Guide_Input_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Guide_Input_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  inserted_idx?: InputMaybe<Scalars['Int']['input']>;
  payload?: InputMaybe<Scalars['jsonb']['input']>;
  scenario?: InputMaybe<Scalars['String']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Guide_Input_Sum_Fields = {
  __typename?: 'guide_input_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  inserted_idx?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "guide_input" */
export type Guide_Input_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** update columns of table "guide_input" */
export enum Guide_Input_Update_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  InsertedIdx = 'inserted_idx',
  /** column name */
  Payload = 'payload',
  /** column name */
  Scenario = 'scenario',
  /** column name */
  Step = 'step',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Guide_Input_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Guide_Input_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Guide_Input_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Guide_Input_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Guide_Input_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Guide_Input_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Guide_Input_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Guide_Input_Set_Input>;
  /** filter the rows which have to be updated */
  where: Guide_Input_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Guide_Input_Var_Pop_Fields = {
  __typename?: 'guide_input_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "guide_input" */
export type Guide_Input_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Guide_Input_Var_Samp_Fields = {
  __typename?: 'guide_input_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "guide_input" */
export type Guide_Input_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Guide_Input_Variance_Fields = {
  __typename?: 'guide_input_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "guide_input" */
export type Guide_Input_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** columns and relationships of "investigator_data" */
export type Investigator_Data = {
  __typename?: 'investigator_data';
  addedCards?: Maybe<Scalars['jsonb']['output']>;
  availableXp?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  campaign_data: Campaign;
  campaign_id: Scalars['Int']['output'];
  cardCounts?: Maybe<Scalars['jsonb']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** A computed field, executes function "investigator_data_id" */
  id?: Maybe<Scalars['String']['output']>;
  ignoreStoryAssets?: Maybe<Scalars['jsonb']['output']>;
  insane?: Maybe<Scalars['Boolean']['output']>;
  investigator: Scalars['String']['output'];
  killed?: Maybe<Scalars['Boolean']['output']>;
  mental?: Maybe<Scalars['Int']['output']>;
  physical?: Maybe<Scalars['Int']['output']>;
  removedCards?: Maybe<Scalars['jsonb']['output']>;
  specialXp?: Maybe<Scalars['jsonb']['output']>;
  spentXp?: Maybe<Scalars['Int']['output']>;
  storyAssets?: Maybe<Scalars['jsonb']['output']>;
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataAddedCardsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataCardCountsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataIgnoreStoryAssetsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataRemovedCardsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataSpecialXpArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataStoryAssetsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "investigator_data" */
export type Investigator_Data_Aggregate = {
  __typename?: 'investigator_data_aggregate';
  aggregate?: Maybe<Investigator_Data_Aggregate_Fields>;
  nodes: Array<Investigator_Data>;
};

export type Investigator_Data_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Investigator_Data_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Investigator_Data_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Investigator_Data_Aggregate_Bool_Exp_Count>;
};

export type Investigator_Data_Aggregate_Bool_Exp_Bool_And = {
  arguments: Investigator_Data_Select_Column_Investigator_Data_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Investigator_Data_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Investigator_Data_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Investigator_Data_Select_Column_Investigator_Data_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Investigator_Data_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Investigator_Data_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Investigator_Data_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "investigator_data" */
export type Investigator_Data_Aggregate_Fields = {
  __typename?: 'investigator_data_aggregate_fields';
  avg?: Maybe<Investigator_Data_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Investigator_Data_Max_Fields>;
  min?: Maybe<Investigator_Data_Min_Fields>;
  stddev?: Maybe<Investigator_Data_Stddev_Fields>;
  stddev_pop?: Maybe<Investigator_Data_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Investigator_Data_Stddev_Samp_Fields>;
  sum?: Maybe<Investigator_Data_Sum_Fields>;
  var_pop?: Maybe<Investigator_Data_Var_Pop_Fields>;
  var_samp?: Maybe<Investigator_Data_Var_Samp_Fields>;
  variance?: Maybe<Investigator_Data_Variance_Fields>;
};


/** aggregate fields of "investigator_data" */
export type Investigator_Data_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "investigator_data" */
export type Investigator_Data_Aggregate_Order_By = {
  avg?: InputMaybe<Investigator_Data_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Investigator_Data_Max_Order_By>;
  min?: InputMaybe<Investigator_Data_Min_Order_By>;
  stddev?: InputMaybe<Investigator_Data_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Investigator_Data_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Investigator_Data_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Investigator_Data_Sum_Order_By>;
  var_pop?: InputMaybe<Investigator_Data_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Investigator_Data_Var_Samp_Order_By>;
  variance?: InputMaybe<Investigator_Data_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Investigator_Data_Append_Input = {
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "investigator_data" */
export type Investigator_Data_Arr_Rel_Insert_Input = {
  data: Array<Investigator_Data_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Investigator_Data_On_Conflict>;
};

/** aggregate avg on columns */
export type Investigator_Data_Avg_Fields = {
  __typename?: 'investigator_data_avg_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "investigator_data" */
export type Investigator_Data_Avg_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "investigator_data". All fields are combined with a logical 'AND'. */
export type Investigator_Data_Bool_Exp = {
  _and?: InputMaybe<Array<Investigator_Data_Bool_Exp>>;
  _not?: InputMaybe<Investigator_Data_Bool_Exp>;
  _or?: InputMaybe<Array<Investigator_Data_Bool_Exp>>;
  addedCards?: InputMaybe<Jsonb_Comparison_Exp>;
  availableXp?: InputMaybe<Int_Comparison_Exp>;
  campaign_data?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  cardCounts?: InputMaybe<Jsonb_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  ignoreStoryAssets?: InputMaybe<Jsonb_Comparison_Exp>;
  insane?: InputMaybe<Boolean_Comparison_Exp>;
  investigator?: InputMaybe<String_Comparison_Exp>;
  killed?: InputMaybe<Boolean_Comparison_Exp>;
  mental?: InputMaybe<Int_Comparison_Exp>;
  physical?: InputMaybe<Int_Comparison_Exp>;
  removedCards?: InputMaybe<Jsonb_Comparison_Exp>;
  specialXp?: InputMaybe<Jsonb_Comparison_Exp>;
  spentXp?: InputMaybe<Int_Comparison_Exp>;
  storyAssets?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "investigator_data" */
export enum Investigator_Data_Constraint {
  /** unique or primary key constraint on columns "campaign_id", "investigator" */
  InvestigatorDataPkey = 'investigator_data_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Investigator_Data_Delete_At_Path_Input = {
  addedCards?: InputMaybe<Array<Scalars['String']['input']>>;
  cardCounts?: InputMaybe<Array<Scalars['String']['input']>>;
  ignoreStoryAssets?: InputMaybe<Array<Scalars['String']['input']>>;
  removedCards?: InputMaybe<Array<Scalars['String']['input']>>;
  specialXp?: InputMaybe<Array<Scalars['String']['input']>>;
  storyAssets?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Investigator_Data_Delete_Elem_Input = {
  addedCards?: InputMaybe<Scalars['Int']['input']>;
  cardCounts?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['Int']['input']>;
  removedCards?: InputMaybe<Scalars['Int']['input']>;
  specialXp?: InputMaybe<Scalars['Int']['input']>;
  storyAssets?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Investigator_Data_Delete_Key_Input = {
  addedCards?: InputMaybe<Scalars['String']['input']>;
  cardCounts?: InputMaybe<Scalars['String']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['String']['input']>;
  removedCards?: InputMaybe<Scalars['String']['input']>;
  specialXp?: InputMaybe<Scalars['String']['input']>;
  storyAssets?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "investigator_data" */
export type Investigator_Data_Inc_Input = {
  availableXp?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  mental?: InputMaybe<Scalars['Int']['input']>;
  physical?: InputMaybe<Scalars['Int']['input']>;
  spentXp?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "investigator_data" */
export type Investigator_Data_Insert_Input = {
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  availableXp?: InputMaybe<Scalars['Int']['input']>;
  campaign_data?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  insane?: InputMaybe<Scalars['Boolean']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  killed?: InputMaybe<Scalars['Boolean']['input']>;
  mental?: InputMaybe<Scalars['Int']['input']>;
  physical?: InputMaybe<Scalars['Int']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  spentXp?: InputMaybe<Scalars['Int']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Investigator_Data_Max_Fields = {
  __typename?: 'investigator_data_max_fields';
  availableXp?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "investigator_data_id" */
  id?: Maybe<Scalars['String']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  mental?: Maybe<Scalars['Int']['output']>;
  physical?: Maybe<Scalars['Int']['output']>;
  spentXp?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "investigator_data" */
export type Investigator_Data_Max_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Investigator_Data_Min_Fields = {
  __typename?: 'investigator_data_min_fields';
  availableXp?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "investigator_data_id" */
  id?: Maybe<Scalars['String']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  mental?: Maybe<Scalars['Int']['output']>;
  physical?: Maybe<Scalars['Int']['output']>;
  spentXp?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "investigator_data" */
export type Investigator_Data_Min_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "investigator_data" */
export type Investigator_Data_Mutation_Response = {
  __typename?: 'investigator_data_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Investigator_Data>;
};

/** input type for inserting object relation for remote table "investigator_data" */
export type Investigator_Data_Obj_Rel_Insert_Input = {
  data: Investigator_Data_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Investigator_Data_On_Conflict>;
};

/** on_conflict condition type for table "investigator_data" */
export type Investigator_Data_On_Conflict = {
  constraint: Investigator_Data_Constraint;
  update_columns?: Array<Investigator_Data_Update_Column>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};

/** Ordering options when selecting data from "investigator_data". */
export type Investigator_Data_Order_By = {
  addedCards?: InputMaybe<Order_By>;
  availableXp?: InputMaybe<Order_By>;
  campaign_data?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  cardCounts?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  ignoreStoryAssets?: InputMaybe<Order_By>;
  insane?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  killed?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  removedCards?: InputMaybe<Order_By>;
  specialXp?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
  storyAssets?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: investigator_data */
export type Investigator_Data_Pk_Columns_Input = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Investigator_Data_Prepend_Input = {
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "investigator_data" */
export enum Investigator_Data_Select_Column {
  /** column name */
  AddedCards = 'addedCards',
  /** column name */
  AvailableXp = 'availableXp',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CardCounts = 'cardCounts',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  IgnoreStoryAssets = 'ignoreStoryAssets',
  /** column name */
  Insane = 'insane',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  Killed = 'killed',
  /** column name */
  Mental = 'mental',
  /** column name */
  Physical = 'physical',
  /** column name */
  RemovedCards = 'removedCards',
  /** column name */
  SpecialXp = 'specialXp',
  /** column name */
  SpentXp = 'spentXp',
  /** column name */
  StoryAssets = 'storyAssets',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "investigator_data_aggregate_bool_exp_bool_and_arguments_columns" columns of table "investigator_data" */
export enum Investigator_Data_Select_Column_Investigator_Data_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Insane = 'insane',
  /** column name */
  Killed = 'killed'
}

/** select "investigator_data_aggregate_bool_exp_bool_or_arguments_columns" columns of table "investigator_data" */
export enum Investigator_Data_Select_Column_Investigator_Data_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Insane = 'insane',
  /** column name */
  Killed = 'killed'
}

/** input type for updating data in table "investigator_data" */
export type Investigator_Data_Set_Input = {
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  availableXp?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  insane?: InputMaybe<Scalars['Boolean']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  killed?: InputMaybe<Scalars['Boolean']['input']>;
  mental?: InputMaybe<Scalars['Int']['input']>;
  physical?: InputMaybe<Scalars['Int']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  spentXp?: InputMaybe<Scalars['Int']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Investigator_Data_Stddev_Fields = {
  __typename?: 'investigator_data_stddev_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "investigator_data" */
export type Investigator_Data_Stddev_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Investigator_Data_Stddev_Pop_Fields = {
  __typename?: 'investigator_data_stddev_pop_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "investigator_data" */
export type Investigator_Data_Stddev_Pop_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Investigator_Data_Stddev_Samp_Fields = {
  __typename?: 'investigator_data_stddev_samp_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "investigator_data" */
export type Investigator_Data_Stddev_Samp_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "investigator_data" */
export type Investigator_Data_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Investigator_Data_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Investigator_Data_Stream_Cursor_Value_Input = {
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  availableXp?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  insane?: InputMaybe<Scalars['Boolean']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  killed?: InputMaybe<Scalars['Boolean']['input']>;
  mental?: InputMaybe<Scalars['Int']['input']>;
  physical?: InputMaybe<Scalars['Int']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  spentXp?: InputMaybe<Scalars['Int']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Investigator_Data_Sum_Fields = {
  __typename?: 'investigator_data_sum_fields';
  availableXp?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  mental?: Maybe<Scalars['Int']['output']>;
  physical?: Maybe<Scalars['Int']['output']>;
  spentXp?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "investigator_data" */
export type Investigator_Data_Sum_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** update columns of table "investigator_data" */
export enum Investigator_Data_Update_Column {
  /** column name */
  AddedCards = 'addedCards',
  /** column name */
  AvailableXp = 'availableXp',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CardCounts = 'cardCounts',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  IgnoreStoryAssets = 'ignoreStoryAssets',
  /** column name */
  Insane = 'insane',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  Killed = 'killed',
  /** column name */
  Mental = 'mental',
  /** column name */
  Physical = 'physical',
  /** column name */
  RemovedCards = 'removedCards',
  /** column name */
  SpecialXp = 'specialXp',
  /** column name */
  SpentXp = 'spentXp',
  /** column name */
  StoryAssets = 'storyAssets',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Investigator_Data_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Investigator_Data_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Investigator_Data_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Investigator_Data_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Investigator_Data_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Investigator_Data_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Investigator_Data_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Investigator_Data_Set_Input>;
  /** filter the rows which have to be updated */
  where: Investigator_Data_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Investigator_Data_Var_Pop_Fields = {
  __typename?: 'investigator_data_var_pop_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "investigator_data" */
export type Investigator_Data_Var_Pop_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Investigator_Data_Var_Samp_Fields = {
  __typename?: 'investigator_data_var_samp_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "investigator_data" */
export type Investigator_Data_Var_Samp_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Investigator_Data_Variance_Fields = {
  __typename?: 'investigator_data_variance_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "investigator_data" */
export type Investigator_Data_Variance_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

export type Jsonb_Cast_Exp = {
  String?: InputMaybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast?: InputMaybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']['input']>;
  _eq?: InputMaybe<Scalars['jsonb']['input']>;
  _gt?: InputMaybe<Scalars['jsonb']['input']>;
  _gte?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: InputMaybe<Scalars['String']['input']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: InputMaybe<Array<Scalars['String']['input']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: InputMaybe<Array<Scalars['String']['input']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['jsonb']['input']>;
  _lte?: InputMaybe<Scalars['jsonb']['input']>;
  _neq?: InputMaybe<Scalars['jsonb']['input']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']['input']>>;
};

/** columns and relationships of "latest_decks" */
export type Latest_Decks = {
  __typename?: 'latest_decks';
  /** An object relationship */
  campaign?: Maybe<Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  deck?: Maybe<Campaign_Deck>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "latest_decks" */
export type Latest_Decks_Aggregate = {
  __typename?: 'latest_decks_aggregate';
  aggregate?: Maybe<Latest_Decks_Aggregate_Fields>;
  nodes: Array<Latest_Decks>;
};

export type Latest_Decks_Aggregate_Bool_Exp = {
  count?: InputMaybe<Latest_Decks_Aggregate_Bool_Exp_Count>;
};

export type Latest_Decks_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Latest_Decks_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "latest_decks" */
export type Latest_Decks_Aggregate_Fields = {
  __typename?: 'latest_decks_aggregate_fields';
  avg?: Maybe<Latest_Decks_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Latest_Decks_Max_Fields>;
  min?: Maybe<Latest_Decks_Min_Fields>;
  stddev?: Maybe<Latest_Decks_Stddev_Fields>;
  stddev_pop?: Maybe<Latest_Decks_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Latest_Decks_Stddev_Samp_Fields>;
  sum?: Maybe<Latest_Decks_Sum_Fields>;
  var_pop?: Maybe<Latest_Decks_Var_Pop_Fields>;
  var_samp?: Maybe<Latest_Decks_Var_Samp_Fields>;
  variance?: Maybe<Latest_Decks_Variance_Fields>;
};


/** aggregate fields of "latest_decks" */
export type Latest_Decks_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "latest_decks" */
export type Latest_Decks_Aggregate_Order_By = {
  avg?: InputMaybe<Latest_Decks_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Latest_Decks_Max_Order_By>;
  min?: InputMaybe<Latest_Decks_Min_Order_By>;
  stddev?: InputMaybe<Latest_Decks_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Latest_Decks_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Latest_Decks_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Latest_Decks_Sum_Order_By>;
  var_pop?: InputMaybe<Latest_Decks_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Latest_Decks_Var_Samp_Order_By>;
  variance?: InputMaybe<Latest_Decks_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "latest_decks" */
export type Latest_Decks_Arr_Rel_Insert_Input = {
  data: Array<Latest_Decks_Insert_Input>;
};

/** aggregate avg on columns */
export type Latest_Decks_Avg_Fields = {
  __typename?: 'latest_decks_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "latest_decks" */
export type Latest_Decks_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "latest_decks". All fields are combined with a logical 'AND'. */
export type Latest_Decks_Bool_Exp = {
  _and?: InputMaybe<Array<Latest_Decks_Bool_Exp>>;
  _not?: InputMaybe<Latest_Decks_Bool_Exp>;
  _or?: InputMaybe<Array<Latest_Decks_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  deck?: InputMaybe<Campaign_Deck_Bool_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  owner_id?: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "latest_decks" */
export type Latest_Decks_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "latest_decks" */
export type Latest_Decks_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck?: InputMaybe<Campaign_Deck_Obj_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Latest_Decks_Max_Fields = {
  __typename?: 'latest_decks_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "latest_decks" */
export type Latest_Decks_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Latest_Decks_Min_Fields = {
  __typename?: 'latest_decks_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "latest_decks" */
export type Latest_Decks_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "latest_decks" */
export type Latest_Decks_Mutation_Response = {
  __typename?: 'latest_decks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Latest_Decks>;
};

/** Ordering options when selecting data from "latest_decks". */
export type Latest_Decks_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  deck?: InputMaybe<Campaign_Deck_Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** select columns of table "latest_decks" */
export enum Latest_Decks_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Id = 'id',
  /** column name */
  OwnerId = 'owner_id'
}

/** input type for updating data in table "latest_decks" */
export type Latest_Decks_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Latest_Decks_Stddev_Fields = {
  __typename?: 'latest_decks_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "latest_decks" */
export type Latest_Decks_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Latest_Decks_Stddev_Pop_Fields = {
  __typename?: 'latest_decks_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "latest_decks" */
export type Latest_Decks_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Latest_Decks_Stddev_Samp_Fields = {
  __typename?: 'latest_decks_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "latest_decks" */
export type Latest_Decks_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "latest_decks" */
export type Latest_Decks_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Latest_Decks_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Latest_Decks_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Latest_Decks_Sum_Fields = {
  __typename?: 'latest_decks_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "latest_decks" */
export type Latest_Decks_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

export type Latest_Decks_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Latest_Decks_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Latest_Decks_Set_Input>;
  /** filter the rows which have to be updated */
  where: Latest_Decks_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Latest_Decks_Var_Pop_Fields = {
  __typename?: 'latest_decks_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "latest_decks" */
export type Latest_Decks_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Latest_Decks_Var_Samp_Fields = {
  __typename?: 'latest_decks_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "latest_decks" */
export type Latest_Decks_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Latest_Decks_Variance_Fields = {
  __typename?: 'latest_decks_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "latest_decks" */
export type Latest_Decks_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** columns and relationships of "local_decks" */
export type Local_Decks = {
  __typename?: 'local_decks';
  /** An object relationship */
  campaign?: Maybe<Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  deck?: Maybe<Campaign_Deck>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "local_decks" */
export type Local_Decks_Aggregate = {
  __typename?: 'local_decks_aggregate';
  aggregate?: Maybe<Local_Decks_Aggregate_Fields>;
  nodes: Array<Local_Decks>;
};

export type Local_Decks_Aggregate_Bool_Exp = {
  count?: InputMaybe<Local_Decks_Aggregate_Bool_Exp_Count>;
};

export type Local_Decks_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Local_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Local_Decks_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "local_decks" */
export type Local_Decks_Aggregate_Fields = {
  __typename?: 'local_decks_aggregate_fields';
  avg?: Maybe<Local_Decks_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Local_Decks_Max_Fields>;
  min?: Maybe<Local_Decks_Min_Fields>;
  stddev?: Maybe<Local_Decks_Stddev_Fields>;
  stddev_pop?: Maybe<Local_Decks_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Local_Decks_Stddev_Samp_Fields>;
  sum?: Maybe<Local_Decks_Sum_Fields>;
  var_pop?: Maybe<Local_Decks_Var_Pop_Fields>;
  var_samp?: Maybe<Local_Decks_Var_Samp_Fields>;
  variance?: Maybe<Local_Decks_Variance_Fields>;
};


/** aggregate fields of "local_decks" */
export type Local_Decks_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Local_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "local_decks" */
export type Local_Decks_Aggregate_Order_By = {
  avg?: InputMaybe<Local_Decks_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Local_Decks_Max_Order_By>;
  min?: InputMaybe<Local_Decks_Min_Order_By>;
  stddev?: InputMaybe<Local_Decks_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Local_Decks_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Local_Decks_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Local_Decks_Sum_Order_By>;
  var_pop?: InputMaybe<Local_Decks_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Local_Decks_Var_Samp_Order_By>;
  variance?: InputMaybe<Local_Decks_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "local_decks" */
export type Local_Decks_Arr_Rel_Insert_Input = {
  data: Array<Local_Decks_Insert_Input>;
};

/** aggregate avg on columns */
export type Local_Decks_Avg_Fields = {
  __typename?: 'local_decks_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "local_decks" */
export type Local_Decks_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "local_decks". All fields are combined with a logical 'AND'. */
export type Local_Decks_Bool_Exp = {
  _and?: InputMaybe<Array<Local_Decks_Bool_Exp>>;
  _not?: InputMaybe<Local_Decks_Bool_Exp>;
  _or?: InputMaybe<Array<Local_Decks_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  deck?: InputMaybe<Campaign_Deck_Bool_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  owner_id?: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "local_decks" */
export type Local_Decks_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "local_decks" */
export type Local_Decks_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck?: InputMaybe<Campaign_Deck_Obj_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Local_Decks_Max_Fields = {
  __typename?: 'local_decks_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "local_decks" */
export type Local_Decks_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Local_Decks_Min_Fields = {
  __typename?: 'local_decks_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "local_decks" */
export type Local_Decks_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "local_decks" */
export type Local_Decks_Mutation_Response = {
  __typename?: 'local_decks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Local_Decks>;
};

/** Ordering options when selecting data from "local_decks". */
export type Local_Decks_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  deck?: InputMaybe<Campaign_Deck_Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** select columns of table "local_decks" */
export enum Local_Decks_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Id = 'id',
  /** column name */
  OwnerId = 'owner_id'
}

/** input type for updating data in table "local_decks" */
export type Local_Decks_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Local_Decks_Stddev_Fields = {
  __typename?: 'local_decks_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "local_decks" */
export type Local_Decks_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Local_Decks_Stddev_Pop_Fields = {
  __typename?: 'local_decks_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "local_decks" */
export type Local_Decks_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Local_Decks_Stddev_Samp_Fields = {
  __typename?: 'local_decks_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "local_decks" */
export type Local_Decks_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "local_decks" */
export type Local_Decks_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Local_Decks_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Local_Decks_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Local_Decks_Sum_Fields = {
  __typename?: 'local_decks_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "local_decks" */
export type Local_Decks_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

export type Local_Decks_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Local_Decks_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Local_Decks_Set_Input>;
  /** filter the rows which have to be updated */
  where: Local_Decks_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Local_Decks_Var_Pop_Fields = {
  __typename?: 'local_decks_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "local_decks" */
export type Local_Decks_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Local_Decks_Var_Samp_Fields = {
  __typename?: 'local_decks_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "local_decks" */
export type Local_Decks_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Local_Decks_Variance_Fields = {
  __typename?: 'local_decks_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "local_decks" */
export type Local_Decks_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  apiDeleteArkhamDbDeck?: Maybe<DeleteDeckOutput>;
  /** execute VOLATILE function "conquest.publish_deck" which returns "conquest.deck" */
  conquest_publish_deck?: Maybe<Conquest_Deck>;
  createArkhamDbDeck?: Maybe<CreateDeckOutput>;
  createCampaign?: Maybe<CreateCampaignOutput>;
  deleteCampaign?: Maybe<DeleteCampaignOutput>;
  /** delete data from the table: "all_card" */
  delete_all_card?: Maybe<All_Card_Mutation_Response>;
  /** delete single row from the table: "all_card" */
  delete_all_card_by_pk?: Maybe<All_Card>;
  /** delete data from the table: "all_card_text" */
  delete_all_card_text?: Maybe<All_Card_Text_Mutation_Response>;
  /** delete single row from the table: "all_card_text" */
  delete_all_card_text_by_pk?: Maybe<All_Card_Text>;
  /** delete data from the table: "all_card_updated" */
  delete_all_card_updated?: Maybe<All_Card_Updated_Mutation_Response>;
  /** delete single row from the table: "all_card_updated" */
  delete_all_card_updated_by_pk?: Maybe<All_Card_Updated>;
  /** delete data from the table: "all_card_updated_by_version" */
  delete_all_card_updated_by_version?: Maybe<All_Card_Updated_By_Version_Mutation_Response>;
  /** delete single row from the table: "all_card_updated_by_version" */
  delete_all_card_updated_by_version_by_pk?: Maybe<All_Card_Updated_By_Version>;
  /** delete data from the table: "arkhamdb_auth" */
  delete_arkhamdb_auth?: Maybe<Arkhamdb_Auth_Mutation_Response>;
  /** delete single row from the table: "arkhamdb_auth" */
  delete_arkhamdb_auth_by_pk?: Maybe<Arkhamdb_Auth>;
  /** delete data from the table: "arkhamdb_deck" */
  delete_arkhamdb_deck?: Maybe<Arkhamdb_Deck_Mutation_Response>;
  /** delete single row from the table: "arkhamdb_deck" */
  delete_arkhamdb_deck_by_pk?: Maybe<Arkhamdb_Deck>;
  /** delete data from the table: "base_decks" */
  delete_base_decks?: Maybe<Base_Decks_Mutation_Response>;
  /** delete data from the table: "campaign" */
  delete_campaign?: Maybe<Campaign_Mutation_Response>;
  /** delete data from the table: "campaign_access" */
  delete_campaign_access?: Maybe<Campaign_Access_Mutation_Response>;
  /** delete single row from the table: "campaign_access" */
  delete_campaign_access_by_pk?: Maybe<Campaign_Access>;
  /** delete single row from the table: "campaign" */
  delete_campaign_by_pk?: Maybe<Campaign>;
  /** delete data from the table: "campaign_deck" */
  delete_campaign_deck?: Maybe<Campaign_Deck_Mutation_Response>;
  /** delete single row from the table: "campaign_deck" */
  delete_campaign_deck_by_pk?: Maybe<Campaign_Deck>;
  /** delete data from the table: "campaign_difficulty" */
  delete_campaign_difficulty?: Maybe<Campaign_Difficulty_Mutation_Response>;
  /** delete single row from the table: "campaign_difficulty" */
  delete_campaign_difficulty_by_pk?: Maybe<Campaign_Difficulty>;
  /** delete data from the table: "campaign_guide" */
  delete_campaign_guide?: Maybe<Campaign_Guide_Mutation_Response>;
  /** delete data from the table: "campaign_investigator" */
  delete_campaign_investigator?: Maybe<Campaign_Investigator_Mutation_Response>;
  /** delete single row from the table: "campaign_investigator" */
  delete_campaign_investigator_by_pk?: Maybe<Campaign_Investigator>;
  /** delete data from the table: "card" */
  delete_card?: Maybe<Card_Mutation_Response>;
  /** delete single row from the table: "card" */
  delete_card_by_pk?: Maybe<Card>;
  /** delete data from the table: "card_cycle" */
  delete_card_cycle?: Maybe<Card_Cycle_Mutation_Response>;
  /** delete single row from the table: "card_cycle" */
  delete_card_cycle_by_pk?: Maybe<Card_Cycle>;
  /** delete data from the table: "card_encounter_set" */
  delete_card_encounter_set?: Maybe<Card_Encounter_Set_Mutation_Response>;
  /** delete single row from the table: "card_encounter_set" */
  delete_card_encounter_set_by_pk?: Maybe<Card_Encounter_Set>;
  /** delete data from the table: "card_pack" */
  delete_card_pack?: Maybe<Card_Pack_Mutation_Response>;
  /** delete single row from the table: "card_pack" */
  delete_card_pack_by_pk?: Maybe<Card_Pack>;
  /** delete data from the table: "card_subtype_name" */
  delete_card_subtype_name?: Maybe<Card_Subtype_Name_Mutation_Response>;
  /** delete single row from the table: "card_subtype_name" */
  delete_card_subtype_name_by_pk?: Maybe<Card_Subtype_Name>;
  /** delete data from the table: "card_text" */
  delete_card_text?: Maybe<Card_Text_Mutation_Response>;
  /** delete single row from the table: "card_text" */
  delete_card_text_by_pk?: Maybe<Card_Text>;
  /** delete data from the table: "card_type_code" */
  delete_card_type_code?: Maybe<Card_Type_Code_Mutation_Response>;
  /** delete single row from the table: "card_type_code" */
  delete_card_type_code_by_pk?: Maybe<Card_Type_Code>;
  /** delete data from the table: "card_type_name" */
  delete_card_type_name?: Maybe<Card_Type_Name_Mutation_Response>;
  /** delete single row from the table: "card_type_name" */
  delete_card_type_name_by_pk?: Maybe<Card_Type_Name>;
  /** delete data from the table: "chaos_bag_result" */
  delete_chaos_bag_result?: Maybe<Chaos_Bag_Result_Mutation_Response>;
  /** delete single row from the table: "chaos_bag_result" */
  delete_chaos_bag_result_by_pk?: Maybe<Chaos_Bag_Result>;
  /** delete data from the table: "chaos_bag_tarot_mode" */
  delete_chaos_bag_tarot_mode?: Maybe<Chaos_Bag_Tarot_Mode_Mutation_Response>;
  /** delete single row from the table: "chaos_bag_tarot_mode" */
  delete_chaos_bag_tarot_mode_by_pk?: Maybe<Chaos_Bag_Tarot_Mode>;
  /** delete data from the table: "conquest.card" */
  delete_conquest_card?: Maybe<Conquest_Card_Mutation_Response>;
  /** delete single row from the table: "conquest.card" */
  delete_conquest_card_by_pk?: Maybe<Conquest_Card>;
  /** delete data from the table: "conquest.card_text" */
  delete_conquest_card_text?: Maybe<Conquest_Card_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.card_text" */
  delete_conquest_card_text_by_pk?: Maybe<Conquest_Card_Text>;
  /** delete data from the table: "conquest.comment" */
  delete_conquest_comment?: Maybe<Conquest_Comment_Mutation_Response>;
  /** delete single row from the table: "conquest.comment" */
  delete_conquest_comment_by_pk?: Maybe<Conquest_Comment>;
  /** delete data from the table: "conquest.cycle" */
  delete_conquest_cycle?: Maybe<Conquest_Cycle_Mutation_Response>;
  /** delete single row from the table: "conquest.cycle" */
  delete_conquest_cycle_by_pk?: Maybe<Conquest_Cycle>;
  /** delete data from the table: "conquest.cycle_text" */
  delete_conquest_cycle_text?: Maybe<Conquest_Cycle_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.cycle_text" */
  delete_conquest_cycle_text_by_pk?: Maybe<Conquest_Cycle_Text>;
  /** delete data from the table: "conquest.deck" */
  delete_conquest_deck?: Maybe<Conquest_Deck_Mutation_Response>;
  /** delete single row from the table: "conquest.deck" */
  delete_conquest_deck_by_pk?: Maybe<Conquest_Deck>;
  /** delete data from the table: "conquest.deck_copy" */
  delete_conquest_deck_copy?: Maybe<Conquest_Deck_Copy_Mutation_Response>;
  /** delete single row from the table: "conquest.deck_copy" */
  delete_conquest_deck_copy_by_pk?: Maybe<Conquest_Deck_Copy>;
  /** delete data from the table: "conquest.deck_like" */
  delete_conquest_deck_like?: Maybe<Conquest_Deck_Like_Mutation_Response>;
  /** delete single row from the table: "conquest.deck_like" */
  delete_conquest_deck_like_by_pk?: Maybe<Conquest_Deck_Like>;
  /** delete data from the table: "conquest.faction" */
  delete_conquest_faction?: Maybe<Conquest_Faction_Mutation_Response>;
  /** delete single row from the table: "conquest.faction" */
  delete_conquest_faction_by_pk?: Maybe<Conquest_Faction>;
  /** delete data from the table: "conquest.faction_text" */
  delete_conquest_faction_text?: Maybe<Conquest_Faction_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.faction_text" */
  delete_conquest_faction_text_by_pk?: Maybe<Conquest_Faction_Text>;
  /** delete data from the table: "conquest.loyalty" */
  delete_conquest_loyalty?: Maybe<Conquest_Loyalty_Mutation_Response>;
  /** delete single row from the table: "conquest.loyalty" */
  delete_conquest_loyalty_by_pk?: Maybe<Conquest_Loyalty>;
  /** delete data from the table: "conquest.loyalty_text" */
  delete_conquest_loyalty_text?: Maybe<Conquest_Loyalty_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.loyalty_text" */
  delete_conquest_loyalty_text_by_pk?: Maybe<Conquest_Loyalty_Text>;
  /** delete data from the table: "conquest.pack" */
  delete_conquest_pack?: Maybe<Conquest_Pack_Mutation_Response>;
  /** delete single row from the table: "conquest.pack" */
  delete_conquest_pack_by_pk?: Maybe<Conquest_Pack>;
  /** delete data from the table: "conquest.pack_text" */
  delete_conquest_pack_text?: Maybe<Conquest_Pack_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.pack_text" */
  delete_conquest_pack_text_by_pk?: Maybe<Conquest_Pack_Text>;
  /** delete data from the table: "conquest.type" */
  delete_conquest_type?: Maybe<Conquest_Type_Mutation_Response>;
  /** delete single row from the table: "conquest.type" */
  delete_conquest_type_by_pk?: Maybe<Conquest_Type>;
  /** delete data from the table: "conquest.type_text" */
  delete_conquest_type_text?: Maybe<Conquest_Type_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.type_text" */
  delete_conquest_type_text_by_pk?: Maybe<Conquest_Type_Text>;
  /** delete data from the table: "conquest.user_role" */
  delete_conquest_user_role?: Maybe<Conquest_User_Role_Mutation_Response>;
  /** delete single row from the table: "conquest.user_role" */
  delete_conquest_user_role_by_pk?: Maybe<Conquest_User_Role>;
  /** delete data from the table: "conquest.user_settings" */
  delete_conquest_user_settings?: Maybe<Conquest_User_Settings_Mutation_Response>;
  /** delete single row from the table: "conquest.user_settings" */
  delete_conquest_user_settings_by_pk?: Maybe<Conquest_User_Settings>;
  /** delete data from the table: "conquest.users" */
  delete_conquest_users?: Maybe<Conquest_Users_Mutation_Response>;
  /** delete single row from the table: "conquest.users" */
  delete_conquest_users_by_pk?: Maybe<Conquest_Users>;
  /** delete data from the table: "cycle" */
  delete_cycle?: Maybe<Cycle_Mutation_Response>;
  /** delete single row from the table: "cycle" */
  delete_cycle_by_pk?: Maybe<Cycle>;
  /** delete data from the table: "cycle_name" */
  delete_cycle_name?: Maybe<Cycle_Name_Mutation_Response>;
  /** delete single row from the table: "cycle_name" */
  delete_cycle_name_by_pk?: Maybe<Cycle_Name>;
  /** delete data from the table: "faction_name" */
  delete_faction_name?: Maybe<Faction_Name_Mutation_Response>;
  /** delete single row from the table: "faction_name" */
  delete_faction_name_by_pk?: Maybe<Faction_Name>;
  /** delete data from the table: "faq" */
  delete_faq?: Maybe<Faq_Mutation_Response>;
  /** delete single row from the table: "faq" */
  delete_faq_by_pk?: Maybe<Faq>;
  /** delete data from the table: "faq_text" */
  delete_faq_text?: Maybe<Faq_Text_Mutation_Response>;
  /** delete single row from the table: "faq_text" */
  delete_faq_text_by_pk?: Maybe<Faq_Text>;
  /** delete data from the table: "friend_status" */
  delete_friend_status?: Maybe<Friend_Status_Mutation_Response>;
  /** delete single row from the table: "friend_status" */
  delete_friend_status_by_pk?: Maybe<Friend_Status>;
  /** delete data from the table: "friend_status_type" */
  delete_friend_status_type?: Maybe<Friend_Status_Type_Mutation_Response>;
  /** delete single row from the table: "friend_status_type" */
  delete_friend_status_type_by_pk?: Maybe<Friend_Status_Type>;
  /** delete data from the table: "full_card" */
  delete_full_card?: Maybe<Full_Card_Mutation_Response>;
  /** delete single row from the table: "full_card" */
  delete_full_card_by_pk?: Maybe<Full_Card>;
  /** delete data from the table: "full_card_text" */
  delete_full_card_text?: Maybe<Full_Card_Text_Mutation_Response>;
  /** delete single row from the table: "full_card_text" */
  delete_full_card_text_by_pk?: Maybe<Full_Card_Text>;
  /** delete data from the table: "gender" */
  delete_gender?: Maybe<Gender_Mutation_Response>;
  /** delete single row from the table: "gender" */
  delete_gender_by_pk?: Maybe<Gender>;
  /** delete data from the table: "guide_achievement" */
  delete_guide_achievement?: Maybe<Guide_Achievement_Mutation_Response>;
  /** delete single row from the table: "guide_achievement" */
  delete_guide_achievement_by_pk?: Maybe<Guide_Achievement>;
  /** delete data from the table: "guide_input" */
  delete_guide_input?: Maybe<Guide_Input_Mutation_Response>;
  /** delete single row from the table: "guide_input" */
  delete_guide_input_by_pk?: Maybe<Guide_Input>;
  /** delete data from the table: "investigator_data" */
  delete_investigator_data?: Maybe<Investigator_Data_Mutation_Response>;
  /** delete single row from the table: "investigator_data" */
  delete_investigator_data_by_pk?: Maybe<Investigator_Data>;
  /** delete data from the table: "latest_decks" */
  delete_latest_decks?: Maybe<Latest_Decks_Mutation_Response>;
  /** delete data from the table: "local_decks" */
  delete_local_decks?: Maybe<Local_Decks_Mutation_Response>;
  /** delete data from the table: "pack" */
  delete_pack?: Maybe<Pack_Mutation_Response>;
  /** delete single row from the table: "pack" */
  delete_pack_by_pk?: Maybe<Pack>;
  /** delete data from the table: "pack_name" */
  delete_pack_name?: Maybe<Pack_Name_Mutation_Response>;
  /** delete single row from the table: "pack_name" */
  delete_pack_name_by_pk?: Maybe<Pack_Name>;
  /** delete data from the table: "rangers.area" */
  delete_rangers_area?: Maybe<Rangers_Area_Mutation_Response>;
  /** delete single row from the table: "rangers.area" */
  delete_rangers_area_by_pk?: Maybe<Rangers_Area>;
  /** delete data from the table: "rangers.area_text" */
  delete_rangers_area_text?: Maybe<Rangers_Area_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.area_text" */
  delete_rangers_area_text_by_pk?: Maybe<Rangers_Area_Text>;
  /** delete data from the table: "rangers.aspect" */
  delete_rangers_aspect?: Maybe<Rangers_Aspect_Mutation_Response>;
  /** delete single row from the table: "rangers.aspect" */
  delete_rangers_aspect_by_pk?: Maybe<Rangers_Aspect>;
  /** delete data from the table: "rangers.aspect_text" */
  delete_rangers_aspect_text?: Maybe<Rangers_Aspect_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.aspect_text" */
  delete_rangers_aspect_text_by_pk?: Maybe<Rangers_Aspect_Text>;
  /** delete data from the table: "rangers.campaign" */
  delete_rangers_campaign?: Maybe<Rangers_Campaign_Mutation_Response>;
  /** delete data from the table: "rangers.campaign_access" */
  delete_rangers_campaign_access?: Maybe<Rangers_Campaign_Access_Mutation_Response>;
  /** delete single row from the table: "rangers.campaign_access" */
  delete_rangers_campaign_access_by_pk?: Maybe<Rangers_Campaign_Access>;
  /** delete single row from the table: "rangers.campaign" */
  delete_rangers_campaign_by_pk?: Maybe<Rangers_Campaign>;
  /** delete data from the table: "rangers.card" */
  delete_rangers_card?: Maybe<Rangers_Card_Mutation_Response>;
  /** delete single row from the table: "rangers.card" */
  delete_rangers_card_by_pk?: Maybe<Rangers_Card>;
  /** delete data from the table: "rangers.card_text" */
  delete_rangers_card_text?: Maybe<Rangers_Card_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.card_text" */
  delete_rangers_card_text_by_pk?: Maybe<Rangers_Card_Text>;
  /** delete data from the table: "rangers.comment" */
  delete_rangers_comment?: Maybe<Rangers_Comment_Mutation_Response>;
  /** delete single row from the table: "rangers.comment" */
  delete_rangers_comment_by_pk?: Maybe<Rangers_Comment>;
  /** delete data from the table: "rangers.deck" */
  delete_rangers_deck?: Maybe<Rangers_Deck_Mutation_Response>;
  /** delete single row from the table: "rangers.deck" */
  delete_rangers_deck_by_pk?: Maybe<Rangers_Deck>;
  /** delete data from the table: "rangers.deck_copy" */
  delete_rangers_deck_copy?: Maybe<Rangers_Deck_Copy_Mutation_Response>;
  /** delete single row from the table: "rangers.deck_copy" */
  delete_rangers_deck_copy_by_pk?: Maybe<Rangers_Deck_Copy>;
  /** delete data from the table: "rangers.deck_like" */
  delete_rangers_deck_like?: Maybe<Rangers_Deck_Like_Mutation_Response>;
  /** delete single row from the table: "rangers.deck_like" */
  delete_rangers_deck_like_by_pk?: Maybe<Rangers_Deck_Like>;
  /** delete data from the table: "rangers.deck_like_count" */
  delete_rangers_deck_like_count?: Maybe<Rangers_Deck_Like_Count_Mutation_Response>;
  /** delete single row from the table: "rangers.deck_like_count" */
  delete_rangers_deck_like_count_by_pk?: Maybe<Rangers_Deck_Like_Count>;
  /** delete data from the table: "rangers.faq_entry" */
  delete_rangers_faq_entry?: Maybe<Rangers_Faq_Entry_Mutation_Response>;
  /** delete single row from the table: "rangers.faq_entry" */
  delete_rangers_faq_entry_by_pk?: Maybe<Rangers_Faq_Entry>;
  /** delete data from the table: "rangers.friend_status" */
  delete_rangers_friend_status?: Maybe<Rangers_Friend_Status_Mutation_Response>;
  /** delete single row from the table: "rangers.friend_status" */
  delete_rangers_friend_status_by_pk?: Maybe<Rangers_Friend_Status>;
  /** delete data from the table: "rangers.friend_status_type" */
  delete_rangers_friend_status_type?: Maybe<Rangers_Friend_Status_Type_Mutation_Response>;
  /** delete single row from the table: "rangers.friend_status_type" */
  delete_rangers_friend_status_type_by_pk?: Maybe<Rangers_Friend_Status_Type>;
  /** delete data from the table: "rangers.latest_deck" */
  delete_rangers_latest_deck?: Maybe<Rangers_Latest_Deck_Mutation_Response>;
  /** delete data from the table: "rangers.locale" */
  delete_rangers_locale?: Maybe<Rangers_Locale_Mutation_Response>;
  /** delete single row from the table: "rangers.locale" */
  delete_rangers_locale_by_pk?: Maybe<Rangers_Locale>;
  /** delete data from the table: "rangers.pack" */
  delete_rangers_pack?: Maybe<Rangers_Pack_Mutation_Response>;
  /** delete single row from the table: "rangers.pack" */
  delete_rangers_pack_by_pk?: Maybe<Rangers_Pack>;
  /** delete data from the table: "rangers.pack_text" */
  delete_rangers_pack_text?: Maybe<Rangers_Pack_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.pack_text" */
  delete_rangers_pack_text_by_pk?: Maybe<Rangers_Pack_Text>;
  /** delete data from the table: "rangers.search_deck" */
  delete_rangers_search_deck?: Maybe<Rangers_Search_Deck_Mutation_Response>;
  /** delete data from the table: "rangers.set" */
  delete_rangers_set?: Maybe<Rangers_Set_Mutation_Response>;
  /** delete single row from the table: "rangers.set" */
  delete_rangers_set_by_pk?: Maybe<Rangers_Set>;
  /** delete data from the table: "rangers.set_text" */
  delete_rangers_set_text?: Maybe<Rangers_Set_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.set_text" */
  delete_rangers_set_text_by_pk?: Maybe<Rangers_Set_Text>;
  /** delete data from the table: "rangers.set_type" */
  delete_rangers_set_type?: Maybe<Rangers_Set_Type_Mutation_Response>;
  /** delete single row from the table: "rangers.set_type" */
  delete_rangers_set_type_by_pk?: Maybe<Rangers_Set_Type>;
  /** delete data from the table: "rangers.set_type_text" */
  delete_rangers_set_type_text?: Maybe<Rangers_Set_Type_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.set_type_text" */
  delete_rangers_set_type_text_by_pk?: Maybe<Rangers_Set_Type_Text>;
  /** delete data from the table: "rangers.subset" */
  delete_rangers_subset?: Maybe<Rangers_Subset_Mutation_Response>;
  /** delete single row from the table: "rangers.subset" */
  delete_rangers_subset_by_pk?: Maybe<Rangers_Subset>;
  /** delete data from the table: "rangers.subset_text" */
  delete_rangers_subset_text?: Maybe<Rangers_Subset_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.subset_text" */
  delete_rangers_subset_text_by_pk?: Maybe<Rangers_Subset_Text>;
  /** delete data from the table: "rangers.taboo_set" */
  delete_rangers_taboo_set?: Maybe<Rangers_Taboo_Set_Mutation_Response>;
  /** delete single row from the table: "rangers.taboo_set" */
  delete_rangers_taboo_set_by_pk?: Maybe<Rangers_Taboo_Set>;
  /** delete data from the table: "rangers.taboo_set_text" */
  delete_rangers_taboo_set_text?: Maybe<Rangers_Taboo_Set_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.taboo_set_text" */
  delete_rangers_taboo_set_text_by_pk?: Maybe<Rangers_Taboo_Set_Text>;
  /** delete data from the table: "rangers.token" */
  delete_rangers_token?: Maybe<Rangers_Token_Mutation_Response>;
  /** delete single row from the table: "rangers.token" */
  delete_rangers_token_by_pk?: Maybe<Rangers_Token>;
  /** delete data from the table: "rangers.token_text" */
  delete_rangers_token_text?: Maybe<Rangers_Token_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.token_text" */
  delete_rangers_token_text_by_pk?: Maybe<Rangers_Token_Text>;
  /** delete data from the table: "rangers.type" */
  delete_rangers_type?: Maybe<Rangers_Type_Mutation_Response>;
  /** delete single row from the table: "rangers.type" */
  delete_rangers_type_by_pk?: Maybe<Rangers_Type>;
  /** delete data from the table: "rangers.type_text" */
  delete_rangers_type_text?: Maybe<Rangers_Type_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.type_text" */
  delete_rangers_type_text_by_pk?: Maybe<Rangers_Type_Text>;
  /** delete data from the table: "rangers.user_friends" */
  delete_rangers_user_friends?: Maybe<Rangers_User_Friends_Mutation_Response>;
  /** delete data from the table: "rangers.user_received_friend_requests" */
  delete_rangers_user_received_friend_requests?: Maybe<Rangers_User_Received_Friend_Requests_Mutation_Response>;
  /** delete data from the table: "rangers.user_role" */
  delete_rangers_user_role?: Maybe<Rangers_User_Role_Mutation_Response>;
  /** delete single row from the table: "rangers.user_role" */
  delete_rangers_user_role_by_pk?: Maybe<Rangers_User_Role>;
  /** delete data from the table: "rangers.user_sent_friend_requests" */
  delete_rangers_user_sent_friend_requests?: Maybe<Rangers_User_Sent_Friend_Requests_Mutation_Response>;
  /** delete data from the table: "rangers.user_settings" */
  delete_rangers_user_settings?: Maybe<Rangers_User_Settings_Mutation_Response>;
  /** delete single row from the table: "rangers.user_settings" */
  delete_rangers_user_settings_by_pk?: Maybe<Rangers_User_Settings>;
  /** delete data from the table: "rangers.users" */
  delete_rangers_users?: Maybe<Rangers_Users_Mutation_Response>;
  /** delete single row from the table: "rangers.users" */
  delete_rangers_users_by_pk?: Maybe<Rangers_Users>;
  /** delete data from the table: "taboo_set" */
  delete_taboo_set?: Maybe<Taboo_Set_Mutation_Response>;
  /** delete single row from the table: "taboo_set" */
  delete_taboo_set_by_pk?: Maybe<Taboo_Set>;
  /** delete data from the table: "user_campaigns" */
  delete_user_campaigns?: Maybe<User_Campaigns_Mutation_Response>;
  /** delete data from the table: "user_flag" */
  delete_user_flag?: Maybe<User_Flag_Mutation_Response>;
  /** delete single row from the table: "user_flag" */
  delete_user_flag_by_pk?: Maybe<User_Flag>;
  /** delete data from the table: "user_flag_type" */
  delete_user_flag_type?: Maybe<User_Flag_Type_Mutation_Response>;
  /** delete single row from the table: "user_flag_type" */
  delete_user_flag_type_by_pk?: Maybe<User_Flag_Type>;
  /** delete data from the table: "user_friends" */
  delete_user_friends?: Maybe<User_Friends_Mutation_Response>;
  /** delete data from the table: "user_received_friend_requests" */
  delete_user_received_friend_requests?: Maybe<User_Received_Friend_Requests_Mutation_Response>;
  /** delete data from the table: "user_sent_friend_requests" */
  delete_user_sent_friend_requests?: Maybe<User_Sent_Friend_Requests_Mutation_Response>;
  /** delete data from the table: "user_settings" */
  delete_user_settings?: Maybe<User_Settings_Mutation_Response>;
  /** delete single row from the table: "user_settings" */
  delete_user_settings_by_pk?: Maybe<User_Settings>;
  /** delete data from the table: "users" */
  delete_users?: Maybe<Users_Mutation_Response>;
  /** delete single row from the table: "users" */
  delete_users_by_pk?: Maybe<Users>;
  editCampaignAccess?: Maybe<EditCampaignAccessOutput>;
  /** insert data into the table: "all_card" */
  insert_all_card?: Maybe<All_Card_Mutation_Response>;
  /** insert a single row into the table: "all_card" */
  insert_all_card_one?: Maybe<All_Card>;
  /** insert data into the table: "all_card_text" */
  insert_all_card_text?: Maybe<All_Card_Text_Mutation_Response>;
  /** insert a single row into the table: "all_card_text" */
  insert_all_card_text_one?: Maybe<All_Card_Text>;
  /** insert data into the table: "all_card_updated" */
  insert_all_card_updated?: Maybe<All_Card_Updated_Mutation_Response>;
  /** insert data into the table: "all_card_updated_by_version" */
  insert_all_card_updated_by_version?: Maybe<All_Card_Updated_By_Version_Mutation_Response>;
  /** insert a single row into the table: "all_card_updated_by_version" */
  insert_all_card_updated_by_version_one?: Maybe<All_Card_Updated_By_Version>;
  /** insert a single row into the table: "all_card_updated" */
  insert_all_card_updated_one?: Maybe<All_Card_Updated>;
  /** insert data into the table: "arkhamdb_auth" */
  insert_arkhamdb_auth?: Maybe<Arkhamdb_Auth_Mutation_Response>;
  /** insert a single row into the table: "arkhamdb_auth" */
  insert_arkhamdb_auth_one?: Maybe<Arkhamdb_Auth>;
  /** insert data into the table: "arkhamdb_deck" */
  insert_arkhamdb_deck?: Maybe<Arkhamdb_Deck_Mutation_Response>;
  /** insert a single row into the table: "arkhamdb_deck" */
  insert_arkhamdb_deck_one?: Maybe<Arkhamdb_Deck>;
  /** insert data into the table: "base_decks" */
  insert_base_decks?: Maybe<Base_Decks_Mutation_Response>;
  /** insert a single row into the table: "base_decks" */
  insert_base_decks_one?: Maybe<Base_Decks>;
  /** insert data into the table: "campaign" */
  insert_campaign?: Maybe<Campaign_Mutation_Response>;
  /** insert data into the table: "campaign_access" */
  insert_campaign_access?: Maybe<Campaign_Access_Mutation_Response>;
  /** insert a single row into the table: "campaign_access" */
  insert_campaign_access_one?: Maybe<Campaign_Access>;
  /** insert data into the table: "campaign_deck" */
  insert_campaign_deck?: Maybe<Campaign_Deck_Mutation_Response>;
  /** insert a single row into the table: "campaign_deck" */
  insert_campaign_deck_one?: Maybe<Campaign_Deck>;
  /** insert data into the table: "campaign_difficulty" */
  insert_campaign_difficulty?: Maybe<Campaign_Difficulty_Mutation_Response>;
  /** insert a single row into the table: "campaign_difficulty" */
  insert_campaign_difficulty_one?: Maybe<Campaign_Difficulty>;
  /** insert data into the table: "campaign_guide" */
  insert_campaign_guide?: Maybe<Campaign_Guide_Mutation_Response>;
  /** insert a single row into the table: "campaign_guide" */
  insert_campaign_guide_one?: Maybe<Campaign_Guide>;
  /** insert data into the table: "campaign_investigator" */
  insert_campaign_investigator?: Maybe<Campaign_Investigator_Mutation_Response>;
  /** insert a single row into the table: "campaign_investigator" */
  insert_campaign_investigator_one?: Maybe<Campaign_Investigator>;
  /** insert a single row into the table: "campaign" */
  insert_campaign_one?: Maybe<Campaign>;
  /** insert data into the table: "card" */
  insert_card?: Maybe<Card_Mutation_Response>;
  /** insert data into the table: "card_cycle" */
  insert_card_cycle?: Maybe<Card_Cycle_Mutation_Response>;
  /** insert a single row into the table: "card_cycle" */
  insert_card_cycle_one?: Maybe<Card_Cycle>;
  /** insert data into the table: "card_encounter_set" */
  insert_card_encounter_set?: Maybe<Card_Encounter_Set_Mutation_Response>;
  /** insert a single row into the table: "card_encounter_set" */
  insert_card_encounter_set_one?: Maybe<Card_Encounter_Set>;
  /** insert a single row into the table: "card" */
  insert_card_one?: Maybe<Card>;
  /** insert data into the table: "card_pack" */
  insert_card_pack?: Maybe<Card_Pack_Mutation_Response>;
  /** insert a single row into the table: "card_pack" */
  insert_card_pack_one?: Maybe<Card_Pack>;
  /** insert data into the table: "card_subtype_name" */
  insert_card_subtype_name?: Maybe<Card_Subtype_Name_Mutation_Response>;
  /** insert a single row into the table: "card_subtype_name" */
  insert_card_subtype_name_one?: Maybe<Card_Subtype_Name>;
  /** insert data into the table: "card_text" */
  insert_card_text?: Maybe<Card_Text_Mutation_Response>;
  /** insert a single row into the table: "card_text" */
  insert_card_text_one?: Maybe<Card_Text>;
  /** insert data into the table: "card_type_code" */
  insert_card_type_code?: Maybe<Card_Type_Code_Mutation_Response>;
  /** insert a single row into the table: "card_type_code" */
  insert_card_type_code_one?: Maybe<Card_Type_Code>;
  /** insert data into the table: "card_type_name" */
  insert_card_type_name?: Maybe<Card_Type_Name_Mutation_Response>;
  /** insert a single row into the table: "card_type_name" */
  insert_card_type_name_one?: Maybe<Card_Type_Name>;
  /** insert data into the table: "chaos_bag_result" */
  insert_chaos_bag_result?: Maybe<Chaos_Bag_Result_Mutation_Response>;
  /** insert a single row into the table: "chaos_bag_result" */
  insert_chaos_bag_result_one?: Maybe<Chaos_Bag_Result>;
  /** insert data into the table: "chaos_bag_tarot_mode" */
  insert_chaos_bag_tarot_mode?: Maybe<Chaos_Bag_Tarot_Mode_Mutation_Response>;
  /** insert a single row into the table: "chaos_bag_tarot_mode" */
  insert_chaos_bag_tarot_mode_one?: Maybe<Chaos_Bag_Tarot_Mode>;
  /** insert data into the table: "conquest.card" */
  insert_conquest_card?: Maybe<Conquest_Card_Mutation_Response>;
  /** insert a single row into the table: "conquest.card" */
  insert_conquest_card_one?: Maybe<Conquest_Card>;
  /** insert data into the table: "conquest.card_text" */
  insert_conquest_card_text?: Maybe<Conquest_Card_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.card_text" */
  insert_conquest_card_text_one?: Maybe<Conquest_Card_Text>;
  /** insert data into the table: "conquest.comment" */
  insert_conquest_comment?: Maybe<Conquest_Comment_Mutation_Response>;
  /** insert a single row into the table: "conquest.comment" */
  insert_conquest_comment_one?: Maybe<Conquest_Comment>;
  /** insert data into the table: "conquest.cycle" */
  insert_conquest_cycle?: Maybe<Conquest_Cycle_Mutation_Response>;
  /** insert a single row into the table: "conquest.cycle" */
  insert_conquest_cycle_one?: Maybe<Conquest_Cycle>;
  /** insert data into the table: "conquest.cycle_text" */
  insert_conquest_cycle_text?: Maybe<Conquest_Cycle_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.cycle_text" */
  insert_conquest_cycle_text_one?: Maybe<Conquest_Cycle_Text>;
  /** insert data into the table: "conquest.deck" */
  insert_conquest_deck?: Maybe<Conquest_Deck_Mutation_Response>;
  /** insert data into the table: "conquest.deck_copy" */
  insert_conquest_deck_copy?: Maybe<Conquest_Deck_Copy_Mutation_Response>;
  /** insert a single row into the table: "conquest.deck_copy" */
  insert_conquest_deck_copy_one?: Maybe<Conquest_Deck_Copy>;
  /** insert data into the table: "conquest.deck_like" */
  insert_conquest_deck_like?: Maybe<Conquest_Deck_Like_Mutation_Response>;
  /** insert a single row into the table: "conquest.deck_like" */
  insert_conquest_deck_like_one?: Maybe<Conquest_Deck_Like>;
  /** insert a single row into the table: "conquest.deck" */
  insert_conquest_deck_one?: Maybe<Conquest_Deck>;
  /** insert data into the table: "conquest.faction" */
  insert_conquest_faction?: Maybe<Conquest_Faction_Mutation_Response>;
  /** insert a single row into the table: "conquest.faction" */
  insert_conquest_faction_one?: Maybe<Conquest_Faction>;
  /** insert data into the table: "conquest.faction_text" */
  insert_conquest_faction_text?: Maybe<Conquest_Faction_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.faction_text" */
  insert_conquest_faction_text_one?: Maybe<Conquest_Faction_Text>;
  /** insert data into the table: "conquest.loyalty" */
  insert_conquest_loyalty?: Maybe<Conquest_Loyalty_Mutation_Response>;
  /** insert a single row into the table: "conquest.loyalty" */
  insert_conquest_loyalty_one?: Maybe<Conquest_Loyalty>;
  /** insert data into the table: "conquest.loyalty_text" */
  insert_conquest_loyalty_text?: Maybe<Conquest_Loyalty_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.loyalty_text" */
  insert_conquest_loyalty_text_one?: Maybe<Conquest_Loyalty_Text>;
  /** insert data into the table: "conquest.pack" */
  insert_conquest_pack?: Maybe<Conquest_Pack_Mutation_Response>;
  /** insert a single row into the table: "conquest.pack" */
  insert_conquest_pack_one?: Maybe<Conquest_Pack>;
  /** insert data into the table: "conquest.pack_text" */
  insert_conquest_pack_text?: Maybe<Conquest_Pack_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.pack_text" */
  insert_conquest_pack_text_one?: Maybe<Conquest_Pack_Text>;
  /** insert data into the table: "conquest.type" */
  insert_conquest_type?: Maybe<Conquest_Type_Mutation_Response>;
  /** insert a single row into the table: "conquest.type" */
  insert_conquest_type_one?: Maybe<Conquest_Type>;
  /** insert data into the table: "conquest.type_text" */
  insert_conquest_type_text?: Maybe<Conquest_Type_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.type_text" */
  insert_conquest_type_text_one?: Maybe<Conquest_Type_Text>;
  /** insert data into the table: "conquest.user_role" */
  insert_conquest_user_role?: Maybe<Conquest_User_Role_Mutation_Response>;
  /** insert a single row into the table: "conquest.user_role" */
  insert_conquest_user_role_one?: Maybe<Conquest_User_Role>;
  /** insert data into the table: "conquest.user_settings" */
  insert_conquest_user_settings?: Maybe<Conquest_User_Settings_Mutation_Response>;
  /** insert a single row into the table: "conquest.user_settings" */
  insert_conquest_user_settings_one?: Maybe<Conquest_User_Settings>;
  /** insert data into the table: "conquest.users" */
  insert_conquest_users?: Maybe<Conquest_Users_Mutation_Response>;
  /** insert a single row into the table: "conquest.users" */
  insert_conquest_users_one?: Maybe<Conquest_Users>;
  /** insert data into the table: "cycle" */
  insert_cycle?: Maybe<Cycle_Mutation_Response>;
  /** insert data into the table: "cycle_name" */
  insert_cycle_name?: Maybe<Cycle_Name_Mutation_Response>;
  /** insert a single row into the table: "cycle_name" */
  insert_cycle_name_one?: Maybe<Cycle_Name>;
  /** insert a single row into the table: "cycle" */
  insert_cycle_one?: Maybe<Cycle>;
  /** insert data into the table: "faction_name" */
  insert_faction_name?: Maybe<Faction_Name_Mutation_Response>;
  /** insert a single row into the table: "faction_name" */
  insert_faction_name_one?: Maybe<Faction_Name>;
  /** insert data into the table: "faq" */
  insert_faq?: Maybe<Faq_Mutation_Response>;
  /** insert a single row into the table: "faq" */
  insert_faq_one?: Maybe<Faq>;
  /** insert data into the table: "faq_text" */
  insert_faq_text?: Maybe<Faq_Text_Mutation_Response>;
  /** insert a single row into the table: "faq_text" */
  insert_faq_text_one?: Maybe<Faq_Text>;
  /** insert data into the table: "friend_status" */
  insert_friend_status?: Maybe<Friend_Status_Mutation_Response>;
  /** insert a single row into the table: "friend_status" */
  insert_friend_status_one?: Maybe<Friend_Status>;
  /** insert data into the table: "friend_status_type" */
  insert_friend_status_type?: Maybe<Friend_Status_Type_Mutation_Response>;
  /** insert a single row into the table: "friend_status_type" */
  insert_friend_status_type_one?: Maybe<Friend_Status_Type>;
  /** insert data into the table: "full_card" */
  insert_full_card?: Maybe<Full_Card_Mutation_Response>;
  /** insert a single row into the table: "full_card" */
  insert_full_card_one?: Maybe<Full_Card>;
  /** insert data into the table: "full_card_text" */
  insert_full_card_text?: Maybe<Full_Card_Text_Mutation_Response>;
  /** insert a single row into the table: "full_card_text" */
  insert_full_card_text_one?: Maybe<Full_Card_Text>;
  /** insert data into the table: "gender" */
  insert_gender?: Maybe<Gender_Mutation_Response>;
  /** insert a single row into the table: "gender" */
  insert_gender_one?: Maybe<Gender>;
  /** insert data into the table: "guide_achievement" */
  insert_guide_achievement?: Maybe<Guide_Achievement_Mutation_Response>;
  /** insert a single row into the table: "guide_achievement" */
  insert_guide_achievement_one?: Maybe<Guide_Achievement>;
  /** insert data into the table: "guide_input" */
  insert_guide_input?: Maybe<Guide_Input_Mutation_Response>;
  /** insert a single row into the table: "guide_input" */
  insert_guide_input_one?: Maybe<Guide_Input>;
  /** insert data into the table: "investigator_data" */
  insert_investigator_data?: Maybe<Investigator_Data_Mutation_Response>;
  /** insert a single row into the table: "investigator_data" */
  insert_investigator_data_one?: Maybe<Investigator_Data>;
  /** insert data into the table: "latest_decks" */
  insert_latest_decks?: Maybe<Latest_Decks_Mutation_Response>;
  /** insert a single row into the table: "latest_decks" */
  insert_latest_decks_one?: Maybe<Latest_Decks>;
  /** insert data into the table: "local_decks" */
  insert_local_decks?: Maybe<Local_Decks_Mutation_Response>;
  /** insert a single row into the table: "local_decks" */
  insert_local_decks_one?: Maybe<Local_Decks>;
  /** insert data into the table: "pack" */
  insert_pack?: Maybe<Pack_Mutation_Response>;
  /** insert data into the table: "pack_name" */
  insert_pack_name?: Maybe<Pack_Name_Mutation_Response>;
  /** insert a single row into the table: "pack_name" */
  insert_pack_name_one?: Maybe<Pack_Name>;
  /** insert a single row into the table: "pack" */
  insert_pack_one?: Maybe<Pack>;
  /** insert data into the table: "rangers.area" */
  insert_rangers_area?: Maybe<Rangers_Area_Mutation_Response>;
  /** insert a single row into the table: "rangers.area" */
  insert_rangers_area_one?: Maybe<Rangers_Area>;
  /** insert data into the table: "rangers.area_text" */
  insert_rangers_area_text?: Maybe<Rangers_Area_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.area_text" */
  insert_rangers_area_text_one?: Maybe<Rangers_Area_Text>;
  /** insert data into the table: "rangers.aspect" */
  insert_rangers_aspect?: Maybe<Rangers_Aspect_Mutation_Response>;
  /** insert a single row into the table: "rangers.aspect" */
  insert_rangers_aspect_one?: Maybe<Rangers_Aspect>;
  /** insert data into the table: "rangers.aspect_text" */
  insert_rangers_aspect_text?: Maybe<Rangers_Aspect_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.aspect_text" */
  insert_rangers_aspect_text_one?: Maybe<Rangers_Aspect_Text>;
  /** insert data into the table: "rangers.campaign" */
  insert_rangers_campaign?: Maybe<Rangers_Campaign_Mutation_Response>;
  /** insert data into the table: "rangers.campaign_access" */
  insert_rangers_campaign_access?: Maybe<Rangers_Campaign_Access_Mutation_Response>;
  /** insert a single row into the table: "rangers.campaign_access" */
  insert_rangers_campaign_access_one?: Maybe<Rangers_Campaign_Access>;
  /** insert a single row into the table: "rangers.campaign" */
  insert_rangers_campaign_one?: Maybe<Rangers_Campaign>;
  /** insert data into the table: "rangers.card" */
  insert_rangers_card?: Maybe<Rangers_Card_Mutation_Response>;
  /** insert a single row into the table: "rangers.card" */
  insert_rangers_card_one?: Maybe<Rangers_Card>;
  /** insert data into the table: "rangers.card_text" */
  insert_rangers_card_text?: Maybe<Rangers_Card_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.card_text" */
  insert_rangers_card_text_one?: Maybe<Rangers_Card_Text>;
  /** insert data into the table: "rangers.comment" */
  insert_rangers_comment?: Maybe<Rangers_Comment_Mutation_Response>;
  /** insert a single row into the table: "rangers.comment" */
  insert_rangers_comment_one?: Maybe<Rangers_Comment>;
  /** insert data into the table: "rangers.deck" */
  insert_rangers_deck?: Maybe<Rangers_Deck_Mutation_Response>;
  /** insert data into the table: "rangers.deck_copy" */
  insert_rangers_deck_copy?: Maybe<Rangers_Deck_Copy_Mutation_Response>;
  /** insert a single row into the table: "rangers.deck_copy" */
  insert_rangers_deck_copy_one?: Maybe<Rangers_Deck_Copy>;
  /** insert data into the table: "rangers.deck_like" */
  insert_rangers_deck_like?: Maybe<Rangers_Deck_Like_Mutation_Response>;
  /** insert data into the table: "rangers.deck_like_count" */
  insert_rangers_deck_like_count?: Maybe<Rangers_Deck_Like_Count_Mutation_Response>;
  /** insert a single row into the table: "rangers.deck_like_count" */
  insert_rangers_deck_like_count_one?: Maybe<Rangers_Deck_Like_Count>;
  /** insert a single row into the table: "rangers.deck_like" */
  insert_rangers_deck_like_one?: Maybe<Rangers_Deck_Like>;
  /** insert a single row into the table: "rangers.deck" */
  insert_rangers_deck_one?: Maybe<Rangers_Deck>;
  /** insert data into the table: "rangers.faq_entry" */
  insert_rangers_faq_entry?: Maybe<Rangers_Faq_Entry_Mutation_Response>;
  /** insert a single row into the table: "rangers.faq_entry" */
  insert_rangers_faq_entry_one?: Maybe<Rangers_Faq_Entry>;
  /** insert data into the table: "rangers.friend_status" */
  insert_rangers_friend_status?: Maybe<Rangers_Friend_Status_Mutation_Response>;
  /** insert a single row into the table: "rangers.friend_status" */
  insert_rangers_friend_status_one?: Maybe<Rangers_Friend_Status>;
  /** insert data into the table: "rangers.friend_status_type" */
  insert_rangers_friend_status_type?: Maybe<Rangers_Friend_Status_Type_Mutation_Response>;
  /** insert a single row into the table: "rangers.friend_status_type" */
  insert_rangers_friend_status_type_one?: Maybe<Rangers_Friend_Status_Type>;
  /** insert data into the table: "rangers.latest_deck" */
  insert_rangers_latest_deck?: Maybe<Rangers_Latest_Deck_Mutation_Response>;
  /** insert a single row into the table: "rangers.latest_deck" */
  insert_rangers_latest_deck_one?: Maybe<Rangers_Latest_Deck>;
  /** insert data into the table: "rangers.locale" */
  insert_rangers_locale?: Maybe<Rangers_Locale_Mutation_Response>;
  /** insert a single row into the table: "rangers.locale" */
  insert_rangers_locale_one?: Maybe<Rangers_Locale>;
  /** insert data into the table: "rangers.pack" */
  insert_rangers_pack?: Maybe<Rangers_Pack_Mutation_Response>;
  /** insert a single row into the table: "rangers.pack" */
  insert_rangers_pack_one?: Maybe<Rangers_Pack>;
  /** insert data into the table: "rangers.pack_text" */
  insert_rangers_pack_text?: Maybe<Rangers_Pack_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.pack_text" */
  insert_rangers_pack_text_one?: Maybe<Rangers_Pack_Text>;
  /** insert data into the table: "rangers.search_deck" */
  insert_rangers_search_deck?: Maybe<Rangers_Search_Deck_Mutation_Response>;
  /** insert a single row into the table: "rangers.search_deck" */
  insert_rangers_search_deck_one?: Maybe<Rangers_Search_Deck>;
  /** insert data into the table: "rangers.set" */
  insert_rangers_set?: Maybe<Rangers_Set_Mutation_Response>;
  /** insert a single row into the table: "rangers.set" */
  insert_rangers_set_one?: Maybe<Rangers_Set>;
  /** insert data into the table: "rangers.set_text" */
  insert_rangers_set_text?: Maybe<Rangers_Set_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.set_text" */
  insert_rangers_set_text_one?: Maybe<Rangers_Set_Text>;
  /** insert data into the table: "rangers.set_type" */
  insert_rangers_set_type?: Maybe<Rangers_Set_Type_Mutation_Response>;
  /** insert a single row into the table: "rangers.set_type" */
  insert_rangers_set_type_one?: Maybe<Rangers_Set_Type>;
  /** insert data into the table: "rangers.set_type_text" */
  insert_rangers_set_type_text?: Maybe<Rangers_Set_Type_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.set_type_text" */
  insert_rangers_set_type_text_one?: Maybe<Rangers_Set_Type_Text>;
  /** insert data into the table: "rangers.subset" */
  insert_rangers_subset?: Maybe<Rangers_Subset_Mutation_Response>;
  /** insert a single row into the table: "rangers.subset" */
  insert_rangers_subset_one?: Maybe<Rangers_Subset>;
  /** insert data into the table: "rangers.subset_text" */
  insert_rangers_subset_text?: Maybe<Rangers_Subset_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.subset_text" */
  insert_rangers_subset_text_one?: Maybe<Rangers_Subset_Text>;
  /** insert data into the table: "rangers.taboo_set" */
  insert_rangers_taboo_set?: Maybe<Rangers_Taboo_Set_Mutation_Response>;
  /** insert a single row into the table: "rangers.taboo_set" */
  insert_rangers_taboo_set_one?: Maybe<Rangers_Taboo_Set>;
  /** insert data into the table: "rangers.taboo_set_text" */
  insert_rangers_taboo_set_text?: Maybe<Rangers_Taboo_Set_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.taboo_set_text" */
  insert_rangers_taboo_set_text_one?: Maybe<Rangers_Taboo_Set_Text>;
  /** insert data into the table: "rangers.token" */
  insert_rangers_token?: Maybe<Rangers_Token_Mutation_Response>;
  /** insert a single row into the table: "rangers.token" */
  insert_rangers_token_one?: Maybe<Rangers_Token>;
  /** insert data into the table: "rangers.token_text" */
  insert_rangers_token_text?: Maybe<Rangers_Token_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.token_text" */
  insert_rangers_token_text_one?: Maybe<Rangers_Token_Text>;
  /** insert data into the table: "rangers.type" */
  insert_rangers_type?: Maybe<Rangers_Type_Mutation_Response>;
  /** insert a single row into the table: "rangers.type" */
  insert_rangers_type_one?: Maybe<Rangers_Type>;
  /** insert data into the table: "rangers.type_text" */
  insert_rangers_type_text?: Maybe<Rangers_Type_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.type_text" */
  insert_rangers_type_text_one?: Maybe<Rangers_Type_Text>;
  /** insert data into the table: "rangers.user_friends" */
  insert_rangers_user_friends?: Maybe<Rangers_User_Friends_Mutation_Response>;
  /** insert a single row into the table: "rangers.user_friends" */
  insert_rangers_user_friends_one?: Maybe<Rangers_User_Friends>;
  /** insert data into the table: "rangers.user_received_friend_requests" */
  insert_rangers_user_received_friend_requests?: Maybe<Rangers_User_Received_Friend_Requests_Mutation_Response>;
  /** insert a single row into the table: "rangers.user_received_friend_requests" */
  insert_rangers_user_received_friend_requests_one?: Maybe<Rangers_User_Received_Friend_Requests>;
  /** insert data into the table: "rangers.user_role" */
  insert_rangers_user_role?: Maybe<Rangers_User_Role_Mutation_Response>;
  /** insert a single row into the table: "rangers.user_role" */
  insert_rangers_user_role_one?: Maybe<Rangers_User_Role>;
  /** insert data into the table: "rangers.user_sent_friend_requests" */
  insert_rangers_user_sent_friend_requests?: Maybe<Rangers_User_Sent_Friend_Requests_Mutation_Response>;
  /** insert a single row into the table: "rangers.user_sent_friend_requests" */
  insert_rangers_user_sent_friend_requests_one?: Maybe<Rangers_User_Sent_Friend_Requests>;
  /** insert data into the table: "rangers.user_settings" */
  insert_rangers_user_settings?: Maybe<Rangers_User_Settings_Mutation_Response>;
  /** insert a single row into the table: "rangers.user_settings" */
  insert_rangers_user_settings_one?: Maybe<Rangers_User_Settings>;
  /** insert data into the table: "rangers.users" */
  insert_rangers_users?: Maybe<Rangers_Users_Mutation_Response>;
  /** insert a single row into the table: "rangers.users" */
  insert_rangers_users_one?: Maybe<Rangers_Users>;
  /** insert data into the table: "taboo_set" */
  insert_taboo_set?: Maybe<Taboo_Set_Mutation_Response>;
  /** insert a single row into the table: "taboo_set" */
  insert_taboo_set_one?: Maybe<Taboo_Set>;
  /** insert data into the table: "user_campaigns" */
  insert_user_campaigns?: Maybe<User_Campaigns_Mutation_Response>;
  /** insert a single row into the table: "user_campaigns" */
  insert_user_campaigns_one?: Maybe<User_Campaigns>;
  /** insert data into the table: "user_flag" */
  insert_user_flag?: Maybe<User_Flag_Mutation_Response>;
  /** insert a single row into the table: "user_flag" */
  insert_user_flag_one?: Maybe<User_Flag>;
  /** insert data into the table: "user_flag_type" */
  insert_user_flag_type?: Maybe<User_Flag_Type_Mutation_Response>;
  /** insert a single row into the table: "user_flag_type" */
  insert_user_flag_type_one?: Maybe<User_Flag_Type>;
  /** insert data into the table: "user_friends" */
  insert_user_friends?: Maybe<User_Friends_Mutation_Response>;
  /** insert a single row into the table: "user_friends" */
  insert_user_friends_one?: Maybe<User_Friends>;
  /** insert data into the table: "user_received_friend_requests" */
  insert_user_received_friend_requests?: Maybe<User_Received_Friend_Requests_Mutation_Response>;
  /** insert a single row into the table: "user_received_friend_requests" */
  insert_user_received_friend_requests_one?: Maybe<User_Received_Friend_Requests>;
  /** insert data into the table: "user_sent_friend_requests" */
  insert_user_sent_friend_requests?: Maybe<User_Sent_Friend_Requests_Mutation_Response>;
  /** insert a single row into the table: "user_sent_friend_requests" */
  insert_user_sent_friend_requests_one?: Maybe<User_Sent_Friend_Requests>;
  /** insert data into the table: "user_settings" */
  insert_user_settings?: Maybe<User_Settings_Mutation_Response>;
  /** insert a single row into the table: "user_settings" */
  insert_user_settings_one?: Maybe<User_Settings>;
  /** insert data into the table: "users" */
  insert_users?: Maybe<Users_Mutation_Response>;
  /** insert a single row into the table: "users" */
  insert_users_one?: Maybe<Users>;
  loginToArkhamDb?: Maybe<LoginOutput>;
  logoutFromArkhamDb?: Maybe<LogoutOutput>;
  migrateLoginToArkhamDb?: Maybe<MigrateLoginOutput>;
  /** execute VOLATILE function "rangers.publish_deck" which returns "rangers.deck" */
  rangers_publish_deck?: Maybe<Rangers_Deck>;
  /** execute VOLATILE function "rangers.remove_campaign" which returns "rangers.campaign" */
  rangers_remove_campaign: Array<Rangers_Campaign>;
  /** execute VOLATILE function "rangers.remove_campaign_deck" which returns "rangers.campaign" */
  rangers_remove_campaign_deck: Array<Rangers_Campaign>;
  /** execute VOLATILE function "rangers.set_campaign_deck" which returns "rangers.campaign" */
  rangers_set_campaign_deck: Array<Rangers_Campaign>;
  /** execute VOLATILE function "rangers.set_handle" which returns "rangers.users" */
  rangers_set_handle: Array<Rangers_Users>;
  /** execute VOLATILE function "rangers.transfer_campaign" which returns "rangers.campaign" */
  rangers_transfer_campaign: Array<Rangers_Campaign>;
  /** execute VOLATILE function "rangers.update_friend_request" which returns "rangers.users" */
  rangers_update_friend_request: Array<Rangers_Users>;
  /** execute VOLATILE function "rangers.upgrade_deck" which returns "rangers.deck" */
  rangers_upgrade_deck?: Maybe<Rangers_Deck>;
  refreshArkhamDbDecks?: Maybe<RefreshDecksOutput>;
  updateFriendRequest?: Maybe<FriendRequestOutput>;
  updateHandle?: Maybe<UpdateHandleOutput>;
  /** update data of the table: "all_card" */
  update_all_card?: Maybe<All_Card_Mutation_Response>;
  /** update single row of the table: "all_card" */
  update_all_card_by_pk?: Maybe<All_Card>;
  /** update multiples rows of table: "all_card" */
  update_all_card_many?: Maybe<Array<Maybe<All_Card_Mutation_Response>>>;
  /** update data of the table: "all_card_text" */
  update_all_card_text?: Maybe<All_Card_Text_Mutation_Response>;
  /** update single row of the table: "all_card_text" */
  update_all_card_text_by_pk?: Maybe<All_Card_Text>;
  /** update multiples rows of table: "all_card_text" */
  update_all_card_text_many?: Maybe<Array<Maybe<All_Card_Text_Mutation_Response>>>;
  /** update data of the table: "all_card_updated" */
  update_all_card_updated?: Maybe<All_Card_Updated_Mutation_Response>;
  /** update single row of the table: "all_card_updated" */
  update_all_card_updated_by_pk?: Maybe<All_Card_Updated>;
  /** update data of the table: "all_card_updated_by_version" */
  update_all_card_updated_by_version?: Maybe<All_Card_Updated_By_Version_Mutation_Response>;
  /** update single row of the table: "all_card_updated_by_version" */
  update_all_card_updated_by_version_by_pk?: Maybe<All_Card_Updated_By_Version>;
  /** update multiples rows of table: "all_card_updated_by_version" */
  update_all_card_updated_by_version_many?: Maybe<Array<Maybe<All_Card_Updated_By_Version_Mutation_Response>>>;
  /** update multiples rows of table: "all_card_updated" */
  update_all_card_updated_many?: Maybe<Array<Maybe<All_Card_Updated_Mutation_Response>>>;
  /** update data of the table: "arkhamdb_auth" */
  update_arkhamdb_auth?: Maybe<Arkhamdb_Auth_Mutation_Response>;
  /** update single row of the table: "arkhamdb_auth" */
  update_arkhamdb_auth_by_pk?: Maybe<Arkhamdb_Auth>;
  /** update multiples rows of table: "arkhamdb_auth" */
  update_arkhamdb_auth_many?: Maybe<Array<Maybe<Arkhamdb_Auth_Mutation_Response>>>;
  /** update data of the table: "arkhamdb_deck" */
  update_arkhamdb_deck?: Maybe<Arkhamdb_Deck_Mutation_Response>;
  /** update single row of the table: "arkhamdb_deck" */
  update_arkhamdb_deck_by_pk?: Maybe<Arkhamdb_Deck>;
  /** update multiples rows of table: "arkhamdb_deck" */
  update_arkhamdb_deck_many?: Maybe<Array<Maybe<Arkhamdb_Deck_Mutation_Response>>>;
  /** update data of the table: "base_decks" */
  update_base_decks?: Maybe<Base_Decks_Mutation_Response>;
  /** update multiples rows of table: "base_decks" */
  update_base_decks_many?: Maybe<Array<Maybe<Base_Decks_Mutation_Response>>>;
  /** update data of the table: "campaign" */
  update_campaign?: Maybe<Campaign_Mutation_Response>;
  /** update data of the table: "campaign_access" */
  update_campaign_access?: Maybe<Campaign_Access_Mutation_Response>;
  /** update single row of the table: "campaign_access" */
  update_campaign_access_by_pk?: Maybe<Campaign_Access>;
  /** update multiples rows of table: "campaign_access" */
  update_campaign_access_many?: Maybe<Array<Maybe<Campaign_Access_Mutation_Response>>>;
  /** update single row of the table: "campaign" */
  update_campaign_by_pk?: Maybe<Campaign>;
  /** update data of the table: "campaign_deck" */
  update_campaign_deck?: Maybe<Campaign_Deck_Mutation_Response>;
  /** update single row of the table: "campaign_deck" */
  update_campaign_deck_by_pk?: Maybe<Campaign_Deck>;
  /** update multiples rows of table: "campaign_deck" */
  update_campaign_deck_many?: Maybe<Array<Maybe<Campaign_Deck_Mutation_Response>>>;
  /** update data of the table: "campaign_difficulty" */
  update_campaign_difficulty?: Maybe<Campaign_Difficulty_Mutation_Response>;
  /** update single row of the table: "campaign_difficulty" */
  update_campaign_difficulty_by_pk?: Maybe<Campaign_Difficulty>;
  /** update multiples rows of table: "campaign_difficulty" */
  update_campaign_difficulty_many?: Maybe<Array<Maybe<Campaign_Difficulty_Mutation_Response>>>;
  /** update data of the table: "campaign_guide" */
  update_campaign_guide?: Maybe<Campaign_Guide_Mutation_Response>;
  /** update multiples rows of table: "campaign_guide" */
  update_campaign_guide_many?: Maybe<Array<Maybe<Campaign_Guide_Mutation_Response>>>;
  /** update data of the table: "campaign_investigator" */
  update_campaign_investigator?: Maybe<Campaign_Investigator_Mutation_Response>;
  /** update single row of the table: "campaign_investigator" */
  update_campaign_investigator_by_pk?: Maybe<Campaign_Investigator>;
  /** update multiples rows of table: "campaign_investigator" */
  update_campaign_investigator_many?: Maybe<Array<Maybe<Campaign_Investigator_Mutation_Response>>>;
  /** update multiples rows of table: "campaign" */
  update_campaign_many?: Maybe<Array<Maybe<Campaign_Mutation_Response>>>;
  /** update data of the table: "card" */
  update_card?: Maybe<Card_Mutation_Response>;
  /** update single row of the table: "card" */
  update_card_by_pk?: Maybe<Card>;
  /** update data of the table: "card_cycle" */
  update_card_cycle?: Maybe<Card_Cycle_Mutation_Response>;
  /** update single row of the table: "card_cycle" */
  update_card_cycle_by_pk?: Maybe<Card_Cycle>;
  /** update multiples rows of table: "card_cycle" */
  update_card_cycle_many?: Maybe<Array<Maybe<Card_Cycle_Mutation_Response>>>;
  /** update data of the table: "card_encounter_set" */
  update_card_encounter_set?: Maybe<Card_Encounter_Set_Mutation_Response>;
  /** update single row of the table: "card_encounter_set" */
  update_card_encounter_set_by_pk?: Maybe<Card_Encounter_Set>;
  /** update multiples rows of table: "card_encounter_set" */
  update_card_encounter_set_many?: Maybe<Array<Maybe<Card_Encounter_Set_Mutation_Response>>>;
  /** update multiples rows of table: "card" */
  update_card_many?: Maybe<Array<Maybe<Card_Mutation_Response>>>;
  /** update data of the table: "card_pack" */
  update_card_pack?: Maybe<Card_Pack_Mutation_Response>;
  /** update single row of the table: "card_pack" */
  update_card_pack_by_pk?: Maybe<Card_Pack>;
  /** update multiples rows of table: "card_pack" */
  update_card_pack_many?: Maybe<Array<Maybe<Card_Pack_Mutation_Response>>>;
  /** update data of the table: "card_subtype_name" */
  update_card_subtype_name?: Maybe<Card_Subtype_Name_Mutation_Response>;
  /** update single row of the table: "card_subtype_name" */
  update_card_subtype_name_by_pk?: Maybe<Card_Subtype_Name>;
  /** update multiples rows of table: "card_subtype_name" */
  update_card_subtype_name_many?: Maybe<Array<Maybe<Card_Subtype_Name_Mutation_Response>>>;
  /** update data of the table: "card_text" */
  update_card_text?: Maybe<Card_Text_Mutation_Response>;
  /** update single row of the table: "card_text" */
  update_card_text_by_pk?: Maybe<Card_Text>;
  /** update multiples rows of table: "card_text" */
  update_card_text_many?: Maybe<Array<Maybe<Card_Text_Mutation_Response>>>;
  /** update data of the table: "card_type_code" */
  update_card_type_code?: Maybe<Card_Type_Code_Mutation_Response>;
  /** update single row of the table: "card_type_code" */
  update_card_type_code_by_pk?: Maybe<Card_Type_Code>;
  /** update multiples rows of table: "card_type_code" */
  update_card_type_code_many?: Maybe<Array<Maybe<Card_Type_Code_Mutation_Response>>>;
  /** update data of the table: "card_type_name" */
  update_card_type_name?: Maybe<Card_Type_Name_Mutation_Response>;
  /** update single row of the table: "card_type_name" */
  update_card_type_name_by_pk?: Maybe<Card_Type_Name>;
  /** update multiples rows of table: "card_type_name" */
  update_card_type_name_many?: Maybe<Array<Maybe<Card_Type_Name_Mutation_Response>>>;
  /** update data of the table: "chaos_bag_result" */
  update_chaos_bag_result?: Maybe<Chaos_Bag_Result_Mutation_Response>;
  /** update single row of the table: "chaos_bag_result" */
  update_chaos_bag_result_by_pk?: Maybe<Chaos_Bag_Result>;
  /** update multiples rows of table: "chaos_bag_result" */
  update_chaos_bag_result_many?: Maybe<Array<Maybe<Chaos_Bag_Result_Mutation_Response>>>;
  /** update data of the table: "chaos_bag_tarot_mode" */
  update_chaos_bag_tarot_mode?: Maybe<Chaos_Bag_Tarot_Mode_Mutation_Response>;
  /** update single row of the table: "chaos_bag_tarot_mode" */
  update_chaos_bag_tarot_mode_by_pk?: Maybe<Chaos_Bag_Tarot_Mode>;
  /** update multiples rows of table: "chaos_bag_tarot_mode" */
  update_chaos_bag_tarot_mode_many?: Maybe<Array<Maybe<Chaos_Bag_Tarot_Mode_Mutation_Response>>>;
  /** update data of the table: "conquest.card" */
  update_conquest_card?: Maybe<Conquest_Card_Mutation_Response>;
  /** update single row of the table: "conquest.card" */
  update_conquest_card_by_pk?: Maybe<Conquest_Card>;
  /** update multiples rows of table: "conquest.card" */
  update_conquest_card_many?: Maybe<Array<Maybe<Conquest_Card_Mutation_Response>>>;
  /** update data of the table: "conquest.card_text" */
  update_conquest_card_text?: Maybe<Conquest_Card_Text_Mutation_Response>;
  /** update single row of the table: "conquest.card_text" */
  update_conquest_card_text_by_pk?: Maybe<Conquest_Card_Text>;
  /** update multiples rows of table: "conquest.card_text" */
  update_conquest_card_text_many?: Maybe<Array<Maybe<Conquest_Card_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.comment" */
  update_conquest_comment?: Maybe<Conquest_Comment_Mutation_Response>;
  /** update single row of the table: "conquest.comment" */
  update_conquest_comment_by_pk?: Maybe<Conquest_Comment>;
  /** update multiples rows of table: "conquest.comment" */
  update_conquest_comment_many?: Maybe<Array<Maybe<Conquest_Comment_Mutation_Response>>>;
  /** update data of the table: "conquest.cycle" */
  update_conquest_cycle?: Maybe<Conquest_Cycle_Mutation_Response>;
  /** update single row of the table: "conquest.cycle" */
  update_conquest_cycle_by_pk?: Maybe<Conquest_Cycle>;
  /** update multiples rows of table: "conquest.cycle" */
  update_conquest_cycle_many?: Maybe<Array<Maybe<Conquest_Cycle_Mutation_Response>>>;
  /** update data of the table: "conquest.cycle_text" */
  update_conquest_cycle_text?: Maybe<Conquest_Cycle_Text_Mutation_Response>;
  /** update single row of the table: "conquest.cycle_text" */
  update_conquest_cycle_text_by_pk?: Maybe<Conquest_Cycle_Text>;
  /** update multiples rows of table: "conquest.cycle_text" */
  update_conquest_cycle_text_many?: Maybe<Array<Maybe<Conquest_Cycle_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.deck" */
  update_conquest_deck?: Maybe<Conquest_Deck_Mutation_Response>;
  /** update single row of the table: "conquest.deck" */
  update_conquest_deck_by_pk?: Maybe<Conquest_Deck>;
  /** update data of the table: "conquest.deck_copy" */
  update_conquest_deck_copy?: Maybe<Conquest_Deck_Copy_Mutation_Response>;
  /** update single row of the table: "conquest.deck_copy" */
  update_conquest_deck_copy_by_pk?: Maybe<Conquest_Deck_Copy>;
  /** update multiples rows of table: "conquest.deck_copy" */
  update_conquest_deck_copy_many?: Maybe<Array<Maybe<Conquest_Deck_Copy_Mutation_Response>>>;
  /** update data of the table: "conquest.deck_like" */
  update_conquest_deck_like?: Maybe<Conquest_Deck_Like_Mutation_Response>;
  /** update single row of the table: "conquest.deck_like" */
  update_conquest_deck_like_by_pk?: Maybe<Conquest_Deck_Like>;
  /** update multiples rows of table: "conquest.deck_like" */
  update_conquest_deck_like_many?: Maybe<Array<Maybe<Conquest_Deck_Like_Mutation_Response>>>;
  /** update multiples rows of table: "conquest.deck" */
  update_conquest_deck_many?: Maybe<Array<Maybe<Conquest_Deck_Mutation_Response>>>;
  /** update data of the table: "conquest.faction" */
  update_conquest_faction?: Maybe<Conquest_Faction_Mutation_Response>;
  /** update single row of the table: "conquest.faction" */
  update_conquest_faction_by_pk?: Maybe<Conquest_Faction>;
  /** update multiples rows of table: "conquest.faction" */
  update_conquest_faction_many?: Maybe<Array<Maybe<Conquest_Faction_Mutation_Response>>>;
  /** update data of the table: "conquest.faction_text" */
  update_conquest_faction_text?: Maybe<Conquest_Faction_Text_Mutation_Response>;
  /** update single row of the table: "conquest.faction_text" */
  update_conquest_faction_text_by_pk?: Maybe<Conquest_Faction_Text>;
  /** update multiples rows of table: "conquest.faction_text" */
  update_conquest_faction_text_many?: Maybe<Array<Maybe<Conquest_Faction_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.loyalty" */
  update_conquest_loyalty?: Maybe<Conquest_Loyalty_Mutation_Response>;
  /** update single row of the table: "conquest.loyalty" */
  update_conquest_loyalty_by_pk?: Maybe<Conquest_Loyalty>;
  /** update multiples rows of table: "conquest.loyalty" */
  update_conquest_loyalty_many?: Maybe<Array<Maybe<Conquest_Loyalty_Mutation_Response>>>;
  /** update data of the table: "conquest.loyalty_text" */
  update_conquest_loyalty_text?: Maybe<Conquest_Loyalty_Text_Mutation_Response>;
  /** update single row of the table: "conquest.loyalty_text" */
  update_conquest_loyalty_text_by_pk?: Maybe<Conquest_Loyalty_Text>;
  /** update multiples rows of table: "conquest.loyalty_text" */
  update_conquest_loyalty_text_many?: Maybe<Array<Maybe<Conquest_Loyalty_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.pack" */
  update_conquest_pack?: Maybe<Conquest_Pack_Mutation_Response>;
  /** update single row of the table: "conquest.pack" */
  update_conquest_pack_by_pk?: Maybe<Conquest_Pack>;
  /** update multiples rows of table: "conquest.pack" */
  update_conquest_pack_many?: Maybe<Array<Maybe<Conquest_Pack_Mutation_Response>>>;
  /** update data of the table: "conquest.pack_text" */
  update_conquest_pack_text?: Maybe<Conquest_Pack_Text_Mutation_Response>;
  /** update single row of the table: "conquest.pack_text" */
  update_conquest_pack_text_by_pk?: Maybe<Conquest_Pack_Text>;
  /** update multiples rows of table: "conquest.pack_text" */
  update_conquest_pack_text_many?: Maybe<Array<Maybe<Conquest_Pack_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.type" */
  update_conquest_type?: Maybe<Conquest_Type_Mutation_Response>;
  /** update single row of the table: "conquest.type" */
  update_conquest_type_by_pk?: Maybe<Conquest_Type>;
  /** update multiples rows of table: "conquest.type" */
  update_conquest_type_many?: Maybe<Array<Maybe<Conquest_Type_Mutation_Response>>>;
  /** update data of the table: "conquest.type_text" */
  update_conquest_type_text?: Maybe<Conquest_Type_Text_Mutation_Response>;
  /** update single row of the table: "conquest.type_text" */
  update_conquest_type_text_by_pk?: Maybe<Conquest_Type_Text>;
  /** update multiples rows of table: "conquest.type_text" */
  update_conquest_type_text_many?: Maybe<Array<Maybe<Conquest_Type_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.user_role" */
  update_conquest_user_role?: Maybe<Conquest_User_Role_Mutation_Response>;
  /** update single row of the table: "conquest.user_role" */
  update_conquest_user_role_by_pk?: Maybe<Conquest_User_Role>;
  /** update multiples rows of table: "conquest.user_role" */
  update_conquest_user_role_many?: Maybe<Array<Maybe<Conquest_User_Role_Mutation_Response>>>;
  /** update data of the table: "conquest.user_settings" */
  update_conquest_user_settings?: Maybe<Conquest_User_Settings_Mutation_Response>;
  /** update single row of the table: "conquest.user_settings" */
  update_conquest_user_settings_by_pk?: Maybe<Conquest_User_Settings>;
  /** update multiples rows of table: "conquest.user_settings" */
  update_conquest_user_settings_many?: Maybe<Array<Maybe<Conquest_User_Settings_Mutation_Response>>>;
  /** update data of the table: "conquest.users" */
  update_conquest_users?: Maybe<Conquest_Users_Mutation_Response>;
  /** update single row of the table: "conquest.users" */
  update_conquest_users_by_pk?: Maybe<Conquest_Users>;
  /** update multiples rows of table: "conquest.users" */
  update_conquest_users_many?: Maybe<Array<Maybe<Conquest_Users_Mutation_Response>>>;
  /** update data of the table: "cycle" */
  update_cycle?: Maybe<Cycle_Mutation_Response>;
  /** update single row of the table: "cycle" */
  update_cycle_by_pk?: Maybe<Cycle>;
  /** update multiples rows of table: "cycle" */
  update_cycle_many?: Maybe<Array<Maybe<Cycle_Mutation_Response>>>;
  /** update data of the table: "cycle_name" */
  update_cycle_name?: Maybe<Cycle_Name_Mutation_Response>;
  /** update single row of the table: "cycle_name" */
  update_cycle_name_by_pk?: Maybe<Cycle_Name>;
  /** update multiples rows of table: "cycle_name" */
  update_cycle_name_many?: Maybe<Array<Maybe<Cycle_Name_Mutation_Response>>>;
  /** update data of the table: "faction_name" */
  update_faction_name?: Maybe<Faction_Name_Mutation_Response>;
  /** update single row of the table: "faction_name" */
  update_faction_name_by_pk?: Maybe<Faction_Name>;
  /** update multiples rows of table: "faction_name" */
  update_faction_name_many?: Maybe<Array<Maybe<Faction_Name_Mutation_Response>>>;
  /** update data of the table: "faq" */
  update_faq?: Maybe<Faq_Mutation_Response>;
  /** update single row of the table: "faq" */
  update_faq_by_pk?: Maybe<Faq>;
  /** update multiples rows of table: "faq" */
  update_faq_many?: Maybe<Array<Maybe<Faq_Mutation_Response>>>;
  /** update data of the table: "faq_text" */
  update_faq_text?: Maybe<Faq_Text_Mutation_Response>;
  /** update single row of the table: "faq_text" */
  update_faq_text_by_pk?: Maybe<Faq_Text>;
  /** update multiples rows of table: "faq_text" */
  update_faq_text_many?: Maybe<Array<Maybe<Faq_Text_Mutation_Response>>>;
  /** update data of the table: "friend_status" */
  update_friend_status?: Maybe<Friend_Status_Mutation_Response>;
  /** update single row of the table: "friend_status" */
  update_friend_status_by_pk?: Maybe<Friend_Status>;
  /** update multiples rows of table: "friend_status" */
  update_friend_status_many?: Maybe<Array<Maybe<Friend_Status_Mutation_Response>>>;
  /** update data of the table: "friend_status_type" */
  update_friend_status_type?: Maybe<Friend_Status_Type_Mutation_Response>;
  /** update single row of the table: "friend_status_type" */
  update_friend_status_type_by_pk?: Maybe<Friend_Status_Type>;
  /** update multiples rows of table: "friend_status_type" */
  update_friend_status_type_many?: Maybe<Array<Maybe<Friend_Status_Type_Mutation_Response>>>;
  /** update data of the table: "full_card" */
  update_full_card?: Maybe<Full_Card_Mutation_Response>;
  /** update single row of the table: "full_card" */
  update_full_card_by_pk?: Maybe<Full_Card>;
  /** update multiples rows of table: "full_card" */
  update_full_card_many?: Maybe<Array<Maybe<Full_Card_Mutation_Response>>>;
  /** update data of the table: "full_card_text" */
  update_full_card_text?: Maybe<Full_Card_Text_Mutation_Response>;
  /** update single row of the table: "full_card_text" */
  update_full_card_text_by_pk?: Maybe<Full_Card_Text>;
  /** update multiples rows of table: "full_card_text" */
  update_full_card_text_many?: Maybe<Array<Maybe<Full_Card_Text_Mutation_Response>>>;
  /** update data of the table: "gender" */
  update_gender?: Maybe<Gender_Mutation_Response>;
  /** update single row of the table: "gender" */
  update_gender_by_pk?: Maybe<Gender>;
  /** update multiples rows of table: "gender" */
  update_gender_many?: Maybe<Array<Maybe<Gender_Mutation_Response>>>;
  /** update data of the table: "guide_achievement" */
  update_guide_achievement?: Maybe<Guide_Achievement_Mutation_Response>;
  /** update single row of the table: "guide_achievement" */
  update_guide_achievement_by_pk?: Maybe<Guide_Achievement>;
  /** update multiples rows of table: "guide_achievement" */
  update_guide_achievement_many?: Maybe<Array<Maybe<Guide_Achievement_Mutation_Response>>>;
  /** update data of the table: "guide_input" */
  update_guide_input?: Maybe<Guide_Input_Mutation_Response>;
  /** update single row of the table: "guide_input" */
  update_guide_input_by_pk?: Maybe<Guide_Input>;
  /** update multiples rows of table: "guide_input" */
  update_guide_input_many?: Maybe<Array<Maybe<Guide_Input_Mutation_Response>>>;
  /** update data of the table: "investigator_data" */
  update_investigator_data?: Maybe<Investigator_Data_Mutation_Response>;
  /** update single row of the table: "investigator_data" */
  update_investigator_data_by_pk?: Maybe<Investigator_Data>;
  /** update multiples rows of table: "investigator_data" */
  update_investigator_data_many?: Maybe<Array<Maybe<Investigator_Data_Mutation_Response>>>;
  /** update data of the table: "latest_decks" */
  update_latest_decks?: Maybe<Latest_Decks_Mutation_Response>;
  /** update multiples rows of table: "latest_decks" */
  update_latest_decks_many?: Maybe<Array<Maybe<Latest_Decks_Mutation_Response>>>;
  /** update data of the table: "local_decks" */
  update_local_decks?: Maybe<Local_Decks_Mutation_Response>;
  /** update multiples rows of table: "local_decks" */
  update_local_decks_many?: Maybe<Array<Maybe<Local_Decks_Mutation_Response>>>;
  /** update data of the table: "pack" */
  update_pack?: Maybe<Pack_Mutation_Response>;
  /** update single row of the table: "pack" */
  update_pack_by_pk?: Maybe<Pack>;
  /** update multiples rows of table: "pack" */
  update_pack_many?: Maybe<Array<Maybe<Pack_Mutation_Response>>>;
  /** update data of the table: "pack_name" */
  update_pack_name?: Maybe<Pack_Name_Mutation_Response>;
  /** update single row of the table: "pack_name" */
  update_pack_name_by_pk?: Maybe<Pack_Name>;
  /** update multiples rows of table: "pack_name" */
  update_pack_name_many?: Maybe<Array<Maybe<Pack_Name_Mutation_Response>>>;
  /** update data of the table: "rangers.area" */
  update_rangers_area?: Maybe<Rangers_Area_Mutation_Response>;
  /** update single row of the table: "rangers.area" */
  update_rangers_area_by_pk?: Maybe<Rangers_Area>;
  /** update multiples rows of table: "rangers.area" */
  update_rangers_area_many?: Maybe<Array<Maybe<Rangers_Area_Mutation_Response>>>;
  /** update data of the table: "rangers.area_text" */
  update_rangers_area_text?: Maybe<Rangers_Area_Text_Mutation_Response>;
  /** update single row of the table: "rangers.area_text" */
  update_rangers_area_text_by_pk?: Maybe<Rangers_Area_Text>;
  /** update multiples rows of table: "rangers.area_text" */
  update_rangers_area_text_many?: Maybe<Array<Maybe<Rangers_Area_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.aspect" */
  update_rangers_aspect?: Maybe<Rangers_Aspect_Mutation_Response>;
  /** update single row of the table: "rangers.aspect" */
  update_rangers_aspect_by_pk?: Maybe<Rangers_Aspect>;
  /** update multiples rows of table: "rangers.aspect" */
  update_rangers_aspect_many?: Maybe<Array<Maybe<Rangers_Aspect_Mutation_Response>>>;
  /** update data of the table: "rangers.aspect_text" */
  update_rangers_aspect_text?: Maybe<Rangers_Aspect_Text_Mutation_Response>;
  /** update single row of the table: "rangers.aspect_text" */
  update_rangers_aspect_text_by_pk?: Maybe<Rangers_Aspect_Text>;
  /** update multiples rows of table: "rangers.aspect_text" */
  update_rangers_aspect_text_many?: Maybe<Array<Maybe<Rangers_Aspect_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.campaign" */
  update_rangers_campaign?: Maybe<Rangers_Campaign_Mutation_Response>;
  /** update data of the table: "rangers.campaign_access" */
  update_rangers_campaign_access?: Maybe<Rangers_Campaign_Access_Mutation_Response>;
  /** update single row of the table: "rangers.campaign_access" */
  update_rangers_campaign_access_by_pk?: Maybe<Rangers_Campaign_Access>;
  /** update multiples rows of table: "rangers.campaign_access" */
  update_rangers_campaign_access_many?: Maybe<Array<Maybe<Rangers_Campaign_Access_Mutation_Response>>>;
  /** update single row of the table: "rangers.campaign" */
  update_rangers_campaign_by_pk?: Maybe<Rangers_Campaign>;
  /** update multiples rows of table: "rangers.campaign" */
  update_rangers_campaign_many?: Maybe<Array<Maybe<Rangers_Campaign_Mutation_Response>>>;
  /** update data of the table: "rangers.card" */
  update_rangers_card?: Maybe<Rangers_Card_Mutation_Response>;
  /** update single row of the table: "rangers.card" */
  update_rangers_card_by_pk?: Maybe<Rangers_Card>;
  /** update multiples rows of table: "rangers.card" */
  update_rangers_card_many?: Maybe<Array<Maybe<Rangers_Card_Mutation_Response>>>;
  /** update data of the table: "rangers.card_text" */
  update_rangers_card_text?: Maybe<Rangers_Card_Text_Mutation_Response>;
  /** update single row of the table: "rangers.card_text" */
  update_rangers_card_text_by_pk?: Maybe<Rangers_Card_Text>;
  /** update multiples rows of table: "rangers.card_text" */
  update_rangers_card_text_many?: Maybe<Array<Maybe<Rangers_Card_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.comment" */
  update_rangers_comment?: Maybe<Rangers_Comment_Mutation_Response>;
  /** update single row of the table: "rangers.comment" */
  update_rangers_comment_by_pk?: Maybe<Rangers_Comment>;
  /** update multiples rows of table: "rangers.comment" */
  update_rangers_comment_many?: Maybe<Array<Maybe<Rangers_Comment_Mutation_Response>>>;
  /** update data of the table: "rangers.deck" */
  update_rangers_deck?: Maybe<Rangers_Deck_Mutation_Response>;
  /** update single row of the table: "rangers.deck" */
  update_rangers_deck_by_pk?: Maybe<Rangers_Deck>;
  /** update data of the table: "rangers.deck_copy" */
  update_rangers_deck_copy?: Maybe<Rangers_Deck_Copy_Mutation_Response>;
  /** update single row of the table: "rangers.deck_copy" */
  update_rangers_deck_copy_by_pk?: Maybe<Rangers_Deck_Copy>;
  /** update multiples rows of table: "rangers.deck_copy" */
  update_rangers_deck_copy_many?: Maybe<Array<Maybe<Rangers_Deck_Copy_Mutation_Response>>>;
  /** update data of the table: "rangers.deck_like" */
  update_rangers_deck_like?: Maybe<Rangers_Deck_Like_Mutation_Response>;
  /** update single row of the table: "rangers.deck_like" */
  update_rangers_deck_like_by_pk?: Maybe<Rangers_Deck_Like>;
  /** update data of the table: "rangers.deck_like_count" */
  update_rangers_deck_like_count?: Maybe<Rangers_Deck_Like_Count_Mutation_Response>;
  /** update single row of the table: "rangers.deck_like_count" */
  update_rangers_deck_like_count_by_pk?: Maybe<Rangers_Deck_Like_Count>;
  /** update multiples rows of table: "rangers.deck_like_count" */
  update_rangers_deck_like_count_many?: Maybe<Array<Maybe<Rangers_Deck_Like_Count_Mutation_Response>>>;
  /** update multiples rows of table: "rangers.deck_like" */
  update_rangers_deck_like_many?: Maybe<Array<Maybe<Rangers_Deck_Like_Mutation_Response>>>;
  /** update multiples rows of table: "rangers.deck" */
  update_rangers_deck_many?: Maybe<Array<Maybe<Rangers_Deck_Mutation_Response>>>;
  /** update data of the table: "rangers.faq_entry" */
  update_rangers_faq_entry?: Maybe<Rangers_Faq_Entry_Mutation_Response>;
  /** update single row of the table: "rangers.faq_entry" */
  update_rangers_faq_entry_by_pk?: Maybe<Rangers_Faq_Entry>;
  /** update multiples rows of table: "rangers.faq_entry" */
  update_rangers_faq_entry_many?: Maybe<Array<Maybe<Rangers_Faq_Entry_Mutation_Response>>>;
  /** update data of the table: "rangers.friend_status" */
  update_rangers_friend_status?: Maybe<Rangers_Friend_Status_Mutation_Response>;
  /** update single row of the table: "rangers.friend_status" */
  update_rangers_friend_status_by_pk?: Maybe<Rangers_Friend_Status>;
  /** update multiples rows of table: "rangers.friend_status" */
  update_rangers_friend_status_many?: Maybe<Array<Maybe<Rangers_Friend_Status_Mutation_Response>>>;
  /** update data of the table: "rangers.friend_status_type" */
  update_rangers_friend_status_type?: Maybe<Rangers_Friend_Status_Type_Mutation_Response>;
  /** update single row of the table: "rangers.friend_status_type" */
  update_rangers_friend_status_type_by_pk?: Maybe<Rangers_Friend_Status_Type>;
  /** update multiples rows of table: "rangers.friend_status_type" */
  update_rangers_friend_status_type_many?: Maybe<Array<Maybe<Rangers_Friend_Status_Type_Mutation_Response>>>;
  /** update data of the table: "rangers.latest_deck" */
  update_rangers_latest_deck?: Maybe<Rangers_Latest_Deck_Mutation_Response>;
  /** update multiples rows of table: "rangers.latest_deck" */
  update_rangers_latest_deck_many?: Maybe<Array<Maybe<Rangers_Latest_Deck_Mutation_Response>>>;
  /** update data of the table: "rangers.locale" */
  update_rangers_locale?: Maybe<Rangers_Locale_Mutation_Response>;
  /** update single row of the table: "rangers.locale" */
  update_rangers_locale_by_pk?: Maybe<Rangers_Locale>;
  /** update multiples rows of table: "rangers.locale" */
  update_rangers_locale_many?: Maybe<Array<Maybe<Rangers_Locale_Mutation_Response>>>;
  /** update data of the table: "rangers.pack" */
  update_rangers_pack?: Maybe<Rangers_Pack_Mutation_Response>;
  /** update single row of the table: "rangers.pack" */
  update_rangers_pack_by_pk?: Maybe<Rangers_Pack>;
  /** update multiples rows of table: "rangers.pack" */
  update_rangers_pack_many?: Maybe<Array<Maybe<Rangers_Pack_Mutation_Response>>>;
  /** update data of the table: "rangers.pack_text" */
  update_rangers_pack_text?: Maybe<Rangers_Pack_Text_Mutation_Response>;
  /** update single row of the table: "rangers.pack_text" */
  update_rangers_pack_text_by_pk?: Maybe<Rangers_Pack_Text>;
  /** update multiples rows of table: "rangers.pack_text" */
  update_rangers_pack_text_many?: Maybe<Array<Maybe<Rangers_Pack_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.search_deck" */
  update_rangers_search_deck?: Maybe<Rangers_Search_Deck_Mutation_Response>;
  /** update multiples rows of table: "rangers.search_deck" */
  update_rangers_search_deck_many?: Maybe<Array<Maybe<Rangers_Search_Deck_Mutation_Response>>>;
  /** update data of the table: "rangers.set" */
  update_rangers_set?: Maybe<Rangers_Set_Mutation_Response>;
  /** update single row of the table: "rangers.set" */
  update_rangers_set_by_pk?: Maybe<Rangers_Set>;
  /** update multiples rows of table: "rangers.set" */
  update_rangers_set_many?: Maybe<Array<Maybe<Rangers_Set_Mutation_Response>>>;
  /** update data of the table: "rangers.set_text" */
  update_rangers_set_text?: Maybe<Rangers_Set_Text_Mutation_Response>;
  /** update single row of the table: "rangers.set_text" */
  update_rangers_set_text_by_pk?: Maybe<Rangers_Set_Text>;
  /** update multiples rows of table: "rangers.set_text" */
  update_rangers_set_text_many?: Maybe<Array<Maybe<Rangers_Set_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.set_type" */
  update_rangers_set_type?: Maybe<Rangers_Set_Type_Mutation_Response>;
  /** update single row of the table: "rangers.set_type" */
  update_rangers_set_type_by_pk?: Maybe<Rangers_Set_Type>;
  /** update multiples rows of table: "rangers.set_type" */
  update_rangers_set_type_many?: Maybe<Array<Maybe<Rangers_Set_Type_Mutation_Response>>>;
  /** update data of the table: "rangers.set_type_text" */
  update_rangers_set_type_text?: Maybe<Rangers_Set_Type_Text_Mutation_Response>;
  /** update single row of the table: "rangers.set_type_text" */
  update_rangers_set_type_text_by_pk?: Maybe<Rangers_Set_Type_Text>;
  /** update multiples rows of table: "rangers.set_type_text" */
  update_rangers_set_type_text_many?: Maybe<Array<Maybe<Rangers_Set_Type_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.subset" */
  update_rangers_subset?: Maybe<Rangers_Subset_Mutation_Response>;
  /** update single row of the table: "rangers.subset" */
  update_rangers_subset_by_pk?: Maybe<Rangers_Subset>;
  /** update multiples rows of table: "rangers.subset" */
  update_rangers_subset_many?: Maybe<Array<Maybe<Rangers_Subset_Mutation_Response>>>;
  /** update data of the table: "rangers.subset_text" */
  update_rangers_subset_text?: Maybe<Rangers_Subset_Text_Mutation_Response>;
  /** update single row of the table: "rangers.subset_text" */
  update_rangers_subset_text_by_pk?: Maybe<Rangers_Subset_Text>;
  /** update multiples rows of table: "rangers.subset_text" */
  update_rangers_subset_text_many?: Maybe<Array<Maybe<Rangers_Subset_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.taboo_set" */
  update_rangers_taboo_set?: Maybe<Rangers_Taboo_Set_Mutation_Response>;
  /** update single row of the table: "rangers.taboo_set" */
  update_rangers_taboo_set_by_pk?: Maybe<Rangers_Taboo_Set>;
  /** update multiples rows of table: "rangers.taboo_set" */
  update_rangers_taboo_set_many?: Maybe<Array<Maybe<Rangers_Taboo_Set_Mutation_Response>>>;
  /** update data of the table: "rangers.taboo_set_text" */
  update_rangers_taboo_set_text?: Maybe<Rangers_Taboo_Set_Text_Mutation_Response>;
  /** update single row of the table: "rangers.taboo_set_text" */
  update_rangers_taboo_set_text_by_pk?: Maybe<Rangers_Taboo_Set_Text>;
  /** update multiples rows of table: "rangers.taboo_set_text" */
  update_rangers_taboo_set_text_many?: Maybe<Array<Maybe<Rangers_Taboo_Set_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.token" */
  update_rangers_token?: Maybe<Rangers_Token_Mutation_Response>;
  /** update single row of the table: "rangers.token" */
  update_rangers_token_by_pk?: Maybe<Rangers_Token>;
  /** update multiples rows of table: "rangers.token" */
  update_rangers_token_many?: Maybe<Array<Maybe<Rangers_Token_Mutation_Response>>>;
  /** update data of the table: "rangers.token_text" */
  update_rangers_token_text?: Maybe<Rangers_Token_Text_Mutation_Response>;
  /** update single row of the table: "rangers.token_text" */
  update_rangers_token_text_by_pk?: Maybe<Rangers_Token_Text>;
  /** update multiples rows of table: "rangers.token_text" */
  update_rangers_token_text_many?: Maybe<Array<Maybe<Rangers_Token_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.type" */
  update_rangers_type?: Maybe<Rangers_Type_Mutation_Response>;
  /** update single row of the table: "rangers.type" */
  update_rangers_type_by_pk?: Maybe<Rangers_Type>;
  /** update multiples rows of table: "rangers.type" */
  update_rangers_type_many?: Maybe<Array<Maybe<Rangers_Type_Mutation_Response>>>;
  /** update data of the table: "rangers.type_text" */
  update_rangers_type_text?: Maybe<Rangers_Type_Text_Mutation_Response>;
  /** update single row of the table: "rangers.type_text" */
  update_rangers_type_text_by_pk?: Maybe<Rangers_Type_Text>;
  /** update multiples rows of table: "rangers.type_text" */
  update_rangers_type_text_many?: Maybe<Array<Maybe<Rangers_Type_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.user_friends" */
  update_rangers_user_friends?: Maybe<Rangers_User_Friends_Mutation_Response>;
  /** update multiples rows of table: "rangers.user_friends" */
  update_rangers_user_friends_many?: Maybe<Array<Maybe<Rangers_User_Friends_Mutation_Response>>>;
  /** update data of the table: "rangers.user_received_friend_requests" */
  update_rangers_user_received_friend_requests?: Maybe<Rangers_User_Received_Friend_Requests_Mutation_Response>;
  /** update multiples rows of table: "rangers.user_received_friend_requests" */
  update_rangers_user_received_friend_requests_many?: Maybe<Array<Maybe<Rangers_User_Received_Friend_Requests_Mutation_Response>>>;
  /** update data of the table: "rangers.user_role" */
  update_rangers_user_role?: Maybe<Rangers_User_Role_Mutation_Response>;
  /** update single row of the table: "rangers.user_role" */
  update_rangers_user_role_by_pk?: Maybe<Rangers_User_Role>;
  /** update multiples rows of table: "rangers.user_role" */
  update_rangers_user_role_many?: Maybe<Array<Maybe<Rangers_User_Role_Mutation_Response>>>;
  /** update data of the table: "rangers.user_sent_friend_requests" */
  update_rangers_user_sent_friend_requests?: Maybe<Rangers_User_Sent_Friend_Requests_Mutation_Response>;
  /** update multiples rows of table: "rangers.user_sent_friend_requests" */
  update_rangers_user_sent_friend_requests_many?: Maybe<Array<Maybe<Rangers_User_Sent_Friend_Requests_Mutation_Response>>>;
  /** update data of the table: "rangers.user_settings" */
  update_rangers_user_settings?: Maybe<Rangers_User_Settings_Mutation_Response>;
  /** update single row of the table: "rangers.user_settings" */
  update_rangers_user_settings_by_pk?: Maybe<Rangers_User_Settings>;
  /** update multiples rows of table: "rangers.user_settings" */
  update_rangers_user_settings_many?: Maybe<Array<Maybe<Rangers_User_Settings_Mutation_Response>>>;
  /** update data of the table: "rangers.users" */
  update_rangers_users?: Maybe<Rangers_Users_Mutation_Response>;
  /** update single row of the table: "rangers.users" */
  update_rangers_users_by_pk?: Maybe<Rangers_Users>;
  /** update multiples rows of table: "rangers.users" */
  update_rangers_users_many?: Maybe<Array<Maybe<Rangers_Users_Mutation_Response>>>;
  /** update data of the table: "taboo_set" */
  update_taboo_set?: Maybe<Taboo_Set_Mutation_Response>;
  /** update single row of the table: "taboo_set" */
  update_taboo_set_by_pk?: Maybe<Taboo_Set>;
  /** update multiples rows of table: "taboo_set" */
  update_taboo_set_many?: Maybe<Array<Maybe<Taboo_Set_Mutation_Response>>>;
  /** update data of the table: "user_campaigns" */
  update_user_campaigns?: Maybe<User_Campaigns_Mutation_Response>;
  /** update multiples rows of table: "user_campaigns" */
  update_user_campaigns_many?: Maybe<Array<Maybe<User_Campaigns_Mutation_Response>>>;
  /** update data of the table: "user_flag" */
  update_user_flag?: Maybe<User_Flag_Mutation_Response>;
  /** update single row of the table: "user_flag" */
  update_user_flag_by_pk?: Maybe<User_Flag>;
  /** update multiples rows of table: "user_flag" */
  update_user_flag_many?: Maybe<Array<Maybe<User_Flag_Mutation_Response>>>;
  /** update data of the table: "user_flag_type" */
  update_user_flag_type?: Maybe<User_Flag_Type_Mutation_Response>;
  /** update single row of the table: "user_flag_type" */
  update_user_flag_type_by_pk?: Maybe<User_Flag_Type>;
  /** update multiples rows of table: "user_flag_type" */
  update_user_flag_type_many?: Maybe<Array<Maybe<User_Flag_Type_Mutation_Response>>>;
  /** update data of the table: "user_friends" */
  update_user_friends?: Maybe<User_Friends_Mutation_Response>;
  /** update multiples rows of table: "user_friends" */
  update_user_friends_many?: Maybe<Array<Maybe<User_Friends_Mutation_Response>>>;
  /** update data of the table: "user_received_friend_requests" */
  update_user_received_friend_requests?: Maybe<User_Received_Friend_Requests_Mutation_Response>;
  /** update multiples rows of table: "user_received_friend_requests" */
  update_user_received_friend_requests_many?: Maybe<Array<Maybe<User_Received_Friend_Requests_Mutation_Response>>>;
  /** update data of the table: "user_sent_friend_requests" */
  update_user_sent_friend_requests?: Maybe<User_Sent_Friend_Requests_Mutation_Response>;
  /** update multiples rows of table: "user_sent_friend_requests" */
  update_user_sent_friend_requests_many?: Maybe<Array<Maybe<User_Sent_Friend_Requests_Mutation_Response>>>;
  /** update data of the table: "user_settings" */
  update_user_settings?: Maybe<User_Settings_Mutation_Response>;
  /** update single row of the table: "user_settings" */
  update_user_settings_by_pk?: Maybe<User_Settings>;
  /** update multiples rows of table: "user_settings" */
  update_user_settings_many?: Maybe<Array<Maybe<User_Settings_Mutation_Response>>>;
  /** update data of the table: "users" */
  update_users?: Maybe<Users_Mutation_Response>;
  /** update single row of the table: "users" */
  update_users_by_pk?: Maybe<Users>;
  /** update multiples rows of table: "users" */
  update_users_many?: Maybe<Array<Maybe<Users_Mutation_Response>>>;
  upgradeArkhamDbDeck?: Maybe<UpgradeDeckOutput>;
  uploadLocalCampaignDeck?: Maybe<UploadLocalCampaignDeckOutput>;
};


/** mutation root */
export type Mutation_RootApiDeleteArkhamDbDeckArgs = {
  args: DeleteDeckInput;
};


/** mutation root */
export type Mutation_RootConquest_Publish_DeckArgs = {
  args: Conquest_Publish_Deck_Args;
  distinct_on?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootCreateArkhamDbDeckArgs = {
  args: CreateDeckInput;
};


/** mutation root */
export type Mutation_RootCreateCampaignArgs = {
  args: CreateCampaignInput;
};


/** mutation root */
export type Mutation_RootDeleteCampaignArgs = {
  args: DeleteCampaignInput;
};


/** mutation root */
export type Mutation_RootDelete_All_CardArgs = {
  where: All_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_All_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_All_Card_TextArgs = {
  where: All_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_All_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_All_Card_UpdatedArgs = {
  where: All_Card_Updated_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_All_Card_Updated_By_PkArgs = {
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_All_Card_Updated_By_VersionArgs = {
  where: All_Card_Updated_By_Version_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_All_Card_Updated_By_Version_By_PkArgs = {
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Arkhamdb_AuthArgs = {
  where: Arkhamdb_Auth_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arkhamdb_Auth_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Arkhamdb_DeckArgs = {
  where: Arkhamdb_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arkhamdb_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Base_DecksArgs = {
  where: Base_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_CampaignArgs = {
  where: Campaign_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_AccessArgs = {
  where: Campaign_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_Access_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Campaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Campaign_DeckArgs = {
  where: Campaign_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Campaign_DifficultyArgs = {
  where: Campaign_Difficulty_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_Difficulty_By_PkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Campaign_GuideArgs = {
  where: Campaign_Guide_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_InvestigatorArgs = {
  where: Campaign_Investigator_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_Investigator_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_CardArgs = {
  where: Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_CycleArgs = {
  where: Card_Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Cycle_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_Encounter_SetArgs = {
  where: Card_Encounter_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Encounter_Set_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_PackArgs = {
  where: Card_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Pack_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_Subtype_NameArgs = {
  where: Card_Subtype_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Subtype_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_TextArgs = {
  where: Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_Type_CodeArgs = {
  where: Card_Type_Code_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Type_Code_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_Type_NameArgs = {
  where: Card_Type_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Type_Name_By_PkArgs = {
  code: Card_Type_Code_Enum;
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Chaos_Bag_ResultArgs = {
  where: Chaos_Bag_Result_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chaos_Bag_Result_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Chaos_Bag_Tarot_ModeArgs = {
  where: Chaos_Bag_Tarot_Mode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chaos_Bag_Tarot_Mode_By_PkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_CardArgs = {
  where: Conquest_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Card_TextArgs = {
  where: Conquest_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_CommentArgs = {
  where: Conquest_Comment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_CycleArgs = {
  where: Conquest_Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Cycle_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Cycle_TextArgs = {
  where: Conquest_Cycle_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Cycle_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_DeckArgs = {
  where: Conquest_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Deck_CopyArgs = {
  where: Conquest_Deck_Copy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Deck_LikeArgs = {
  where: Conquest_Deck_Like_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_FactionArgs = {
  where: Conquest_Faction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Faction_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Faction_TextArgs = {
  where: Conquest_Faction_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Faction_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_LoyaltyArgs = {
  where: Conquest_Loyalty_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Loyalty_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Loyalty_TextArgs = {
  where: Conquest_Loyalty_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Loyalty_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_PackArgs = {
  where: Conquest_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Pack_TextArgs = {
  where: Conquest_Pack_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_TypeArgs = {
  where: Conquest_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Type_TextArgs = {
  where: Conquest_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_User_RoleArgs = {
  where: Conquest_User_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_User_SettingsArgs = {
  where: Conquest_User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_UsersArgs = {
  where: Conquest_Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_CycleArgs = {
  where: Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Cycle_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Cycle_NameArgs = {
  where: Cycle_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Cycle_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Faction_NameArgs = {
  where: Faction_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Faction_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_FaqArgs = {
  where: Faq_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Faq_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Faq_TextArgs = {
  where: Faq_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Faq_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Friend_StatusArgs = {
  where: Friend_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Friend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Friend_Status_TypeArgs = {
  where: Friend_Status_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Friend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Full_CardArgs = {
  where: Full_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Full_Card_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Full_Card_TextArgs = {
  where: Full_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Full_Card_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_GenderArgs = {
  where: Gender_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Gender_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Guide_AchievementArgs = {
  where: Guide_Achievement_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Guide_Achievement_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Guide_InputArgs = {
  where: Guide_Input_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Guide_Input_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Investigator_DataArgs = {
  where: Investigator_Data_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Investigator_Data_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Latest_DecksArgs = {
  where: Latest_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Local_DecksArgs = {
  where: Local_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_PackArgs = {
  where: Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Pack_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Pack_NameArgs = {
  where: Pack_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Pack_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_AreaArgs = {
  where: Rangers_Area_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Area_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Area_TextArgs = {
  where: Rangers_Area_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Area_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_AspectArgs = {
  where: Rangers_Aspect_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Aspect_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Aspect_TextArgs = {
  where: Rangers_Aspect_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Aspect_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_CampaignArgs = {
  where: Rangers_Campaign_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Campaign_AccessArgs = {
  where: Rangers_Campaign_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Campaign_Access_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Campaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_CardArgs = {
  where: Rangers_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Card_TextArgs = {
  where: Rangers_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_CommentArgs = {
  where: Rangers_Comment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_DeckArgs = {
  where: Rangers_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_CopyArgs = {
  where: Rangers_Deck_Copy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_LikeArgs = {
  where: Rangers_Deck_Like_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_Like_CountArgs = {
  where: Rangers_Deck_Like_Count_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_Like_Count_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Faq_EntryArgs = {
  where: Rangers_Faq_Entry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Faq_Entry_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Friend_StatusArgs = {
  where: Rangers_Friend_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Friend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Friend_Status_TypeArgs = {
  where: Rangers_Friend_Status_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Friend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Latest_DeckArgs = {
  where: Rangers_Latest_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_LocaleArgs = {
  where: Rangers_Locale_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Locale_By_PkArgs = {
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_PackArgs = {
  where: Rangers_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Pack_TextArgs = {
  where: Rangers_Pack_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Search_DeckArgs = {
  where: Rangers_Search_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_SetArgs = {
  where: Rangers_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_TextArgs = {
  where: Rangers_Set_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_TypeArgs = {
  where: Rangers_Set_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_Type_TextArgs = {
  where: Rangers_Set_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_SubsetArgs = {
  where: Rangers_Subset_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Subset_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Subset_TextArgs = {
  where: Rangers_Subset_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Subset_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Taboo_SetArgs = {
  where: Rangers_Taboo_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Taboo_Set_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Taboo_Set_TextArgs = {
  where: Rangers_Taboo_Set_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Taboo_Set_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_TokenArgs = {
  where: Rangers_Token_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Token_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Token_TextArgs = {
  where: Rangers_Token_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Token_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_TypeArgs = {
  where: Rangers_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Type_TextArgs = {
  where: Rangers_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_FriendsArgs = {
  where: Rangers_User_Friends_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_Received_Friend_RequestsArgs = {
  where: Rangers_User_Received_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_RoleArgs = {
  where: Rangers_User_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_Sent_Friend_RequestsArgs = {
  where: Rangers_User_Sent_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_SettingsArgs = {
  where: Rangers_User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_UsersArgs = {
  where: Rangers_Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Taboo_SetArgs = {
  where: Taboo_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Taboo_Set_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_CampaignsArgs = {
  where: User_Campaigns_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_FlagArgs = {
  where: User_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Flag_By_PkArgs = {
  flag: User_Flag_Type_Enum;
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_Flag_TypeArgs = {
  where: User_Flag_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Flag_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_FriendsArgs = {
  where: User_Friends_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Received_Friend_RequestsArgs = {
  where: User_Received_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Sent_Friend_RequestsArgs = {
  where: User_Sent_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_SettingsArgs = {
  where: User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UsersArgs = {
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootEditCampaignAccessArgs = {
  args: EditCampaignAccessInput;
};


/** mutation root */
export type Mutation_RootInsert_All_CardArgs = {
  objects: Array<All_Card_Insert_Input>;
  on_conflict?: InputMaybe<All_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_OneArgs = {
  object: All_Card_Insert_Input;
  on_conflict?: InputMaybe<All_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_TextArgs = {
  objects: Array<All_Card_Text_Insert_Input>;
  on_conflict?: InputMaybe<All_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_Text_OneArgs = {
  object: All_Card_Text_Insert_Input;
  on_conflict?: InputMaybe<All_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_UpdatedArgs = {
  objects: Array<All_Card_Updated_Insert_Input>;
  on_conflict?: InputMaybe<All_Card_Updated_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_Updated_By_VersionArgs = {
  objects: Array<All_Card_Updated_By_Version_Insert_Input>;
  on_conflict?: InputMaybe<All_Card_Updated_By_Version_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_Updated_By_Version_OneArgs = {
  object: All_Card_Updated_By_Version_Insert_Input;
  on_conflict?: InputMaybe<All_Card_Updated_By_Version_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_Updated_OneArgs = {
  object: All_Card_Updated_Insert_Input;
  on_conflict?: InputMaybe<All_Card_Updated_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arkhamdb_AuthArgs = {
  objects: Array<Arkhamdb_Auth_Insert_Input>;
  on_conflict?: InputMaybe<Arkhamdb_Auth_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arkhamdb_Auth_OneArgs = {
  object: Arkhamdb_Auth_Insert_Input;
  on_conflict?: InputMaybe<Arkhamdb_Auth_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arkhamdb_DeckArgs = {
  objects: Array<Arkhamdb_Deck_Insert_Input>;
  on_conflict?: InputMaybe<Arkhamdb_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arkhamdb_Deck_OneArgs = {
  object: Arkhamdb_Deck_Insert_Input;
  on_conflict?: InputMaybe<Arkhamdb_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Base_DecksArgs = {
  objects: Array<Base_Decks_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Base_Decks_OneArgs = {
  object: Base_Decks_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_CampaignArgs = {
  objects: Array<Campaign_Insert_Input>;
  on_conflict?: InputMaybe<Campaign_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_AccessArgs = {
  objects: Array<Campaign_Access_Insert_Input>;
  on_conflict?: InputMaybe<Campaign_Access_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_Access_OneArgs = {
  object: Campaign_Access_Insert_Input;
  on_conflict?: InputMaybe<Campaign_Access_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_DeckArgs = {
  objects: Array<Campaign_Deck_Insert_Input>;
  on_conflict?: InputMaybe<Campaign_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_Deck_OneArgs = {
  object: Campaign_Deck_Insert_Input;
  on_conflict?: InputMaybe<Campaign_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_DifficultyArgs = {
  objects: Array<Campaign_Difficulty_Insert_Input>;
  on_conflict?: InputMaybe<Campaign_Difficulty_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_Difficulty_OneArgs = {
  object: Campaign_Difficulty_Insert_Input;
  on_conflict?: InputMaybe<Campaign_Difficulty_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_GuideArgs = {
  objects: Array<Campaign_Guide_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_Guide_OneArgs = {
  object: Campaign_Guide_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_InvestigatorArgs = {
  objects: Array<Campaign_Investigator_Insert_Input>;
  on_conflict?: InputMaybe<Campaign_Investigator_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_Investigator_OneArgs = {
  object: Campaign_Investigator_Insert_Input;
  on_conflict?: InputMaybe<Campaign_Investigator_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_OneArgs = {
  object: Campaign_Insert_Input;
  on_conflict?: InputMaybe<Campaign_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CardArgs = {
  objects: Array<Card_Insert_Input>;
  on_conflict?: InputMaybe<Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_CycleArgs = {
  objects: Array<Card_Cycle_Insert_Input>;
  on_conflict?: InputMaybe<Card_Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Cycle_OneArgs = {
  object: Card_Cycle_Insert_Input;
  on_conflict?: InputMaybe<Card_Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Encounter_SetArgs = {
  objects: Array<Card_Encounter_Set_Insert_Input>;
  on_conflict?: InputMaybe<Card_Encounter_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Encounter_Set_OneArgs = {
  object: Card_Encounter_Set_Insert_Input;
  on_conflict?: InputMaybe<Card_Encounter_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_OneArgs = {
  object: Card_Insert_Input;
  on_conflict?: InputMaybe<Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_PackArgs = {
  objects: Array<Card_Pack_Insert_Input>;
  on_conflict?: InputMaybe<Card_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Pack_OneArgs = {
  object: Card_Pack_Insert_Input;
  on_conflict?: InputMaybe<Card_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Subtype_NameArgs = {
  objects: Array<Card_Subtype_Name_Insert_Input>;
  on_conflict?: InputMaybe<Card_Subtype_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Subtype_Name_OneArgs = {
  object: Card_Subtype_Name_Insert_Input;
  on_conflict?: InputMaybe<Card_Subtype_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_TextArgs = {
  objects: Array<Card_Text_Insert_Input>;
  on_conflict?: InputMaybe<Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Text_OneArgs = {
  object: Card_Text_Insert_Input;
  on_conflict?: InputMaybe<Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Type_CodeArgs = {
  objects: Array<Card_Type_Code_Insert_Input>;
  on_conflict?: InputMaybe<Card_Type_Code_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Type_Code_OneArgs = {
  object: Card_Type_Code_Insert_Input;
  on_conflict?: InputMaybe<Card_Type_Code_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Type_NameArgs = {
  objects: Array<Card_Type_Name_Insert_Input>;
  on_conflict?: InputMaybe<Card_Type_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Type_Name_OneArgs = {
  object: Card_Type_Name_Insert_Input;
  on_conflict?: InputMaybe<Card_Type_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chaos_Bag_ResultArgs = {
  objects: Array<Chaos_Bag_Result_Insert_Input>;
  on_conflict?: InputMaybe<Chaos_Bag_Result_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chaos_Bag_Result_OneArgs = {
  object: Chaos_Bag_Result_Insert_Input;
  on_conflict?: InputMaybe<Chaos_Bag_Result_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chaos_Bag_Tarot_ModeArgs = {
  objects: Array<Chaos_Bag_Tarot_Mode_Insert_Input>;
  on_conflict?: InputMaybe<Chaos_Bag_Tarot_Mode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chaos_Bag_Tarot_Mode_OneArgs = {
  object: Chaos_Bag_Tarot_Mode_Insert_Input;
  on_conflict?: InputMaybe<Chaos_Bag_Tarot_Mode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_CardArgs = {
  objects: Array<Conquest_Card_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Card_OneArgs = {
  object: Conquest_Card_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Card_TextArgs = {
  objects: Array<Conquest_Card_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Card_Text_OneArgs = {
  object: Conquest_Card_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_CommentArgs = {
  objects: Array<Conquest_Comment_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Comment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Comment_OneArgs = {
  object: Conquest_Comment_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Comment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_CycleArgs = {
  objects: Array<Conquest_Cycle_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Cycle_OneArgs = {
  object: Conquest_Cycle_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Cycle_TextArgs = {
  objects: Array<Conquest_Cycle_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Cycle_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Cycle_Text_OneArgs = {
  object: Conquest_Cycle_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Cycle_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_DeckArgs = {
  objects: Array<Conquest_Deck_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Deck_CopyArgs = {
  objects: Array<Conquest_Deck_Copy_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Deck_Copy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Deck_Copy_OneArgs = {
  object: Conquest_Deck_Copy_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Deck_Copy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Deck_LikeArgs = {
  objects: Array<Conquest_Deck_Like_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Deck_Like_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Deck_Like_OneArgs = {
  object: Conquest_Deck_Like_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Deck_Like_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Deck_OneArgs = {
  object: Conquest_Deck_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_FactionArgs = {
  objects: Array<Conquest_Faction_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Faction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Faction_OneArgs = {
  object: Conquest_Faction_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Faction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Faction_TextArgs = {
  objects: Array<Conquest_Faction_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Faction_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Faction_Text_OneArgs = {
  object: Conquest_Faction_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Faction_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_LoyaltyArgs = {
  objects: Array<Conquest_Loyalty_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Loyalty_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Loyalty_OneArgs = {
  object: Conquest_Loyalty_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Loyalty_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Loyalty_TextArgs = {
  objects: Array<Conquest_Loyalty_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Loyalty_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Loyalty_Text_OneArgs = {
  object: Conquest_Loyalty_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Loyalty_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_PackArgs = {
  objects: Array<Conquest_Pack_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Pack_OneArgs = {
  object: Conquest_Pack_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Pack_TextArgs = {
  objects: Array<Conquest_Pack_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Pack_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Pack_Text_OneArgs = {
  object: Conquest_Pack_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Pack_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_TypeArgs = {
  objects: Array<Conquest_Type_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Type_OneArgs = {
  object: Conquest_Type_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Type_TextArgs = {
  objects: Array<Conquest_Type_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Type_Text_OneArgs = {
  object: Conquest_Type_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_User_RoleArgs = {
  objects: Array<Conquest_User_Role_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_User_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_User_Role_OneArgs = {
  object: Conquest_User_Role_Insert_Input;
  on_conflict?: InputMaybe<Conquest_User_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_User_SettingsArgs = {
  objects: Array<Conquest_User_Settings_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_User_Settings_OneArgs = {
  object: Conquest_User_Settings_Insert_Input;
  on_conflict?: InputMaybe<Conquest_User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_UsersArgs = {
  objects: Array<Conquest_Users_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Users_OneArgs = {
  object: Conquest_Users_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CycleArgs = {
  objects: Array<Cycle_Insert_Input>;
  on_conflict?: InputMaybe<Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Cycle_NameArgs = {
  objects: Array<Cycle_Name_Insert_Input>;
  on_conflict?: InputMaybe<Cycle_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Cycle_Name_OneArgs = {
  object: Cycle_Name_Insert_Input;
  on_conflict?: InputMaybe<Cycle_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Cycle_OneArgs = {
  object: Cycle_Insert_Input;
  on_conflict?: InputMaybe<Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faction_NameArgs = {
  objects: Array<Faction_Name_Insert_Input>;
  on_conflict?: InputMaybe<Faction_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faction_Name_OneArgs = {
  object: Faction_Name_Insert_Input;
  on_conflict?: InputMaybe<Faction_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_FaqArgs = {
  objects: Array<Faq_Insert_Input>;
  on_conflict?: InputMaybe<Faq_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faq_OneArgs = {
  object: Faq_Insert_Input;
  on_conflict?: InputMaybe<Faq_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faq_TextArgs = {
  objects: Array<Faq_Text_Insert_Input>;
  on_conflict?: InputMaybe<Faq_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faq_Text_OneArgs = {
  object: Faq_Text_Insert_Input;
  on_conflict?: InputMaybe<Faq_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Friend_StatusArgs = {
  objects: Array<Friend_Status_Insert_Input>;
  on_conflict?: InputMaybe<Friend_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Friend_Status_OneArgs = {
  object: Friend_Status_Insert_Input;
  on_conflict?: InputMaybe<Friend_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Friend_Status_TypeArgs = {
  objects: Array<Friend_Status_Type_Insert_Input>;
  on_conflict?: InputMaybe<Friend_Status_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Friend_Status_Type_OneArgs = {
  object: Friend_Status_Type_Insert_Input;
  on_conflict?: InputMaybe<Friend_Status_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Full_CardArgs = {
  objects: Array<Full_Card_Insert_Input>;
  on_conflict?: InputMaybe<Full_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Full_Card_OneArgs = {
  object: Full_Card_Insert_Input;
  on_conflict?: InputMaybe<Full_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Full_Card_TextArgs = {
  objects: Array<Full_Card_Text_Insert_Input>;
  on_conflict?: InputMaybe<Full_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Full_Card_Text_OneArgs = {
  object: Full_Card_Text_Insert_Input;
  on_conflict?: InputMaybe<Full_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GenderArgs = {
  objects: Array<Gender_Insert_Input>;
  on_conflict?: InputMaybe<Gender_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Gender_OneArgs = {
  object: Gender_Insert_Input;
  on_conflict?: InputMaybe<Gender_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Guide_AchievementArgs = {
  objects: Array<Guide_Achievement_Insert_Input>;
  on_conflict?: InputMaybe<Guide_Achievement_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Guide_Achievement_OneArgs = {
  object: Guide_Achievement_Insert_Input;
  on_conflict?: InputMaybe<Guide_Achievement_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Guide_InputArgs = {
  objects: Array<Guide_Input_Insert_Input>;
  on_conflict?: InputMaybe<Guide_Input_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Guide_Input_OneArgs = {
  object: Guide_Input_Insert_Input;
  on_conflict?: InputMaybe<Guide_Input_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Investigator_DataArgs = {
  objects: Array<Investigator_Data_Insert_Input>;
  on_conflict?: InputMaybe<Investigator_Data_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Investigator_Data_OneArgs = {
  object: Investigator_Data_Insert_Input;
  on_conflict?: InputMaybe<Investigator_Data_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Latest_DecksArgs = {
  objects: Array<Latest_Decks_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Latest_Decks_OneArgs = {
  object: Latest_Decks_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Local_DecksArgs = {
  objects: Array<Local_Decks_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Local_Decks_OneArgs = {
  object: Local_Decks_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_PackArgs = {
  objects: Array<Pack_Insert_Input>;
  on_conflict?: InputMaybe<Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pack_NameArgs = {
  objects: Array<Pack_Name_Insert_Input>;
  on_conflict?: InputMaybe<Pack_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pack_Name_OneArgs = {
  object: Pack_Name_Insert_Input;
  on_conflict?: InputMaybe<Pack_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pack_OneArgs = {
  object: Pack_Insert_Input;
  on_conflict?: InputMaybe<Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_AreaArgs = {
  objects: Array<Rangers_Area_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Area_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Area_OneArgs = {
  object: Rangers_Area_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Area_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Area_TextArgs = {
  objects: Array<Rangers_Area_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Area_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Area_Text_OneArgs = {
  object: Rangers_Area_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Area_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_AspectArgs = {
  objects: Array<Rangers_Aspect_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Aspect_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Aspect_OneArgs = {
  object: Rangers_Aspect_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Aspect_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Aspect_TextArgs = {
  objects: Array<Rangers_Aspect_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Aspect_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Aspect_Text_OneArgs = {
  object: Rangers_Aspect_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Aspect_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_CampaignArgs = {
  objects: Array<Rangers_Campaign_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Campaign_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Campaign_AccessArgs = {
  objects: Array<Rangers_Campaign_Access_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Campaign_Access_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Campaign_Access_OneArgs = {
  object: Rangers_Campaign_Access_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Campaign_Access_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Campaign_OneArgs = {
  object: Rangers_Campaign_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Campaign_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_CardArgs = {
  objects: Array<Rangers_Card_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Card_OneArgs = {
  object: Rangers_Card_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Card_TextArgs = {
  objects: Array<Rangers_Card_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Card_Text_OneArgs = {
  object: Rangers_Card_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_CommentArgs = {
  objects: Array<Rangers_Comment_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Comment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Comment_OneArgs = {
  object: Rangers_Comment_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Comment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_DeckArgs = {
  objects: Array<Rangers_Deck_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_CopyArgs = {
  objects: Array<Rangers_Deck_Copy_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Deck_Copy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_Copy_OneArgs = {
  object: Rangers_Deck_Copy_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Deck_Copy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_LikeArgs = {
  objects: Array<Rangers_Deck_Like_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Deck_Like_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_Like_CountArgs = {
  objects: Array<Rangers_Deck_Like_Count_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Deck_Like_Count_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_Like_Count_OneArgs = {
  object: Rangers_Deck_Like_Count_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Deck_Like_Count_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_Like_OneArgs = {
  object: Rangers_Deck_Like_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Deck_Like_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_OneArgs = {
  object: Rangers_Deck_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Faq_EntryArgs = {
  objects: Array<Rangers_Faq_Entry_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Faq_Entry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Faq_Entry_OneArgs = {
  object: Rangers_Faq_Entry_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Faq_Entry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Friend_StatusArgs = {
  objects: Array<Rangers_Friend_Status_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Friend_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Friend_Status_OneArgs = {
  object: Rangers_Friend_Status_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Friend_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Friend_Status_TypeArgs = {
  objects: Array<Rangers_Friend_Status_Type_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Friend_Status_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Friend_Status_Type_OneArgs = {
  object: Rangers_Friend_Status_Type_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Friend_Status_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Latest_DeckArgs = {
  objects: Array<Rangers_Latest_Deck_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Latest_Deck_OneArgs = {
  object: Rangers_Latest_Deck_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_LocaleArgs = {
  objects: Array<Rangers_Locale_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Locale_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Locale_OneArgs = {
  object: Rangers_Locale_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Locale_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_PackArgs = {
  objects: Array<Rangers_Pack_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Pack_OneArgs = {
  object: Rangers_Pack_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Pack_TextArgs = {
  objects: Array<Rangers_Pack_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Pack_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Pack_Text_OneArgs = {
  object: Rangers_Pack_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Pack_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Search_DeckArgs = {
  objects: Array<Rangers_Search_Deck_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Search_Deck_OneArgs = {
  object: Rangers_Search_Deck_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_SetArgs = {
  objects: Array<Rangers_Set_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_OneArgs = {
  object: Rangers_Set_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_TextArgs = {
  objects: Array<Rangers_Set_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Set_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_Text_OneArgs = {
  object: Rangers_Set_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Set_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_TypeArgs = {
  objects: Array<Rangers_Set_Type_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Set_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_Type_OneArgs = {
  object: Rangers_Set_Type_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Set_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_Type_TextArgs = {
  objects: Array<Rangers_Set_Type_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Set_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_Type_Text_OneArgs = {
  object: Rangers_Set_Type_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Set_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_SubsetArgs = {
  objects: Array<Rangers_Subset_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Subset_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Subset_OneArgs = {
  object: Rangers_Subset_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Subset_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Subset_TextArgs = {
  objects: Array<Rangers_Subset_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Subset_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Subset_Text_OneArgs = {
  object: Rangers_Subset_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Subset_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Taboo_SetArgs = {
  objects: Array<Rangers_Taboo_Set_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Taboo_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Taboo_Set_OneArgs = {
  object: Rangers_Taboo_Set_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Taboo_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Taboo_Set_TextArgs = {
  objects: Array<Rangers_Taboo_Set_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Taboo_Set_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Taboo_Set_Text_OneArgs = {
  object: Rangers_Taboo_Set_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Taboo_Set_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_TokenArgs = {
  objects: Array<Rangers_Token_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Token_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Token_OneArgs = {
  object: Rangers_Token_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Token_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Token_TextArgs = {
  objects: Array<Rangers_Token_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Token_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Token_Text_OneArgs = {
  object: Rangers_Token_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Token_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_TypeArgs = {
  objects: Array<Rangers_Type_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Type_OneArgs = {
  object: Rangers_Type_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Type_TextArgs = {
  objects: Array<Rangers_Type_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Type_Text_OneArgs = {
  object: Rangers_Type_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_FriendsArgs = {
  objects: Array<Rangers_User_Friends_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Friends_OneArgs = {
  object: Rangers_User_Friends_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Received_Friend_RequestsArgs = {
  objects: Array<Rangers_User_Received_Friend_Requests_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Received_Friend_Requests_OneArgs = {
  object: Rangers_User_Received_Friend_Requests_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_RoleArgs = {
  objects: Array<Rangers_User_Role_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_User_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Role_OneArgs = {
  object: Rangers_User_Role_Insert_Input;
  on_conflict?: InputMaybe<Rangers_User_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Sent_Friend_RequestsArgs = {
  objects: Array<Rangers_User_Sent_Friend_Requests_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Sent_Friend_Requests_OneArgs = {
  object: Rangers_User_Sent_Friend_Requests_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_SettingsArgs = {
  objects: Array<Rangers_User_Settings_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Settings_OneArgs = {
  object: Rangers_User_Settings_Insert_Input;
  on_conflict?: InputMaybe<Rangers_User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_UsersArgs = {
  objects: Array<Rangers_Users_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Users_OneArgs = {
  object: Rangers_Users_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Taboo_SetArgs = {
  objects: Array<Taboo_Set_Insert_Input>;
  on_conflict?: InputMaybe<Taboo_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Taboo_Set_OneArgs = {
  object: Taboo_Set_Insert_Input;
  on_conflict?: InputMaybe<Taboo_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_CampaignsArgs = {
  objects: Array<User_Campaigns_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_User_Campaigns_OneArgs = {
  object: User_Campaigns_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_User_FlagArgs = {
  objects: Array<User_Flag_Insert_Input>;
  on_conflict?: InputMaybe<User_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Flag_OneArgs = {
  object: User_Flag_Insert_Input;
  on_conflict?: InputMaybe<User_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Flag_TypeArgs = {
  objects: Array<User_Flag_Type_Insert_Input>;
  on_conflict?: InputMaybe<User_Flag_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Flag_Type_OneArgs = {
  object: User_Flag_Type_Insert_Input;
  on_conflict?: InputMaybe<User_Flag_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_FriendsArgs = {
  objects: Array<User_Friends_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_User_Friends_OneArgs = {
  object: User_Friends_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_User_Received_Friend_RequestsArgs = {
  objects: Array<User_Received_Friend_Requests_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_User_Received_Friend_Requests_OneArgs = {
  object: User_Received_Friend_Requests_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_User_Sent_Friend_RequestsArgs = {
  objects: Array<User_Sent_Friend_Requests_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_User_Sent_Friend_Requests_OneArgs = {
  object: User_Sent_Friend_Requests_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_User_SettingsArgs = {
  objects: Array<User_Settings_Insert_Input>;
  on_conflict?: InputMaybe<User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Settings_OneArgs = {
  object: User_Settings_Insert_Input;
  on_conflict?: InputMaybe<User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsersArgs = {
  objects: Array<Users_Insert_Input>;
  on_conflict?: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Users_OneArgs = {
  object: Users_Insert_Input;
  on_conflict?: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootLoginToArkhamDbArgs = {
  args: LoginInput;
};


/** mutation root */
export type Mutation_RootMigrateLoginToArkhamDbArgs = {
  args: MigrateLoginInput;
};


/** mutation root */
export type Mutation_RootRangers_Publish_DeckArgs = {
  args: Rangers_Publish_Deck_Args;
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRangers_Remove_CampaignArgs = {
  args: Rangers_Remove_Campaign_Args;
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRangers_Remove_Campaign_DeckArgs = {
  args: Rangers_Remove_Campaign_Deck_Args;
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRangers_Set_Campaign_DeckArgs = {
  args: Rangers_Set_Campaign_Deck_Args;
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRangers_Set_HandleArgs = {
  args: Rangers_Set_Handle_Args;
  distinct_on?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Users_Order_By>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRangers_Transfer_CampaignArgs = {
  args: Rangers_Transfer_Campaign_Args;
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRangers_Update_Friend_RequestArgs = {
  args: Rangers_Update_Friend_Request_Args;
  distinct_on?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Users_Order_By>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRangers_Upgrade_DeckArgs = {
  args: Rangers_Upgrade_Deck_Args;
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRefreshArkhamDbDecksArgs = {
  args: RefreshDecksInput;
};


/** mutation root */
export type Mutation_RootUpdateFriendRequestArgs = {
  args: FriendRequestInput;
};


/** mutation root */
export type Mutation_RootUpdateHandleArgs = {
  args: UpdateHandleInput;
};


/** mutation root */
export type Mutation_RootUpdate_All_CardArgs = {
  _append?: InputMaybe<All_Card_Append_Input>;
  _delete_at_path?: InputMaybe<All_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<All_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<All_Card_Delete_Key_Input>;
  _inc?: InputMaybe<All_Card_Inc_Input>;
  _prepend?: InputMaybe<All_Card_Prepend_Input>;
  _set?: InputMaybe<All_Card_Set_Input>;
  where: All_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_By_PkArgs = {
  _append?: InputMaybe<All_Card_Append_Input>;
  _delete_at_path?: InputMaybe<All_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<All_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<All_Card_Delete_Key_Input>;
  _inc?: InputMaybe<All_Card_Inc_Input>;
  _prepend?: InputMaybe<All_Card_Prepend_Input>;
  _set?: InputMaybe<All_Card_Set_Input>;
  pk_columns: All_Card_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_ManyArgs = {
  updates: Array<All_Card_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_TextArgs = {
  _set?: InputMaybe<All_Card_Text_Set_Input>;
  where: All_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Text_By_PkArgs = {
  _set?: InputMaybe<All_Card_Text_Set_Input>;
  pk_columns: All_Card_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Text_ManyArgs = {
  updates: Array<All_Card_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_UpdatedArgs = {
  _inc?: InputMaybe<All_Card_Updated_Inc_Input>;
  _set?: InputMaybe<All_Card_Updated_Set_Input>;
  where: All_Card_Updated_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Updated_By_PkArgs = {
  _inc?: InputMaybe<All_Card_Updated_Inc_Input>;
  _set?: InputMaybe<All_Card_Updated_Set_Input>;
  pk_columns: All_Card_Updated_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Updated_By_VersionArgs = {
  _inc?: InputMaybe<All_Card_Updated_By_Version_Inc_Input>;
  _set?: InputMaybe<All_Card_Updated_By_Version_Set_Input>;
  where: All_Card_Updated_By_Version_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Updated_By_Version_By_PkArgs = {
  _inc?: InputMaybe<All_Card_Updated_By_Version_Inc_Input>;
  _set?: InputMaybe<All_Card_Updated_By_Version_Set_Input>;
  pk_columns: All_Card_Updated_By_Version_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Updated_By_Version_ManyArgs = {
  updates: Array<All_Card_Updated_By_Version_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Updated_ManyArgs = {
  updates: Array<All_Card_Updated_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_AuthArgs = {
  _inc?: InputMaybe<Arkhamdb_Auth_Inc_Input>;
  _set?: InputMaybe<Arkhamdb_Auth_Set_Input>;
  where: Arkhamdb_Auth_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_Auth_By_PkArgs = {
  _inc?: InputMaybe<Arkhamdb_Auth_Inc_Input>;
  _set?: InputMaybe<Arkhamdb_Auth_Set_Input>;
  pk_columns: Arkhamdb_Auth_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_Auth_ManyArgs = {
  updates: Array<Arkhamdb_Auth_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_DeckArgs = {
  _append?: InputMaybe<Arkhamdb_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Arkhamdb_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Arkhamdb_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Arkhamdb_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Arkhamdb_Deck_Inc_Input>;
  _prepend?: InputMaybe<Arkhamdb_Deck_Prepend_Input>;
  _set?: InputMaybe<Arkhamdb_Deck_Set_Input>;
  where: Arkhamdb_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_Deck_By_PkArgs = {
  _append?: InputMaybe<Arkhamdb_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Arkhamdb_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Arkhamdb_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Arkhamdb_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Arkhamdb_Deck_Inc_Input>;
  _prepend?: InputMaybe<Arkhamdb_Deck_Prepend_Input>;
  _set?: InputMaybe<Arkhamdb_Deck_Set_Input>;
  pk_columns: Arkhamdb_Deck_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_Deck_ManyArgs = {
  updates: Array<Arkhamdb_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Base_DecksArgs = {
  _inc?: InputMaybe<Base_Decks_Inc_Input>;
  _set?: InputMaybe<Base_Decks_Set_Input>;
  where: Base_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Base_Decks_ManyArgs = {
  updates: Array<Base_Decks_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CampaignArgs = {
  _append?: InputMaybe<Campaign_Append_Input>;
  _delete_at_path?: InputMaybe<Campaign_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Campaign_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Campaign_Delete_Key_Input>;
  _inc?: InputMaybe<Campaign_Inc_Input>;
  _prepend?: InputMaybe<Campaign_Prepend_Input>;
  _set?: InputMaybe<Campaign_Set_Input>;
  where: Campaign_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_AccessArgs = {
  _inc?: InputMaybe<Campaign_Access_Inc_Input>;
  _set?: InputMaybe<Campaign_Access_Set_Input>;
  where: Campaign_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Access_By_PkArgs = {
  _inc?: InputMaybe<Campaign_Access_Inc_Input>;
  _set?: InputMaybe<Campaign_Access_Set_Input>;
  pk_columns: Campaign_Access_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Access_ManyArgs = {
  updates: Array<Campaign_Access_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_By_PkArgs = {
  _append?: InputMaybe<Campaign_Append_Input>;
  _delete_at_path?: InputMaybe<Campaign_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Campaign_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Campaign_Delete_Key_Input>;
  _inc?: InputMaybe<Campaign_Inc_Input>;
  _prepend?: InputMaybe<Campaign_Prepend_Input>;
  _set?: InputMaybe<Campaign_Set_Input>;
  pk_columns: Campaign_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_DeckArgs = {
  _append?: InputMaybe<Campaign_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Campaign_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Campaign_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Campaign_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Campaign_Deck_Inc_Input>;
  _prepend?: InputMaybe<Campaign_Deck_Prepend_Input>;
  _set?: InputMaybe<Campaign_Deck_Set_Input>;
  where: Campaign_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Deck_By_PkArgs = {
  _append?: InputMaybe<Campaign_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Campaign_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Campaign_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Campaign_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Campaign_Deck_Inc_Input>;
  _prepend?: InputMaybe<Campaign_Deck_Prepend_Input>;
  _set?: InputMaybe<Campaign_Deck_Set_Input>;
  pk_columns: Campaign_Deck_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Deck_ManyArgs = {
  updates: Array<Campaign_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_DifficultyArgs = {
  _set?: InputMaybe<Campaign_Difficulty_Set_Input>;
  where: Campaign_Difficulty_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Difficulty_By_PkArgs = {
  _set?: InputMaybe<Campaign_Difficulty_Set_Input>;
  pk_columns: Campaign_Difficulty_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Difficulty_ManyArgs = {
  updates: Array<Campaign_Difficulty_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_GuideArgs = {
  _inc?: InputMaybe<Campaign_Guide_Inc_Input>;
  _set?: InputMaybe<Campaign_Guide_Set_Input>;
  where: Campaign_Guide_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Guide_ManyArgs = {
  updates: Array<Campaign_Guide_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_InvestigatorArgs = {
  _inc?: InputMaybe<Campaign_Investigator_Inc_Input>;
  _set?: InputMaybe<Campaign_Investigator_Set_Input>;
  where: Campaign_Investigator_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Investigator_By_PkArgs = {
  _inc?: InputMaybe<Campaign_Investigator_Inc_Input>;
  _set?: InputMaybe<Campaign_Investigator_Set_Input>;
  pk_columns: Campaign_Investigator_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Investigator_ManyArgs = {
  updates: Array<Campaign_Investigator_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_ManyArgs = {
  updates: Array<Campaign_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CardArgs = {
  _append?: InputMaybe<Card_Append_Input>;
  _delete_at_path?: InputMaybe<Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Card_Delete_Key_Input>;
  _inc?: InputMaybe<Card_Inc_Input>;
  _prepend?: InputMaybe<Card_Prepend_Input>;
  _set?: InputMaybe<Card_Set_Input>;
  where: Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_By_PkArgs = {
  _append?: InputMaybe<Card_Append_Input>;
  _delete_at_path?: InputMaybe<Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Card_Delete_Key_Input>;
  _inc?: InputMaybe<Card_Inc_Input>;
  _prepend?: InputMaybe<Card_Prepend_Input>;
  _set?: InputMaybe<Card_Set_Input>;
  pk_columns: Card_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_CycleArgs = {
  _inc?: InputMaybe<Card_Cycle_Inc_Input>;
  _set?: InputMaybe<Card_Cycle_Set_Input>;
  where: Card_Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Cycle_By_PkArgs = {
  _inc?: InputMaybe<Card_Cycle_Inc_Input>;
  _set?: InputMaybe<Card_Cycle_Set_Input>;
  pk_columns: Card_Cycle_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Cycle_ManyArgs = {
  updates: Array<Card_Cycle_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Encounter_SetArgs = {
  _set?: InputMaybe<Card_Encounter_Set_Set_Input>;
  where: Card_Encounter_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Encounter_Set_By_PkArgs = {
  _set?: InputMaybe<Card_Encounter_Set_Set_Input>;
  pk_columns: Card_Encounter_Set_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Encounter_Set_ManyArgs = {
  updates: Array<Card_Encounter_Set_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_ManyArgs = {
  updates: Array<Card_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_PackArgs = {
  _inc?: InputMaybe<Card_Pack_Inc_Input>;
  _set?: InputMaybe<Card_Pack_Set_Input>;
  where: Card_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Pack_By_PkArgs = {
  _inc?: InputMaybe<Card_Pack_Inc_Input>;
  _set?: InputMaybe<Card_Pack_Set_Input>;
  pk_columns: Card_Pack_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Pack_ManyArgs = {
  updates: Array<Card_Pack_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Subtype_NameArgs = {
  _set?: InputMaybe<Card_Subtype_Name_Set_Input>;
  where: Card_Subtype_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Subtype_Name_By_PkArgs = {
  _set?: InputMaybe<Card_Subtype_Name_Set_Input>;
  pk_columns: Card_Subtype_Name_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Subtype_Name_ManyArgs = {
  updates: Array<Card_Subtype_Name_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_TextArgs = {
  _set?: InputMaybe<Card_Text_Set_Input>;
  where: Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Text_By_PkArgs = {
  _set?: InputMaybe<Card_Text_Set_Input>;
  pk_columns: Card_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Text_ManyArgs = {
  updates: Array<Card_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_CodeArgs = {
  _set?: InputMaybe<Card_Type_Code_Set_Input>;
  where: Card_Type_Code_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_Code_By_PkArgs = {
  _set?: InputMaybe<Card_Type_Code_Set_Input>;
  pk_columns: Card_Type_Code_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_Code_ManyArgs = {
  updates: Array<Card_Type_Code_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_NameArgs = {
  _set?: InputMaybe<Card_Type_Name_Set_Input>;
  where: Card_Type_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_Name_By_PkArgs = {
  _set?: InputMaybe<Card_Type_Name_Set_Input>;
  pk_columns: Card_Type_Name_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_Name_ManyArgs = {
  updates: Array<Card_Type_Name_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_ResultArgs = {
  _append?: InputMaybe<Chaos_Bag_Result_Append_Input>;
  _delete_at_path?: InputMaybe<Chaos_Bag_Result_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Chaos_Bag_Result_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Chaos_Bag_Result_Delete_Key_Input>;
  _inc?: InputMaybe<Chaos_Bag_Result_Inc_Input>;
  _prepend?: InputMaybe<Chaos_Bag_Result_Prepend_Input>;
  _set?: InputMaybe<Chaos_Bag_Result_Set_Input>;
  where: Chaos_Bag_Result_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_Result_By_PkArgs = {
  _append?: InputMaybe<Chaos_Bag_Result_Append_Input>;
  _delete_at_path?: InputMaybe<Chaos_Bag_Result_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Chaos_Bag_Result_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Chaos_Bag_Result_Delete_Key_Input>;
  _inc?: InputMaybe<Chaos_Bag_Result_Inc_Input>;
  _prepend?: InputMaybe<Chaos_Bag_Result_Prepend_Input>;
  _set?: InputMaybe<Chaos_Bag_Result_Set_Input>;
  pk_columns: Chaos_Bag_Result_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_Result_ManyArgs = {
  updates: Array<Chaos_Bag_Result_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_Tarot_ModeArgs = {
  _set?: InputMaybe<Chaos_Bag_Tarot_Mode_Set_Input>;
  where: Chaos_Bag_Tarot_Mode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_Tarot_Mode_By_PkArgs = {
  _set?: InputMaybe<Chaos_Bag_Tarot_Mode_Set_Input>;
  pk_columns: Chaos_Bag_Tarot_Mode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_Tarot_Mode_ManyArgs = {
  updates: Array<Chaos_Bag_Tarot_Mode_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_CardArgs = {
  _append?: InputMaybe<Conquest_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Conquest_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Conquest_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Conquest_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Conquest_Card_Inc_Input>;
  _prepend?: InputMaybe<Conquest_Card_Prepend_Input>;
  _set?: InputMaybe<Conquest_Card_Set_Input>;
  where: Conquest_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Card_By_PkArgs = {
  _append?: InputMaybe<Conquest_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Conquest_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Conquest_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Conquest_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Conquest_Card_Inc_Input>;
  _prepend?: InputMaybe<Conquest_Card_Prepend_Input>;
  _set?: InputMaybe<Conquest_Card_Set_Input>;
  pk_columns: Conquest_Card_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Card_ManyArgs = {
  updates: Array<Conquest_Card_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Card_TextArgs = {
  _set?: InputMaybe<Conquest_Card_Text_Set_Input>;
  where: Conquest_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Card_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Card_Text_Set_Input>;
  pk_columns: Conquest_Card_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Card_Text_ManyArgs = {
  updates: Array<Conquest_Card_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_CommentArgs = {
  _inc?: InputMaybe<Conquest_Comment_Inc_Input>;
  _set?: InputMaybe<Conquest_Comment_Set_Input>;
  where: Conquest_Comment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Comment_By_PkArgs = {
  _inc?: InputMaybe<Conquest_Comment_Inc_Input>;
  _set?: InputMaybe<Conquest_Comment_Set_Input>;
  pk_columns: Conquest_Comment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Comment_ManyArgs = {
  updates: Array<Conquest_Comment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_CycleArgs = {
  _inc?: InputMaybe<Conquest_Cycle_Inc_Input>;
  _set?: InputMaybe<Conquest_Cycle_Set_Input>;
  where: Conquest_Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Cycle_By_PkArgs = {
  _inc?: InputMaybe<Conquest_Cycle_Inc_Input>;
  _set?: InputMaybe<Conquest_Cycle_Set_Input>;
  pk_columns: Conquest_Cycle_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Cycle_ManyArgs = {
  updates: Array<Conquest_Cycle_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Cycle_TextArgs = {
  _set?: InputMaybe<Conquest_Cycle_Text_Set_Input>;
  where: Conquest_Cycle_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Cycle_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Cycle_Text_Set_Input>;
  pk_columns: Conquest_Cycle_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Cycle_Text_ManyArgs = {
  updates: Array<Conquest_Cycle_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_DeckArgs = {
  _append?: InputMaybe<Conquest_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Conquest_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Conquest_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Conquest_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Conquest_Deck_Inc_Input>;
  _prepend?: InputMaybe<Conquest_Deck_Prepend_Input>;
  _set?: InputMaybe<Conquest_Deck_Set_Input>;
  where: Conquest_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_By_PkArgs = {
  _append?: InputMaybe<Conquest_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Conquest_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Conquest_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Conquest_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Conquest_Deck_Inc_Input>;
  _prepend?: InputMaybe<Conquest_Deck_Prepend_Input>;
  _set?: InputMaybe<Conquest_Deck_Set_Input>;
  pk_columns: Conquest_Deck_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_CopyArgs = {
  _inc?: InputMaybe<Conquest_Deck_Copy_Inc_Input>;
  _set?: InputMaybe<Conquest_Deck_Copy_Set_Input>;
  where: Conquest_Deck_Copy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_Copy_By_PkArgs = {
  _inc?: InputMaybe<Conquest_Deck_Copy_Inc_Input>;
  _set?: InputMaybe<Conquest_Deck_Copy_Set_Input>;
  pk_columns: Conquest_Deck_Copy_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_Copy_ManyArgs = {
  updates: Array<Conquest_Deck_Copy_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_LikeArgs = {
  _inc?: InputMaybe<Conquest_Deck_Like_Inc_Input>;
  _set?: InputMaybe<Conquest_Deck_Like_Set_Input>;
  where: Conquest_Deck_Like_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_Like_By_PkArgs = {
  _inc?: InputMaybe<Conquest_Deck_Like_Inc_Input>;
  _set?: InputMaybe<Conquest_Deck_Like_Set_Input>;
  pk_columns: Conquest_Deck_Like_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_Like_ManyArgs = {
  updates: Array<Conquest_Deck_Like_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_ManyArgs = {
  updates: Array<Conquest_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_FactionArgs = {
  _set?: InputMaybe<Conquest_Faction_Set_Input>;
  where: Conquest_Faction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Faction_By_PkArgs = {
  _set?: InputMaybe<Conquest_Faction_Set_Input>;
  pk_columns: Conquest_Faction_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Faction_ManyArgs = {
  updates: Array<Conquest_Faction_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Faction_TextArgs = {
  _set?: InputMaybe<Conquest_Faction_Text_Set_Input>;
  where: Conquest_Faction_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Faction_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Faction_Text_Set_Input>;
  pk_columns: Conquest_Faction_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Faction_Text_ManyArgs = {
  updates: Array<Conquest_Faction_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_LoyaltyArgs = {
  _set?: InputMaybe<Conquest_Loyalty_Set_Input>;
  where: Conquest_Loyalty_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Loyalty_By_PkArgs = {
  _set?: InputMaybe<Conquest_Loyalty_Set_Input>;
  pk_columns: Conquest_Loyalty_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Loyalty_ManyArgs = {
  updates: Array<Conquest_Loyalty_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Loyalty_TextArgs = {
  _set?: InputMaybe<Conquest_Loyalty_Text_Set_Input>;
  where: Conquest_Loyalty_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Loyalty_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Loyalty_Text_Set_Input>;
  pk_columns: Conquest_Loyalty_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Loyalty_Text_ManyArgs = {
  updates: Array<Conquest_Loyalty_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_PackArgs = {
  _inc?: InputMaybe<Conquest_Pack_Inc_Input>;
  _set?: InputMaybe<Conquest_Pack_Set_Input>;
  where: Conquest_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Pack_By_PkArgs = {
  _inc?: InputMaybe<Conquest_Pack_Inc_Input>;
  _set?: InputMaybe<Conquest_Pack_Set_Input>;
  pk_columns: Conquest_Pack_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Pack_ManyArgs = {
  updates: Array<Conquest_Pack_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Pack_TextArgs = {
  _set?: InputMaybe<Conquest_Pack_Text_Set_Input>;
  where: Conquest_Pack_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Pack_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Pack_Text_Set_Input>;
  pk_columns: Conquest_Pack_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Pack_Text_ManyArgs = {
  updates: Array<Conquest_Pack_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_TypeArgs = {
  _set?: InputMaybe<Conquest_Type_Set_Input>;
  where: Conquest_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Type_By_PkArgs = {
  _set?: InputMaybe<Conquest_Type_Set_Input>;
  pk_columns: Conquest_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Type_ManyArgs = {
  updates: Array<Conquest_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Type_TextArgs = {
  _set?: InputMaybe<Conquest_Type_Text_Set_Input>;
  where: Conquest_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Type_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Type_Text_Set_Input>;
  pk_columns: Conquest_Type_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Type_Text_ManyArgs = {
  updates: Array<Conquest_Type_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_RoleArgs = {
  _set?: InputMaybe<Conquest_User_Role_Set_Input>;
  where: Conquest_User_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_Role_By_PkArgs = {
  _set?: InputMaybe<Conquest_User_Role_Set_Input>;
  pk_columns: Conquest_User_Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_Role_ManyArgs = {
  updates: Array<Conquest_User_Role_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_SettingsArgs = {
  _set?: InputMaybe<Conquest_User_Settings_Set_Input>;
  where: Conquest_User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_Settings_By_PkArgs = {
  _set?: InputMaybe<Conquest_User_Settings_Set_Input>;
  pk_columns: Conquest_User_Settings_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_Settings_ManyArgs = {
  updates: Array<Conquest_User_Settings_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_UsersArgs = {
  _set?: InputMaybe<Conquest_Users_Set_Input>;
  where: Conquest_Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Users_By_PkArgs = {
  _set?: InputMaybe<Conquest_Users_Set_Input>;
  pk_columns: Conquest_Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Users_ManyArgs = {
  updates: Array<Conquest_Users_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CycleArgs = {
  _inc?: InputMaybe<Cycle_Inc_Input>;
  _set?: InputMaybe<Cycle_Set_Input>;
  where: Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Cycle_By_PkArgs = {
  _inc?: InputMaybe<Cycle_Inc_Input>;
  _set?: InputMaybe<Cycle_Set_Input>;
  pk_columns: Cycle_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Cycle_ManyArgs = {
  updates: Array<Cycle_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Cycle_NameArgs = {
  _set?: InputMaybe<Cycle_Name_Set_Input>;
  where: Cycle_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Cycle_Name_By_PkArgs = {
  _set?: InputMaybe<Cycle_Name_Set_Input>;
  pk_columns: Cycle_Name_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Cycle_Name_ManyArgs = {
  updates: Array<Cycle_Name_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Faction_NameArgs = {
  _set?: InputMaybe<Faction_Name_Set_Input>;
  where: Faction_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Faction_Name_By_PkArgs = {
  _set?: InputMaybe<Faction_Name_Set_Input>;
  pk_columns: Faction_Name_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Faction_Name_ManyArgs = {
  updates: Array<Faction_Name_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FaqArgs = {
  _set?: InputMaybe<Faq_Set_Input>;
  where: Faq_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Faq_By_PkArgs = {
  _set?: InputMaybe<Faq_Set_Input>;
  pk_columns: Faq_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Faq_ManyArgs = {
  updates: Array<Faq_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Faq_TextArgs = {
  _set?: InputMaybe<Faq_Text_Set_Input>;
  where: Faq_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Faq_Text_By_PkArgs = {
  _set?: InputMaybe<Faq_Text_Set_Input>;
  pk_columns: Faq_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Faq_Text_ManyArgs = {
  updates: Array<Faq_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_StatusArgs = {
  _set?: InputMaybe<Friend_Status_Set_Input>;
  where: Friend_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_Status_By_PkArgs = {
  _set?: InputMaybe<Friend_Status_Set_Input>;
  pk_columns: Friend_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_Status_ManyArgs = {
  updates: Array<Friend_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_Status_TypeArgs = {
  _set?: InputMaybe<Friend_Status_Type_Set_Input>;
  where: Friend_Status_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_Status_Type_By_PkArgs = {
  _set?: InputMaybe<Friend_Status_Type_Set_Input>;
  pk_columns: Friend_Status_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_Status_Type_ManyArgs = {
  updates: Array<Friend_Status_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Full_CardArgs = {
  _append?: InputMaybe<Full_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Full_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Full_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Full_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Full_Card_Inc_Input>;
  _prepend?: InputMaybe<Full_Card_Prepend_Input>;
  _set?: InputMaybe<Full_Card_Set_Input>;
  where: Full_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Full_Card_By_PkArgs = {
  _append?: InputMaybe<Full_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Full_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Full_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Full_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Full_Card_Inc_Input>;
  _prepend?: InputMaybe<Full_Card_Prepend_Input>;
  _set?: InputMaybe<Full_Card_Set_Input>;
  pk_columns: Full_Card_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Full_Card_ManyArgs = {
  updates: Array<Full_Card_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Full_Card_TextArgs = {
  _set?: InputMaybe<Full_Card_Text_Set_Input>;
  where: Full_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Full_Card_Text_By_PkArgs = {
  _set?: InputMaybe<Full_Card_Text_Set_Input>;
  pk_columns: Full_Card_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Full_Card_Text_ManyArgs = {
  updates: Array<Full_Card_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_GenderArgs = {
  _set?: InputMaybe<Gender_Set_Input>;
  where: Gender_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Gender_By_PkArgs = {
  _set?: InputMaybe<Gender_Set_Input>;
  pk_columns: Gender_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Gender_ManyArgs = {
  updates: Array<Gender_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_AchievementArgs = {
  _inc?: InputMaybe<Guide_Achievement_Inc_Input>;
  _set?: InputMaybe<Guide_Achievement_Set_Input>;
  where: Guide_Achievement_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_Achievement_By_PkArgs = {
  _inc?: InputMaybe<Guide_Achievement_Inc_Input>;
  _set?: InputMaybe<Guide_Achievement_Set_Input>;
  pk_columns: Guide_Achievement_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_Achievement_ManyArgs = {
  updates: Array<Guide_Achievement_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_InputArgs = {
  _append?: InputMaybe<Guide_Input_Append_Input>;
  _delete_at_path?: InputMaybe<Guide_Input_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Guide_Input_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Guide_Input_Delete_Key_Input>;
  _inc?: InputMaybe<Guide_Input_Inc_Input>;
  _prepend?: InputMaybe<Guide_Input_Prepend_Input>;
  _set?: InputMaybe<Guide_Input_Set_Input>;
  where: Guide_Input_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_Input_By_PkArgs = {
  _append?: InputMaybe<Guide_Input_Append_Input>;
  _delete_at_path?: InputMaybe<Guide_Input_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Guide_Input_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Guide_Input_Delete_Key_Input>;
  _inc?: InputMaybe<Guide_Input_Inc_Input>;
  _prepend?: InputMaybe<Guide_Input_Prepend_Input>;
  _set?: InputMaybe<Guide_Input_Set_Input>;
  pk_columns: Guide_Input_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_Input_ManyArgs = {
  updates: Array<Guide_Input_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Investigator_DataArgs = {
  _append?: InputMaybe<Investigator_Data_Append_Input>;
  _delete_at_path?: InputMaybe<Investigator_Data_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Investigator_Data_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Investigator_Data_Delete_Key_Input>;
  _inc?: InputMaybe<Investigator_Data_Inc_Input>;
  _prepend?: InputMaybe<Investigator_Data_Prepend_Input>;
  _set?: InputMaybe<Investigator_Data_Set_Input>;
  where: Investigator_Data_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Investigator_Data_By_PkArgs = {
  _append?: InputMaybe<Investigator_Data_Append_Input>;
  _delete_at_path?: InputMaybe<Investigator_Data_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Investigator_Data_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Investigator_Data_Delete_Key_Input>;
  _inc?: InputMaybe<Investigator_Data_Inc_Input>;
  _prepend?: InputMaybe<Investigator_Data_Prepend_Input>;
  _set?: InputMaybe<Investigator_Data_Set_Input>;
  pk_columns: Investigator_Data_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Investigator_Data_ManyArgs = {
  updates: Array<Investigator_Data_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Latest_DecksArgs = {
  _inc?: InputMaybe<Latest_Decks_Inc_Input>;
  _set?: InputMaybe<Latest_Decks_Set_Input>;
  where: Latest_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Latest_Decks_ManyArgs = {
  updates: Array<Latest_Decks_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Local_DecksArgs = {
  _inc?: InputMaybe<Local_Decks_Inc_Input>;
  _set?: InputMaybe<Local_Decks_Set_Input>;
  where: Local_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Local_Decks_ManyArgs = {
  updates: Array<Local_Decks_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PackArgs = {
  _inc?: InputMaybe<Pack_Inc_Input>;
  _set?: InputMaybe<Pack_Set_Input>;
  where: Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Pack_By_PkArgs = {
  _inc?: InputMaybe<Pack_Inc_Input>;
  _set?: InputMaybe<Pack_Set_Input>;
  pk_columns: Pack_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Pack_ManyArgs = {
  updates: Array<Pack_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Pack_NameArgs = {
  _set?: InputMaybe<Pack_Name_Set_Input>;
  where: Pack_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Pack_Name_By_PkArgs = {
  _set?: InputMaybe<Pack_Name_Set_Input>;
  pk_columns: Pack_Name_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Pack_Name_ManyArgs = {
  updates: Array<Pack_Name_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_AreaArgs = {
  _set?: InputMaybe<Rangers_Area_Set_Input>;
  where: Rangers_Area_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Area_By_PkArgs = {
  _set?: InputMaybe<Rangers_Area_Set_Input>;
  pk_columns: Rangers_Area_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Area_ManyArgs = {
  updates: Array<Rangers_Area_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Area_TextArgs = {
  _set?: InputMaybe<Rangers_Area_Text_Set_Input>;
  where: Rangers_Area_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Area_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Area_Text_Set_Input>;
  pk_columns: Rangers_Area_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Area_Text_ManyArgs = {
  updates: Array<Rangers_Area_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_AspectArgs = {
  _set?: InputMaybe<Rangers_Aspect_Set_Input>;
  where: Rangers_Aspect_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Aspect_By_PkArgs = {
  _set?: InputMaybe<Rangers_Aspect_Set_Input>;
  pk_columns: Rangers_Aspect_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Aspect_ManyArgs = {
  updates: Array<Rangers_Aspect_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Aspect_TextArgs = {
  _set?: InputMaybe<Rangers_Aspect_Text_Set_Input>;
  where: Rangers_Aspect_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Aspect_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Aspect_Text_Set_Input>;
  pk_columns: Rangers_Aspect_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Aspect_Text_ManyArgs = {
  updates: Array<Rangers_Aspect_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_CampaignArgs = {
  _append?: InputMaybe<Rangers_Campaign_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Campaign_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Campaign_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Campaign_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Campaign_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Campaign_Prepend_Input>;
  _set?: InputMaybe<Rangers_Campaign_Set_Input>;
  where: Rangers_Campaign_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Campaign_AccessArgs = {
  _inc?: InputMaybe<Rangers_Campaign_Access_Inc_Input>;
  _set?: InputMaybe<Rangers_Campaign_Access_Set_Input>;
  where: Rangers_Campaign_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Campaign_Access_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Campaign_Access_Inc_Input>;
  _set?: InputMaybe<Rangers_Campaign_Access_Set_Input>;
  pk_columns: Rangers_Campaign_Access_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Campaign_Access_ManyArgs = {
  updates: Array<Rangers_Campaign_Access_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Campaign_By_PkArgs = {
  _append?: InputMaybe<Rangers_Campaign_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Campaign_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Campaign_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Campaign_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Campaign_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Campaign_Prepend_Input>;
  _set?: InputMaybe<Rangers_Campaign_Set_Input>;
  pk_columns: Rangers_Campaign_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Campaign_ManyArgs = {
  updates: Array<Rangers_Campaign_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_CardArgs = {
  _append?: InputMaybe<Rangers_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Card_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Card_Prepend_Input>;
  _set?: InputMaybe<Rangers_Card_Set_Input>;
  where: Rangers_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Card_By_PkArgs = {
  _append?: InputMaybe<Rangers_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Card_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Card_Prepend_Input>;
  _set?: InputMaybe<Rangers_Card_Set_Input>;
  pk_columns: Rangers_Card_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Card_ManyArgs = {
  updates: Array<Rangers_Card_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Card_TextArgs = {
  _set?: InputMaybe<Rangers_Card_Text_Set_Input>;
  where: Rangers_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Card_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Card_Text_Set_Input>;
  pk_columns: Rangers_Card_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Card_Text_ManyArgs = {
  updates: Array<Rangers_Card_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_CommentArgs = {
  _inc?: InputMaybe<Rangers_Comment_Inc_Input>;
  _set?: InputMaybe<Rangers_Comment_Set_Input>;
  where: Rangers_Comment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Comment_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Comment_Inc_Input>;
  _set?: InputMaybe<Rangers_Comment_Set_Input>;
  pk_columns: Rangers_Comment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Comment_ManyArgs = {
  updates: Array<Rangers_Comment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_DeckArgs = {
  _append?: InputMaybe<Rangers_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Deck_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Deck_Prepend_Input>;
  _set?: InputMaybe<Rangers_Deck_Set_Input>;
  where: Rangers_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_By_PkArgs = {
  _append?: InputMaybe<Rangers_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Deck_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Deck_Prepend_Input>;
  _set?: InputMaybe<Rangers_Deck_Set_Input>;
  pk_columns: Rangers_Deck_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_CopyArgs = {
  _inc?: InputMaybe<Rangers_Deck_Copy_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Copy_Set_Input>;
  where: Rangers_Deck_Copy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Copy_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Deck_Copy_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Copy_Set_Input>;
  pk_columns: Rangers_Deck_Copy_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Copy_ManyArgs = {
  updates: Array<Rangers_Deck_Copy_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_LikeArgs = {
  _inc?: InputMaybe<Rangers_Deck_Like_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Like_Set_Input>;
  where: Rangers_Deck_Like_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Like_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Deck_Like_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Like_Set_Input>;
  pk_columns: Rangers_Deck_Like_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Like_CountArgs = {
  _inc?: InputMaybe<Rangers_Deck_Like_Count_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Like_Count_Set_Input>;
  where: Rangers_Deck_Like_Count_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Like_Count_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Deck_Like_Count_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Like_Count_Set_Input>;
  pk_columns: Rangers_Deck_Like_Count_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Like_Count_ManyArgs = {
  updates: Array<Rangers_Deck_Like_Count_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Like_ManyArgs = {
  updates: Array<Rangers_Deck_Like_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_ManyArgs = {
  updates: Array<Rangers_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Faq_EntryArgs = {
  _set?: InputMaybe<Rangers_Faq_Entry_Set_Input>;
  where: Rangers_Faq_Entry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Faq_Entry_By_PkArgs = {
  _set?: InputMaybe<Rangers_Faq_Entry_Set_Input>;
  pk_columns: Rangers_Faq_Entry_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Faq_Entry_ManyArgs = {
  updates: Array<Rangers_Faq_Entry_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_StatusArgs = {
  _set?: InputMaybe<Rangers_Friend_Status_Set_Input>;
  where: Rangers_Friend_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_Status_By_PkArgs = {
  _set?: InputMaybe<Rangers_Friend_Status_Set_Input>;
  pk_columns: Rangers_Friend_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_Status_ManyArgs = {
  updates: Array<Rangers_Friend_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_Status_TypeArgs = {
  _set?: InputMaybe<Rangers_Friend_Status_Type_Set_Input>;
  where: Rangers_Friend_Status_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_Status_Type_By_PkArgs = {
  _set?: InputMaybe<Rangers_Friend_Status_Type_Set_Input>;
  pk_columns: Rangers_Friend_Status_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_Status_Type_ManyArgs = {
  updates: Array<Rangers_Friend_Status_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Latest_DeckArgs = {
  _inc?: InputMaybe<Rangers_Latest_Deck_Inc_Input>;
  _set?: InputMaybe<Rangers_Latest_Deck_Set_Input>;
  where: Rangers_Latest_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Latest_Deck_ManyArgs = {
  updates: Array<Rangers_Latest_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_LocaleArgs = {
  _set?: InputMaybe<Rangers_Locale_Set_Input>;
  where: Rangers_Locale_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Locale_By_PkArgs = {
  _set?: InputMaybe<Rangers_Locale_Set_Input>;
  pk_columns: Rangers_Locale_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Locale_ManyArgs = {
  updates: Array<Rangers_Locale_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_PackArgs = {
  _inc?: InputMaybe<Rangers_Pack_Inc_Input>;
  _set?: InputMaybe<Rangers_Pack_Set_Input>;
  where: Rangers_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Pack_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Pack_Inc_Input>;
  _set?: InputMaybe<Rangers_Pack_Set_Input>;
  pk_columns: Rangers_Pack_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Pack_ManyArgs = {
  updates: Array<Rangers_Pack_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Pack_TextArgs = {
  _set?: InputMaybe<Rangers_Pack_Text_Set_Input>;
  where: Rangers_Pack_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Pack_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Pack_Text_Set_Input>;
  pk_columns: Rangers_Pack_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Pack_Text_ManyArgs = {
  updates: Array<Rangers_Pack_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Search_DeckArgs = {
  _append?: InputMaybe<Rangers_Search_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Search_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Search_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Search_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Search_Deck_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Search_Deck_Prepend_Input>;
  _set?: InputMaybe<Rangers_Search_Deck_Set_Input>;
  where: Rangers_Search_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Search_Deck_ManyArgs = {
  updates: Array<Rangers_Search_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_SetArgs = {
  _inc?: InputMaybe<Rangers_Set_Inc_Input>;
  _set?: InputMaybe<Rangers_Set_Set_Input>;
  where: Rangers_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Set_Inc_Input>;
  _set?: InputMaybe<Rangers_Set_Set_Input>;
  pk_columns: Rangers_Set_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_ManyArgs = {
  updates: Array<Rangers_Set_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_TextArgs = {
  _set?: InputMaybe<Rangers_Set_Text_Set_Input>;
  where: Rangers_Set_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Set_Text_Set_Input>;
  pk_columns: Rangers_Set_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Text_ManyArgs = {
  updates: Array<Rangers_Set_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_TypeArgs = {
  _set?: InputMaybe<Rangers_Set_Type_Set_Input>;
  where: Rangers_Set_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Type_By_PkArgs = {
  _set?: InputMaybe<Rangers_Set_Type_Set_Input>;
  pk_columns: Rangers_Set_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Type_ManyArgs = {
  updates: Array<Rangers_Set_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Type_TextArgs = {
  _set?: InputMaybe<Rangers_Set_Type_Text_Set_Input>;
  where: Rangers_Set_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Type_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Set_Type_Text_Set_Input>;
  pk_columns: Rangers_Set_Type_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Type_Text_ManyArgs = {
  updates: Array<Rangers_Set_Type_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_SubsetArgs = {
  _inc?: InputMaybe<Rangers_Subset_Inc_Input>;
  _set?: InputMaybe<Rangers_Subset_Set_Input>;
  where: Rangers_Subset_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Subset_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Subset_Inc_Input>;
  _set?: InputMaybe<Rangers_Subset_Set_Input>;
  pk_columns: Rangers_Subset_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Subset_ManyArgs = {
  updates: Array<Rangers_Subset_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Subset_TextArgs = {
  _set?: InputMaybe<Rangers_Subset_Text_Set_Input>;
  where: Rangers_Subset_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Subset_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Subset_Text_Set_Input>;
  pk_columns: Rangers_Subset_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Subset_Text_ManyArgs = {
  updates: Array<Rangers_Subset_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Taboo_SetArgs = {
  _set?: InputMaybe<Rangers_Taboo_Set_Set_Input>;
  where: Rangers_Taboo_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Taboo_Set_By_PkArgs = {
  _set?: InputMaybe<Rangers_Taboo_Set_Set_Input>;
  pk_columns: Rangers_Taboo_Set_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Taboo_Set_ManyArgs = {
  updates: Array<Rangers_Taboo_Set_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Taboo_Set_TextArgs = {
  _set?: InputMaybe<Rangers_Taboo_Set_Text_Set_Input>;
  where: Rangers_Taboo_Set_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Taboo_Set_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Taboo_Set_Text_Set_Input>;
  pk_columns: Rangers_Taboo_Set_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Taboo_Set_Text_ManyArgs = {
  updates: Array<Rangers_Taboo_Set_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_TokenArgs = {
  _set?: InputMaybe<Rangers_Token_Set_Input>;
  where: Rangers_Token_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Token_By_PkArgs = {
  _set?: InputMaybe<Rangers_Token_Set_Input>;
  pk_columns: Rangers_Token_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Token_ManyArgs = {
  updates: Array<Rangers_Token_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Token_TextArgs = {
  _set?: InputMaybe<Rangers_Token_Text_Set_Input>;
  where: Rangers_Token_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Token_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Token_Text_Set_Input>;
  pk_columns: Rangers_Token_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Token_Text_ManyArgs = {
  updates: Array<Rangers_Token_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_TypeArgs = {
  _set?: InputMaybe<Rangers_Type_Set_Input>;
  where: Rangers_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Type_By_PkArgs = {
  _set?: InputMaybe<Rangers_Type_Set_Input>;
  pk_columns: Rangers_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Type_ManyArgs = {
  updates: Array<Rangers_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Type_TextArgs = {
  _set?: InputMaybe<Rangers_Type_Text_Set_Input>;
  where: Rangers_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Type_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Type_Text_Set_Input>;
  pk_columns: Rangers_Type_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Type_Text_ManyArgs = {
  updates: Array<Rangers_Type_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_FriendsArgs = {
  _set?: InputMaybe<Rangers_User_Friends_Set_Input>;
  where: Rangers_User_Friends_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Friends_ManyArgs = {
  updates: Array<Rangers_User_Friends_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Received_Friend_RequestsArgs = {
  _set?: InputMaybe<Rangers_User_Received_Friend_Requests_Set_Input>;
  where: Rangers_User_Received_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Received_Friend_Requests_ManyArgs = {
  updates: Array<Rangers_User_Received_Friend_Requests_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_RoleArgs = {
  _set?: InputMaybe<Rangers_User_Role_Set_Input>;
  where: Rangers_User_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Role_By_PkArgs = {
  _set?: InputMaybe<Rangers_User_Role_Set_Input>;
  pk_columns: Rangers_User_Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Role_ManyArgs = {
  updates: Array<Rangers_User_Role_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Sent_Friend_RequestsArgs = {
  _set?: InputMaybe<Rangers_User_Sent_Friend_Requests_Set_Input>;
  where: Rangers_User_Sent_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Sent_Friend_Requests_ManyArgs = {
  updates: Array<Rangers_User_Sent_Friend_Requests_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_SettingsArgs = {
  _append?: InputMaybe<Rangers_User_Settings_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_User_Settings_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_User_Settings_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_User_Settings_Delete_Key_Input>;
  _prepend?: InputMaybe<Rangers_User_Settings_Prepend_Input>;
  _set?: InputMaybe<Rangers_User_Settings_Set_Input>;
  where: Rangers_User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Settings_By_PkArgs = {
  _append?: InputMaybe<Rangers_User_Settings_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_User_Settings_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_User_Settings_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_User_Settings_Delete_Key_Input>;
  _prepend?: InputMaybe<Rangers_User_Settings_Prepend_Input>;
  _set?: InputMaybe<Rangers_User_Settings_Set_Input>;
  pk_columns: Rangers_User_Settings_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Settings_ManyArgs = {
  updates: Array<Rangers_User_Settings_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_UsersArgs = {
  _set?: InputMaybe<Rangers_Users_Set_Input>;
  where: Rangers_Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Users_By_PkArgs = {
  _set?: InputMaybe<Rangers_Users_Set_Input>;
  pk_columns: Rangers_Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Users_ManyArgs = {
  updates: Array<Rangers_Users_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Taboo_SetArgs = {
  _inc?: InputMaybe<Taboo_Set_Inc_Input>;
  _set?: InputMaybe<Taboo_Set_Set_Input>;
  where: Taboo_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Taboo_Set_By_PkArgs = {
  _inc?: InputMaybe<Taboo_Set_Inc_Input>;
  _set?: InputMaybe<Taboo_Set_Set_Input>;
  pk_columns: Taboo_Set_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Taboo_Set_ManyArgs = {
  updates: Array<Taboo_Set_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_CampaignsArgs = {
  _inc?: InputMaybe<User_Campaigns_Inc_Input>;
  _set?: InputMaybe<User_Campaigns_Set_Input>;
  where: User_Campaigns_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Campaigns_ManyArgs = {
  updates: Array<User_Campaigns_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_FlagArgs = {
  _set?: InputMaybe<User_Flag_Set_Input>;
  where: User_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Flag_By_PkArgs = {
  _set?: InputMaybe<User_Flag_Set_Input>;
  pk_columns: User_Flag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Flag_ManyArgs = {
  updates: Array<User_Flag_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Flag_TypeArgs = {
  _set?: InputMaybe<User_Flag_Type_Set_Input>;
  where: User_Flag_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Flag_Type_By_PkArgs = {
  _set?: InputMaybe<User_Flag_Type_Set_Input>;
  pk_columns: User_Flag_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Flag_Type_ManyArgs = {
  updates: Array<User_Flag_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_FriendsArgs = {
  _set?: InputMaybe<User_Friends_Set_Input>;
  where: User_Friends_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Friends_ManyArgs = {
  updates: Array<User_Friends_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Received_Friend_RequestsArgs = {
  _set?: InputMaybe<User_Received_Friend_Requests_Set_Input>;
  where: User_Received_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Received_Friend_Requests_ManyArgs = {
  updates: Array<User_Received_Friend_Requests_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Sent_Friend_RequestsArgs = {
  _set?: InputMaybe<User_Sent_Friend_Requests_Set_Input>;
  where: User_Sent_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Sent_Friend_Requests_ManyArgs = {
  updates: Array<User_Sent_Friend_Requests_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_SettingsArgs = {
  _append?: InputMaybe<User_Settings_Append_Input>;
  _delete_at_path?: InputMaybe<User_Settings_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<User_Settings_Delete_Elem_Input>;
  _delete_key?: InputMaybe<User_Settings_Delete_Key_Input>;
  _prepend?: InputMaybe<User_Settings_Prepend_Input>;
  _set?: InputMaybe<User_Settings_Set_Input>;
  where: User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Settings_By_PkArgs = {
  _append?: InputMaybe<User_Settings_Append_Input>;
  _delete_at_path?: InputMaybe<User_Settings_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<User_Settings_Delete_Elem_Input>;
  _delete_key?: InputMaybe<User_Settings_Delete_Key_Input>;
  _prepend?: InputMaybe<User_Settings_Prepend_Input>;
  _set?: InputMaybe<User_Settings_Set_Input>;
  pk_columns: User_Settings_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Settings_ManyArgs = {
  updates: Array<User_Settings_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsersArgs = {
  _set?: InputMaybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Users_By_PkArgs = {
  _set?: InputMaybe<Users_Set_Input>;
  pk_columns: Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Users_ManyArgs = {
  updates: Array<Users_Updates>;
};


/** mutation root */
export type Mutation_RootUpgradeArkhamDbDeckArgs = {
  args: UpgradeDeckInput;
};


/** mutation root */
export type Mutation_RootUploadLocalCampaignDeckArgs = {
  args: UploadLocalCampaignDeckInput;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "pack" */
export type Pack = {
  __typename?: 'pack';
  /** An array relationship */
  cards: Array<All_Card>;
  /** An aggregate relationship */
  cards_aggregate: All_Card_Aggregate;
  code: Scalars['String']['output'];
  /** An object relationship */
  cycle: Cycle;
  cycle_code: Scalars['String']['output'];
  official: Scalars['Boolean']['output'];
  position: Scalars['Int']['output'];
  real_name: Scalars['String']['output'];
  /** An array relationship */
  translations: Array<Pack_Name>;
  /** An aggregate relationship */
  translations_aggregate: Pack_Name_Aggregate;
};


/** columns and relationships of "pack" */
export type PackCardsArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


/** columns and relationships of "pack" */
export type PackCards_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


/** columns and relationships of "pack" */
export type PackTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


/** columns and relationships of "pack" */
export type PackTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};

/** aggregated selection of "pack" */
export type Pack_Aggregate = {
  __typename?: 'pack_aggregate';
  aggregate?: Maybe<Pack_Aggregate_Fields>;
  nodes: Array<Pack>;
};

export type Pack_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Pack_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Pack_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Pack_Aggregate_Bool_Exp_Count>;
};

export type Pack_Aggregate_Bool_Exp_Bool_And = {
  arguments: Pack_Select_Column_Pack_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Pack_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Pack_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Pack_Select_Column_Pack_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Pack_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Pack_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Pack_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "pack" */
export type Pack_Aggregate_Fields = {
  __typename?: 'pack_aggregate_fields';
  avg?: Maybe<Pack_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Pack_Max_Fields>;
  min?: Maybe<Pack_Min_Fields>;
  stddev?: Maybe<Pack_Stddev_Fields>;
  stddev_pop?: Maybe<Pack_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Pack_Stddev_Samp_Fields>;
  sum?: Maybe<Pack_Sum_Fields>;
  var_pop?: Maybe<Pack_Var_Pop_Fields>;
  var_samp?: Maybe<Pack_Var_Samp_Fields>;
  variance?: Maybe<Pack_Variance_Fields>;
};


/** aggregate fields of "pack" */
export type Pack_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "pack" */
export type Pack_Aggregate_Order_By = {
  avg?: InputMaybe<Pack_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Pack_Max_Order_By>;
  min?: InputMaybe<Pack_Min_Order_By>;
  stddev?: InputMaybe<Pack_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Pack_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Pack_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Pack_Sum_Order_By>;
  var_pop?: InputMaybe<Pack_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Pack_Var_Samp_Order_By>;
  variance?: InputMaybe<Pack_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "pack" */
export type Pack_Arr_Rel_Insert_Input = {
  data: Array<Pack_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Pack_On_Conflict>;
};

/** aggregate avg on columns */
export type Pack_Avg_Fields = {
  __typename?: 'pack_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "pack" */
export type Pack_Avg_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "pack". All fields are combined with a logical 'AND'. */
export type Pack_Bool_Exp = {
  _and?: InputMaybe<Array<Pack_Bool_Exp>>;
  _not?: InputMaybe<Pack_Bool_Exp>;
  _or?: InputMaybe<Array<Pack_Bool_Exp>>;
  cards?: InputMaybe<All_Card_Bool_Exp>;
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cycle?: InputMaybe<Cycle_Bool_Exp>;
  cycle_code?: InputMaybe<String_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Pack_Name_Bool_Exp>;
  translations_aggregate?: InputMaybe<Pack_Name_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "pack" */
export enum Pack_Constraint {
  /** unique or primary key constraint on columns "code" */
  PackPkey = 'pack_pkey'
}

/** input type for incrementing numeric columns in table "pack" */
export type Pack_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "pack" */
export type Pack_Insert_Input = {
  cards?: InputMaybe<All_Card_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  cycle?: InputMaybe<Cycle_Obj_Rel_Insert_Input>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Pack_Name_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Pack_Max_Fields = {
  __typename?: 'pack_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  cycle_code?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "pack" */
export type Pack_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Pack_Min_Fields = {
  __typename?: 'pack_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  cycle_code?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "pack" */
export type Pack_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "pack" */
export type Pack_Mutation_Response = {
  __typename?: 'pack_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Pack>;
};

/** columns and relationships of "pack_name" */
export type Pack_Name = {
  __typename?: 'pack_name';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "pack_name" */
export type Pack_Name_Aggregate = {
  __typename?: 'pack_name_aggregate';
  aggregate?: Maybe<Pack_Name_Aggregate_Fields>;
  nodes: Array<Pack_Name>;
};

export type Pack_Name_Aggregate_Bool_Exp = {
  count?: InputMaybe<Pack_Name_Aggregate_Bool_Exp_Count>;
};

export type Pack_Name_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Pack_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Pack_Name_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "pack_name" */
export type Pack_Name_Aggregate_Fields = {
  __typename?: 'pack_name_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Pack_Name_Max_Fields>;
  min?: Maybe<Pack_Name_Min_Fields>;
};


/** aggregate fields of "pack_name" */
export type Pack_Name_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Pack_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "pack_name" */
export type Pack_Name_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Pack_Name_Max_Order_By>;
  min?: InputMaybe<Pack_Name_Min_Order_By>;
};

/** input type for inserting array relation for remote table "pack_name" */
export type Pack_Name_Arr_Rel_Insert_Input = {
  data: Array<Pack_Name_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Pack_Name_On_Conflict>;
};

/** Boolean expression to filter rows from the table "pack_name". All fields are combined with a logical 'AND'. */
export type Pack_Name_Bool_Exp = {
  _and?: InputMaybe<Array<Pack_Name_Bool_Exp>>;
  _not?: InputMaybe<Pack_Name_Bool_Exp>;
  _or?: InputMaybe<Array<Pack_Name_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "pack_name" */
export enum Pack_Name_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  PackNamePkey = 'pack_name_pkey'
}

/** input type for inserting data into table "pack_name" */
export type Pack_Name_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Pack_Name_Max_Fields = {
  __typename?: 'pack_name_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "pack_name" */
export type Pack_Name_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Pack_Name_Min_Fields = {
  __typename?: 'pack_name_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "pack_name" */
export type Pack_Name_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "pack_name" */
export type Pack_Name_Mutation_Response = {
  __typename?: 'pack_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Pack_Name>;
};

/** on_conflict condition type for table "pack_name" */
export type Pack_Name_On_Conflict = {
  constraint: Pack_Name_Constraint;
  update_columns?: Array<Pack_Name_Update_Column>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};

/** Ordering options when selecting data from "pack_name". */
export type Pack_Name_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: pack_name */
export type Pack_Name_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "pack_name" */
export enum Pack_Name_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "pack_name" */
export type Pack_Name_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "pack_name" */
export type Pack_Name_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Pack_Name_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Pack_Name_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "pack_name" */
export enum Pack_Name_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Pack_Name_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Pack_Name_Set_Input>;
  /** filter the rows which have to be updated */
  where: Pack_Name_Bool_Exp;
};

/** input type for inserting object relation for remote table "pack" */
export type Pack_Obj_Rel_Insert_Input = {
  data: Pack_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Pack_On_Conflict>;
};

/** on_conflict condition type for table "pack" */
export type Pack_On_Conflict = {
  constraint: Pack_Constraint;
  update_columns?: Array<Pack_Update_Column>;
  where?: InputMaybe<Pack_Bool_Exp>;
};

/** Ordering options when selecting data from "pack". */
export type Pack_Order_By = {
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  cycle?: InputMaybe<Cycle_Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Pack_Name_Aggregate_Order_By>;
};

/** primary key columns input for table: pack */
export type Pack_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** select columns of table "pack" */
export enum Pack_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CycleCode = 'cycle_code',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position',
  /** column name */
  RealName = 'real_name'
}

/** select "pack_aggregate_bool_exp_bool_and_arguments_columns" columns of table "pack" */
export enum Pack_Select_Column_Pack_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** select "pack_aggregate_bool_exp_bool_or_arguments_columns" columns of table "pack" */
export enum Pack_Select_Column_Pack_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** input type for updating data in table "pack" */
export type Pack_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Pack_Stddev_Fields = {
  __typename?: 'pack_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "pack" */
export type Pack_Stddev_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Pack_Stddev_Pop_Fields = {
  __typename?: 'pack_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "pack" */
export type Pack_Stddev_Pop_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Pack_Stddev_Samp_Fields = {
  __typename?: 'pack_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "pack" */
export type Pack_Stddev_Samp_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "pack" */
export type Pack_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Pack_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Pack_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Pack_Sum_Fields = {
  __typename?: 'pack_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "pack" */
export type Pack_Sum_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** update columns of table "pack" */
export enum Pack_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CycleCode = 'cycle_code',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position',
  /** column name */
  RealName = 'real_name'
}

export type Pack_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Pack_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Pack_Set_Input>;
  /** filter the rows which have to be updated */
  where: Pack_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Pack_Var_Pop_Fields = {
  __typename?: 'pack_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "pack" */
export type Pack_Var_Pop_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Pack_Var_Samp_Fields = {
  __typename?: 'pack_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "pack" */
export type Pack_Var_Samp_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Pack_Variance_Fields = {
  __typename?: 'pack_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "pack" */
export type Pack_Variance_Order_By = {
  position?: InputMaybe<Order_By>;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "all_card" */
  all_card: Array<All_Card>;
  /** fetch aggregated fields from the table: "all_card" */
  all_card_aggregate: All_Card_Aggregate;
  /** fetch data from the table: "all_card" using primary key columns */
  all_card_by_pk?: Maybe<All_Card>;
  /** fetch data from the table: "all_card_text" */
  all_card_text: Array<All_Card_Text>;
  /** fetch aggregated fields from the table: "all_card_text" */
  all_card_text_aggregate: All_Card_Text_Aggregate;
  /** fetch data from the table: "all_card_text" using primary key columns */
  all_card_text_by_pk?: Maybe<All_Card_Text>;
  /** fetch data from the table: "all_card_updated" */
  all_card_updated: Array<All_Card_Updated>;
  /** fetch aggregated fields from the table: "all_card_updated" */
  all_card_updated_aggregate: All_Card_Updated_Aggregate;
  /** fetch data from the table: "all_card_updated" using primary key columns */
  all_card_updated_by_pk?: Maybe<All_Card_Updated>;
  /** fetch data from the table: "all_card_updated_by_version" */
  all_card_updated_by_version: Array<All_Card_Updated_By_Version>;
  /** fetch aggregated fields from the table: "all_card_updated_by_version" */
  all_card_updated_by_version_aggregate: All_Card_Updated_By_Version_Aggregate;
  /** fetch data from the table: "all_card_updated_by_version" using primary key columns */
  all_card_updated_by_version_by_pk?: Maybe<All_Card_Updated_By_Version>;
  /** fetch data from the table: "arkhamdb_auth" */
  arkhamdb_auth: Array<Arkhamdb_Auth>;
  /** fetch aggregated fields from the table: "arkhamdb_auth" */
  arkhamdb_auth_aggregate: Arkhamdb_Auth_Aggregate;
  /** fetch data from the table: "arkhamdb_auth" using primary key columns */
  arkhamdb_auth_by_pk?: Maybe<Arkhamdb_Auth>;
  /** fetch data from the table: "arkhamdb_deck" */
  arkhamdb_deck: Array<Arkhamdb_Deck>;
  /** fetch aggregated fields from the table: "arkhamdb_deck" */
  arkhamdb_deck_aggregate: Arkhamdb_Deck_Aggregate;
  /** fetch data from the table: "arkhamdb_deck" using primary key columns */
  arkhamdb_deck_by_pk?: Maybe<Arkhamdb_Deck>;
  /** An array relationship */
  base_decks: Array<Base_Decks>;
  /** An aggregate relationship */
  base_decks_aggregate: Base_Decks_Aggregate;
  /** fetch data from the table: "campaign" */
  campaign: Array<Campaign>;
  /** fetch data from the table: "campaign_access" */
  campaign_access: Array<Campaign_Access>;
  /** fetch aggregated fields from the table: "campaign_access" */
  campaign_access_aggregate: Campaign_Access_Aggregate;
  /** fetch data from the table: "campaign_access" using primary key columns */
  campaign_access_by_pk?: Maybe<Campaign_Access>;
  /** fetch aggregated fields from the table: "campaign" */
  campaign_aggregate: Campaign_Aggregate;
  /** fetch data from the table: "campaign" using primary key columns */
  campaign_by_pk?: Maybe<Campaign>;
  /** fetch data from the table: "campaign_deck" */
  campaign_deck: Array<Campaign_Deck>;
  /** fetch aggregated fields from the table: "campaign_deck" */
  campaign_deck_aggregate: Campaign_Deck_Aggregate;
  /** fetch data from the table: "campaign_deck" using primary key columns */
  campaign_deck_by_pk?: Maybe<Campaign_Deck>;
  /** fetch data from the table: "campaign_difficulty" */
  campaign_difficulty: Array<Campaign_Difficulty>;
  /** fetch aggregated fields from the table: "campaign_difficulty" */
  campaign_difficulty_aggregate: Campaign_Difficulty_Aggregate;
  /** fetch data from the table: "campaign_difficulty" using primary key columns */
  campaign_difficulty_by_pk?: Maybe<Campaign_Difficulty>;
  /** fetch data from the table: "campaign_guide" */
  campaign_guide: Array<Campaign_Guide>;
  /** fetch aggregated fields from the table: "campaign_guide" */
  campaign_guide_aggregate: Campaign_Guide_Aggregate;
  /** fetch data from the table: "campaign_investigator" */
  campaign_investigator: Array<Campaign_Investigator>;
  /** fetch aggregated fields from the table: "campaign_investigator" */
  campaign_investigator_aggregate: Campaign_Investigator_Aggregate;
  /** fetch data from the table: "campaign_investigator" using primary key columns */
  campaign_investigator_by_pk?: Maybe<Campaign_Investigator>;
  /** fetch data from the table: "campaigns_by_cycle" */
  campaigns_by_cycle: Array<Campaigns_By_Cycle>;
  /** fetch aggregated fields from the table: "campaigns_by_cycle" */
  campaigns_by_cycle_aggregate: Campaigns_By_Cycle_Aggregate;
  /** fetch data from the table: "card" */
  card: Array<Card>;
  /** fetch aggregated fields from the table: "card" */
  card_aggregate: Card_Aggregate;
  /** fetch data from the table: "card" using primary key columns */
  card_by_pk?: Maybe<Card>;
  /** fetch data from the table: "card_cycle" */
  card_cycle: Array<Card_Cycle>;
  /** fetch aggregated fields from the table: "card_cycle" */
  card_cycle_aggregate: Card_Cycle_Aggregate;
  /** fetch data from the table: "card_cycle" using primary key columns */
  card_cycle_by_pk?: Maybe<Card_Cycle>;
  /** fetch data from the table: "card_encounter_set" */
  card_encounter_set: Array<Card_Encounter_Set>;
  /** fetch aggregated fields from the table: "card_encounter_set" */
  card_encounter_set_aggregate: Card_Encounter_Set_Aggregate;
  /** fetch data from the table: "card_encounter_set" using primary key columns */
  card_encounter_set_by_pk?: Maybe<Card_Encounter_Set>;
  /** fetch data from the table: "card_pack" */
  card_pack: Array<Card_Pack>;
  /** fetch aggregated fields from the table: "card_pack" */
  card_pack_aggregate: Card_Pack_Aggregate;
  /** fetch data from the table: "card_pack" using primary key columns */
  card_pack_by_pk?: Maybe<Card_Pack>;
  /** fetch data from the table: "card_subtype_name" */
  card_subtype_name: Array<Card_Subtype_Name>;
  /** fetch aggregated fields from the table: "card_subtype_name" */
  card_subtype_name_aggregate: Card_Subtype_Name_Aggregate;
  /** fetch data from the table: "card_subtype_name" using primary key columns */
  card_subtype_name_by_pk?: Maybe<Card_Subtype_Name>;
  /** fetch data from the table: "card_text" */
  card_text: Array<Card_Text>;
  /** fetch aggregated fields from the table: "card_text" */
  card_text_aggregate: Card_Text_Aggregate;
  /** fetch data from the table: "card_text" using primary key columns */
  card_text_by_pk?: Maybe<Card_Text>;
  /** fetch data from the table: "card_type_code" */
  card_type_code: Array<Card_Type_Code>;
  /** fetch aggregated fields from the table: "card_type_code" */
  card_type_code_aggregate: Card_Type_Code_Aggregate;
  /** fetch data from the table: "card_type_code" using primary key columns */
  card_type_code_by_pk?: Maybe<Card_Type_Code>;
  /** fetch data from the table: "card_type_name" */
  card_type_name: Array<Card_Type_Name>;
  /** fetch aggregated fields from the table: "card_type_name" */
  card_type_name_aggregate: Card_Type_Name_Aggregate;
  /** fetch data from the table: "card_type_name" using primary key columns */
  card_type_name_by_pk?: Maybe<Card_Type_Name>;
  /** An array relationship */
  chaos_bag_result: Array<Chaos_Bag_Result>;
  /** An aggregate relationship */
  chaos_bag_result_aggregate: Chaos_Bag_Result_Aggregate;
  /** fetch data from the table: "chaos_bag_result" using primary key columns */
  chaos_bag_result_by_pk?: Maybe<Chaos_Bag_Result>;
  /** fetch data from the table: "chaos_bag_tarot_mode" */
  chaos_bag_tarot_mode: Array<Chaos_Bag_Tarot_Mode>;
  /** fetch aggregated fields from the table: "chaos_bag_tarot_mode" */
  chaos_bag_tarot_mode_aggregate: Chaos_Bag_Tarot_Mode_Aggregate;
  /** fetch data from the table: "chaos_bag_tarot_mode" using primary key columns */
  chaos_bag_tarot_mode_by_pk?: Maybe<Chaos_Bag_Tarot_Mode>;
  /** fetch data from the table: "conquest.card" */
  conquest_card: Array<Conquest_Card>;
  /** fetch aggregated fields from the table: "conquest.card" */
  conquest_card_aggregate: Conquest_Card_Aggregate;
  /** fetch data from the table: "conquest.card" using primary key columns */
  conquest_card_by_pk?: Maybe<Conquest_Card>;
  /** fetch data from the table: "conquest.card_localized" */
  conquest_card_localized: Array<Conquest_Card_Localized>;
  /** fetch aggregated fields from the table: "conquest.card_localized" */
  conquest_card_localized_aggregate: Conquest_Card_Localized_Aggregate;
  /** fetch data from the table: "conquest.card_text" */
  conquest_card_text: Array<Conquest_Card_Text>;
  /** fetch aggregated fields from the table: "conquest.card_text" */
  conquest_card_text_aggregate: Conquest_Card_Text_Aggregate;
  /** fetch data from the table: "conquest.card_text" using primary key columns */
  conquest_card_text_by_pk?: Maybe<Conquest_Card_Text>;
  /** fetch data from the table: "conquest.card_updated" */
  conquest_card_updated: Array<Conquest_Card_Updated>;
  /** fetch aggregated fields from the table: "conquest.card_updated" */
  conquest_card_updated_aggregate: Conquest_Card_Updated_Aggregate;
  /** fetch data from the table: "conquest.comment" */
  conquest_comment: Array<Conquest_Comment>;
  /** fetch aggregated fields from the table: "conquest.comment" */
  conquest_comment_aggregate: Conquest_Comment_Aggregate;
  /** fetch data from the table: "conquest.comment" using primary key columns */
  conquest_comment_by_pk?: Maybe<Conquest_Comment>;
  /** fetch data from the table: "conquest.cycle" */
  conquest_cycle: Array<Conquest_Cycle>;
  /** fetch aggregated fields from the table: "conquest.cycle" */
  conquest_cycle_aggregate: Conquest_Cycle_Aggregate;
  /** fetch data from the table: "conquest.cycle" using primary key columns */
  conquest_cycle_by_pk?: Maybe<Conquest_Cycle>;
  /** fetch data from the table: "conquest.cycle_text" */
  conquest_cycle_text: Array<Conquest_Cycle_Text>;
  /** fetch aggregated fields from the table: "conquest.cycle_text" */
  conquest_cycle_text_aggregate: Conquest_Cycle_Text_Aggregate;
  /** fetch data from the table: "conquest.cycle_text" using primary key columns */
  conquest_cycle_text_by_pk?: Maybe<Conquest_Cycle_Text>;
  /** fetch data from the table: "conquest.deck" */
  conquest_deck: Array<Conquest_Deck>;
  /** fetch aggregated fields from the table: "conquest.deck" */
  conquest_deck_aggregate: Conquest_Deck_Aggregate;
  /** fetch data from the table: "conquest.deck" using primary key columns */
  conquest_deck_by_pk?: Maybe<Conquest_Deck>;
  /** fetch data from the table: "conquest.deck_copy" */
  conquest_deck_copy: Array<Conquest_Deck_Copy>;
  /** fetch aggregated fields from the table: "conquest.deck_copy" */
  conquest_deck_copy_aggregate: Conquest_Deck_Copy_Aggregate;
  /** fetch data from the table: "conquest.deck_copy" using primary key columns */
  conquest_deck_copy_by_pk?: Maybe<Conquest_Deck_Copy>;
  /** fetch data from the table: "conquest.deck_like" */
  conquest_deck_like: Array<Conquest_Deck_Like>;
  /** fetch aggregated fields from the table: "conquest.deck_like" */
  conquest_deck_like_aggregate: Conquest_Deck_Like_Aggregate;
  /** fetch data from the table: "conquest.deck_like" using primary key columns */
  conquest_deck_like_by_pk?: Maybe<Conquest_Deck_Like>;
  /** fetch data from the table: "conquest.faction" */
  conquest_faction: Array<Conquest_Faction>;
  /** fetch aggregated fields from the table: "conquest.faction" */
  conquest_faction_aggregate: Conquest_Faction_Aggregate;
  /** fetch data from the table: "conquest.faction" using primary key columns */
  conquest_faction_by_pk?: Maybe<Conquest_Faction>;
  /** fetch data from the table: "conquest.faction_text" */
  conquest_faction_text: Array<Conquest_Faction_Text>;
  /** fetch aggregated fields from the table: "conquest.faction_text" */
  conquest_faction_text_aggregate: Conquest_Faction_Text_Aggregate;
  /** fetch data from the table: "conquest.faction_text" using primary key columns */
  conquest_faction_text_by_pk?: Maybe<Conquest_Faction_Text>;
  /** fetch data from the table: "conquest.loyalty" */
  conquest_loyalty: Array<Conquest_Loyalty>;
  /** fetch aggregated fields from the table: "conquest.loyalty" */
  conquest_loyalty_aggregate: Conquest_Loyalty_Aggregate;
  /** fetch data from the table: "conquest.loyalty" using primary key columns */
  conquest_loyalty_by_pk?: Maybe<Conquest_Loyalty>;
  /** fetch data from the table: "conquest.loyalty_text" */
  conquest_loyalty_text: Array<Conquest_Loyalty_Text>;
  /** fetch aggregated fields from the table: "conquest.loyalty_text" */
  conquest_loyalty_text_aggregate: Conquest_Loyalty_Text_Aggregate;
  /** fetch data from the table: "conquest.loyalty_text" using primary key columns */
  conquest_loyalty_text_by_pk?: Maybe<Conquest_Loyalty_Text>;
  /** fetch data from the table: "conquest.pack" */
  conquest_pack: Array<Conquest_Pack>;
  /** fetch aggregated fields from the table: "conquest.pack" */
  conquest_pack_aggregate: Conquest_Pack_Aggregate;
  /** fetch data from the table: "conquest.pack" using primary key columns */
  conquest_pack_by_pk?: Maybe<Conquest_Pack>;
  /** fetch data from the table: "conquest.pack_text" */
  conquest_pack_text: Array<Conquest_Pack_Text>;
  /** fetch aggregated fields from the table: "conquest.pack_text" */
  conquest_pack_text_aggregate: Conquest_Pack_Text_Aggregate;
  /** fetch data from the table: "conquest.pack_text" using primary key columns */
  conquest_pack_text_by_pk?: Maybe<Conquest_Pack_Text>;
  /** fetch data from the table: "conquest.type" */
  conquest_type: Array<Conquest_Type>;
  /** fetch aggregated fields from the table: "conquest.type" */
  conquest_type_aggregate: Conquest_Type_Aggregate;
  /** fetch data from the table: "conquest.type" using primary key columns */
  conquest_type_by_pk?: Maybe<Conquest_Type>;
  /** fetch data from the table: "conquest.type_text" */
  conquest_type_text: Array<Conquest_Type_Text>;
  /** fetch aggregated fields from the table: "conquest.type_text" */
  conquest_type_text_aggregate: Conquest_Type_Text_Aggregate;
  /** fetch data from the table: "conquest.type_text" using primary key columns */
  conquest_type_text_by_pk?: Maybe<Conquest_Type_Text>;
  /** fetch data from the table: "conquest.user_role" */
  conquest_user_role: Array<Conquest_User_Role>;
  /** fetch aggregated fields from the table: "conquest.user_role" */
  conquest_user_role_aggregate: Conquest_User_Role_Aggregate;
  /** fetch data from the table: "conquest.user_role" using primary key columns */
  conquest_user_role_by_pk?: Maybe<Conquest_User_Role>;
  /** fetch data from the table: "conquest.user_settings" */
  conquest_user_settings: Array<Conquest_User_Settings>;
  /** fetch aggregated fields from the table: "conquest.user_settings" */
  conquest_user_settings_aggregate: Conquest_User_Settings_Aggregate;
  /** fetch data from the table: "conquest.user_settings" using primary key columns */
  conquest_user_settings_by_pk?: Maybe<Conquest_User_Settings>;
  /** fetch data from the table: "conquest.users" */
  conquest_users: Array<Conquest_Users>;
  /** fetch aggregated fields from the table: "conquest.users" */
  conquest_users_aggregate: Conquest_Users_Aggregate;
  /** fetch data from the table: "conquest.users" using primary key columns */
  conquest_users_by_pk?: Maybe<Conquest_Users>;
  /** fetch data from the table: "cycle" */
  cycle: Array<Cycle>;
  /** fetch aggregated fields from the table: "cycle" */
  cycle_aggregate: Cycle_Aggregate;
  /** fetch data from the table: "cycle" using primary key columns */
  cycle_by_pk?: Maybe<Cycle>;
  /** fetch data from the table: "cycle_name" */
  cycle_name: Array<Cycle_Name>;
  /** fetch aggregated fields from the table: "cycle_name" */
  cycle_name_aggregate: Cycle_Name_Aggregate;
  /** fetch data from the table: "cycle_name" using primary key columns */
  cycle_name_by_pk?: Maybe<Cycle_Name>;
  /** fetch data from the table: "faction_name" */
  faction_name: Array<Faction_Name>;
  /** fetch aggregated fields from the table: "faction_name" */
  faction_name_aggregate: Faction_Name_Aggregate;
  /** fetch data from the table: "faction_name" using primary key columns */
  faction_name_by_pk?: Maybe<Faction_Name>;
  /** fetch data from the table: "faq" */
  faq: Array<Faq>;
  /** fetch aggregated fields from the table: "faq" */
  faq_aggregate: Faq_Aggregate;
  /** fetch data from the table: "faq" using primary key columns */
  faq_by_pk?: Maybe<Faq>;
  /** fetch data from the table: "faq_text" */
  faq_text: Array<Faq_Text>;
  /** fetch aggregated fields from the table: "faq_text" */
  faq_text_aggregate: Faq_Text_Aggregate;
  /** fetch data from the table: "faq_text" using primary key columns */
  faq_text_by_pk?: Maybe<Faq_Text>;
  /** fetch data from the table: "friend_status" */
  friend_status: Array<Friend_Status>;
  /** fetch aggregated fields from the table: "friend_status" */
  friend_status_aggregate: Friend_Status_Aggregate;
  /** fetch data from the table: "friend_status" using primary key columns */
  friend_status_by_pk?: Maybe<Friend_Status>;
  /** fetch data from the table: "friend_status_type" */
  friend_status_type: Array<Friend_Status_Type>;
  /** fetch aggregated fields from the table: "friend_status_type" */
  friend_status_type_aggregate: Friend_Status_Type_Aggregate;
  /** fetch data from the table: "friend_status_type" using primary key columns */
  friend_status_type_by_pk?: Maybe<Friend_Status_Type>;
  /** fetch data from the table: "full_card" */
  full_card: Array<Full_Card>;
  /** fetch aggregated fields from the table: "full_card" */
  full_card_aggregate: Full_Card_Aggregate;
  /** fetch data from the table: "full_card" using primary key columns */
  full_card_by_pk?: Maybe<Full_Card>;
  /** fetch data from the table: "full_card_text" */
  full_card_text: Array<Full_Card_Text>;
  /** fetch aggregated fields from the table: "full_card_text" */
  full_card_text_aggregate: Full_Card_Text_Aggregate;
  /** fetch data from the table: "full_card_text" using primary key columns */
  full_card_text_by_pk?: Maybe<Full_Card_Text>;
  /** fetch data from the table: "gender" */
  gender: Array<Gender>;
  /** fetch aggregated fields from the table: "gender" */
  gender_aggregate: Gender_Aggregate;
  /** fetch data from the table: "gender" using primary key columns */
  gender_by_pk?: Maybe<Gender>;
  /** fetch data from the table: "guide_achievement" */
  guide_achievement: Array<Guide_Achievement>;
  /** fetch aggregated fields from the table: "guide_achievement" */
  guide_achievement_aggregate: Guide_Achievement_Aggregate;
  /** fetch data from the table: "guide_achievement" using primary key columns */
  guide_achievement_by_pk?: Maybe<Guide_Achievement>;
  /** fetch data from the table: "guide_input" */
  guide_input: Array<Guide_Input>;
  /** fetch aggregated fields from the table: "guide_input" */
  guide_input_aggregate: Guide_Input_Aggregate;
  /** fetch data from the table: "guide_input" using primary key columns */
  guide_input_by_pk?: Maybe<Guide_Input>;
  /** An array relationship */
  investigator_data: Array<Investigator_Data>;
  /** An aggregate relationship */
  investigator_data_aggregate: Investigator_Data_Aggregate;
  /** fetch data from the table: "investigator_data" using primary key columns */
  investigator_data_by_pk?: Maybe<Investigator_Data>;
  /** An array relationship */
  latest_decks: Array<Latest_Decks>;
  /** An aggregate relationship */
  latest_decks_aggregate: Latest_Decks_Aggregate;
  /** An array relationship */
  local_decks: Array<Local_Decks>;
  /** An aggregate relationship */
  local_decks_aggregate: Local_Decks_Aggregate;
  /** fetch data from the table: "pack" */
  pack: Array<Pack>;
  /** fetch aggregated fields from the table: "pack" */
  pack_aggregate: Pack_Aggregate;
  /** fetch data from the table: "pack" using primary key columns */
  pack_by_pk?: Maybe<Pack>;
  /** fetch data from the table: "pack_name" */
  pack_name: Array<Pack_Name>;
  /** fetch aggregated fields from the table: "pack_name" */
  pack_name_aggregate: Pack_Name_Aggregate;
  /** fetch data from the table: "pack_name" using primary key columns */
  pack_name_by_pk?: Maybe<Pack_Name>;
  /** fetch data from the table: "rangers.area" */
  rangers_area: Array<Rangers_Area>;
  /** fetch aggregated fields from the table: "rangers.area" */
  rangers_area_aggregate: Rangers_Area_Aggregate;
  /** fetch data from the table: "rangers.area" using primary key columns */
  rangers_area_by_pk?: Maybe<Rangers_Area>;
  /** fetch data from the table: "rangers.area_text" */
  rangers_area_text: Array<Rangers_Area_Text>;
  /** fetch aggregated fields from the table: "rangers.area_text" */
  rangers_area_text_aggregate: Rangers_Area_Text_Aggregate;
  /** fetch data from the table: "rangers.area_text" using primary key columns */
  rangers_area_text_by_pk?: Maybe<Rangers_Area_Text>;
  /** fetch data from the table: "rangers.aspect" */
  rangers_aspect: Array<Rangers_Aspect>;
  /** fetch aggregated fields from the table: "rangers.aspect" */
  rangers_aspect_aggregate: Rangers_Aspect_Aggregate;
  /** fetch data from the table: "rangers.aspect" using primary key columns */
  rangers_aspect_by_pk?: Maybe<Rangers_Aspect>;
  /** fetch data from the table: "rangers.aspect_localized" */
  rangers_aspect_localized: Array<Rangers_Aspect_Localized>;
  /** fetch aggregated fields from the table: "rangers.aspect_localized" */
  rangers_aspect_localized_aggregate: Rangers_Aspect_Localized_Aggregate;
  /** fetch data from the table: "rangers.aspect_text" */
  rangers_aspect_text: Array<Rangers_Aspect_Text>;
  /** fetch aggregated fields from the table: "rangers.aspect_text" */
  rangers_aspect_text_aggregate: Rangers_Aspect_Text_Aggregate;
  /** fetch data from the table: "rangers.aspect_text" using primary key columns */
  rangers_aspect_text_by_pk?: Maybe<Rangers_Aspect_Text>;
  /** fetch data from the table: "rangers.campaign" */
  rangers_campaign: Array<Rangers_Campaign>;
  /** fetch data from the table: "rangers.campaign_access" */
  rangers_campaign_access: Array<Rangers_Campaign_Access>;
  /** fetch aggregated fields from the table: "rangers.campaign_access" */
  rangers_campaign_access_aggregate: Rangers_Campaign_Access_Aggregate;
  /** fetch data from the table: "rangers.campaign_access" using primary key columns */
  rangers_campaign_access_by_pk?: Maybe<Rangers_Campaign_Access>;
  /** fetch aggregated fields from the table: "rangers.campaign" */
  rangers_campaign_aggregate: Rangers_Campaign_Aggregate;
  /** fetch data from the table: "rangers.campaign" using primary key columns */
  rangers_campaign_by_pk?: Maybe<Rangers_Campaign>;
  /** fetch data from the table: "rangers.card" */
  rangers_card: Array<Rangers_Card>;
  /** fetch aggregated fields from the table: "rangers.card" */
  rangers_card_aggregate: Rangers_Card_Aggregate;
  /** fetch data from the table: "rangers.card" using primary key columns */
  rangers_card_by_pk?: Maybe<Rangers_Card>;
  /** fetch data from the table: "rangers.card_localized" */
  rangers_card_localized: Array<Rangers_Card_Localized>;
  /** fetch aggregated fields from the table: "rangers.card_localized" */
  rangers_card_localized_aggregate: Rangers_Card_Localized_Aggregate;
  /** execute function "rangers.card_search" which returns "rangers.card_localized" */
  rangers_card_search: Array<Rangers_Card_Localized>;
  /** execute function "rangers.card_search" and query aggregates on result of table type "rangers.card_localized" */
  rangers_card_search_aggregate: Rangers_Card_Localized_Aggregate;
  /** fetch data from the table: "rangers.card_text" */
  rangers_card_text: Array<Rangers_Card_Text>;
  /** fetch aggregated fields from the table: "rangers.card_text" */
  rangers_card_text_aggregate: Rangers_Card_Text_Aggregate;
  /** fetch data from the table: "rangers.card_text" using primary key columns */
  rangers_card_text_by_pk?: Maybe<Rangers_Card_Text>;
  /** fetch data from the table: "rangers.card_updated" */
  rangers_card_updated: Array<Rangers_Card_Updated>;
  /** fetch aggregated fields from the table: "rangers.card_updated" */
  rangers_card_updated_aggregate: Rangers_Card_Updated_Aggregate;
  /** fetch data from the table: "rangers.comment" */
  rangers_comment: Array<Rangers_Comment>;
  /** fetch aggregated fields from the table: "rangers.comment" */
  rangers_comment_aggregate: Rangers_Comment_Aggregate;
  /** fetch data from the table: "rangers.comment" using primary key columns */
  rangers_comment_by_pk?: Maybe<Rangers_Comment>;
  /** fetch data from the table: "rangers.deck" */
  rangers_deck: Array<Rangers_Deck>;
  /** fetch aggregated fields from the table: "rangers.deck" */
  rangers_deck_aggregate: Rangers_Deck_Aggregate;
  /** fetch data from the table: "rangers.deck" using primary key columns */
  rangers_deck_by_pk?: Maybe<Rangers_Deck>;
  /** fetch data from the table: "rangers.deck_copy" */
  rangers_deck_copy: Array<Rangers_Deck_Copy>;
  /** fetch aggregated fields from the table: "rangers.deck_copy" */
  rangers_deck_copy_aggregate: Rangers_Deck_Copy_Aggregate;
  /** fetch data from the table: "rangers.deck_copy" using primary key columns */
  rangers_deck_copy_by_pk?: Maybe<Rangers_Deck_Copy>;
  /** fetch data from the table: "rangers.deck_like" */
  rangers_deck_like: Array<Rangers_Deck_Like>;
  /** fetch aggregated fields from the table: "rangers.deck_like" */
  rangers_deck_like_aggregate: Rangers_Deck_Like_Aggregate;
  /** fetch data from the table: "rangers.deck_like" using primary key columns */
  rangers_deck_like_by_pk?: Maybe<Rangers_Deck_Like>;
  /** fetch data from the table: "rangers.deck_like_count" */
  rangers_deck_like_count: Array<Rangers_Deck_Like_Count>;
  /** fetch aggregated fields from the table: "rangers.deck_like_count" */
  rangers_deck_like_count_aggregate: Rangers_Deck_Like_Count_Aggregate;
  /** fetch data from the table: "rangers.deck_like_count" using primary key columns */
  rangers_deck_like_count_by_pk?: Maybe<Rangers_Deck_Like_Count>;
  /** fetch data from the table: "rangers.deck_rank" */
  rangers_deck_rank: Array<Rangers_Deck_Rank>;
  /** fetch aggregated fields from the table: "rangers.deck_rank" */
  rangers_deck_rank_aggregate: Rangers_Deck_Rank_Aggregate;
  /** execute function "rangers.deck_search" which returns "rangers.search_deck" */
  rangers_deck_search: Array<Rangers_Search_Deck>;
  /** execute function "rangers.deck_search" and query aggregates on result of table type "rangers.search_deck" */
  rangers_deck_search_aggregate: Rangers_Search_Deck_Aggregate;
  /** fetch data from the table: "rangers.faq_entry" */
  rangers_faq_entry: Array<Rangers_Faq_Entry>;
  /** fetch aggregated fields from the table: "rangers.faq_entry" */
  rangers_faq_entry_aggregate: Rangers_Faq_Entry_Aggregate;
  /** fetch data from the table: "rangers.faq_entry" using primary key columns */
  rangers_faq_entry_by_pk?: Maybe<Rangers_Faq_Entry>;
  /** fetch data from the table: "rangers.friend_status" */
  rangers_friend_status: Array<Rangers_Friend_Status>;
  /** fetch aggregated fields from the table: "rangers.friend_status" */
  rangers_friend_status_aggregate: Rangers_Friend_Status_Aggregate;
  /** fetch data from the table: "rangers.friend_status" using primary key columns */
  rangers_friend_status_by_pk?: Maybe<Rangers_Friend_Status>;
  /** fetch data from the table: "rangers.friend_status_type" */
  rangers_friend_status_type: Array<Rangers_Friend_Status_Type>;
  /** fetch aggregated fields from the table: "rangers.friend_status_type" */
  rangers_friend_status_type_aggregate: Rangers_Friend_Status_Type_Aggregate;
  /** fetch data from the table: "rangers.friend_status_type" using primary key columns */
  rangers_friend_status_type_by_pk?: Maybe<Rangers_Friend_Status_Type>;
  /** fetch data from the table: "rangers.latest_deck" */
  rangers_latest_deck: Array<Rangers_Latest_Deck>;
  /** fetch aggregated fields from the table: "rangers.latest_deck" */
  rangers_latest_deck_aggregate: Rangers_Latest_Deck_Aggregate;
  /** fetch data from the table: "rangers.locale" */
  rangers_locale: Array<Rangers_Locale>;
  /** fetch aggregated fields from the table: "rangers.locale" */
  rangers_locale_aggregate: Rangers_Locale_Aggregate;
  /** fetch data from the table: "rangers.locale" using primary key columns */
  rangers_locale_by_pk?: Maybe<Rangers_Locale>;
  /** fetch data from the table: "rangers.pack" */
  rangers_pack: Array<Rangers_Pack>;
  /** fetch aggregated fields from the table: "rangers.pack" */
  rangers_pack_aggregate: Rangers_Pack_Aggregate;
  /** fetch data from the table: "rangers.pack" using primary key columns */
  rangers_pack_by_pk?: Maybe<Rangers_Pack>;
  /** fetch data from the table: "rangers.pack_localized" */
  rangers_pack_localized: Array<Rangers_Pack_Localized>;
  /** fetch aggregated fields from the table: "rangers.pack_localized" */
  rangers_pack_localized_aggregate: Rangers_Pack_Localized_Aggregate;
  /** fetch data from the table: "rangers.pack_text" */
  rangers_pack_text: Array<Rangers_Pack_Text>;
  /** fetch aggregated fields from the table: "rangers.pack_text" */
  rangers_pack_text_aggregate: Rangers_Pack_Text_Aggregate;
  /** fetch data from the table: "rangers.pack_text" using primary key columns */
  rangers_pack_text_by_pk?: Maybe<Rangers_Pack_Text>;
  /** execute function "rangers.search_all_decks" which returns "rangers.search_deck" */
  rangers_search_all_decks: Array<Rangers_Search_Deck>;
  /** execute function "rangers.search_all_decks" and query aggregates on result of table type "rangers.search_deck" */
  rangers_search_all_decks_aggregate: Rangers_Search_Deck_Aggregate;
  /** fetch data from the table: "rangers.search_deck" */
  rangers_search_deck: Array<Rangers_Search_Deck>;
  /** fetch aggregated fields from the table: "rangers.search_deck" */
  rangers_search_deck_aggregate: Rangers_Search_Deck_Aggregate;
  /** fetch data from the table: "rangers.set" */
  rangers_set: Array<Rangers_Set>;
  /** fetch aggregated fields from the table: "rangers.set" */
  rangers_set_aggregate: Rangers_Set_Aggregate;
  /** fetch data from the table: "rangers.set" using primary key columns */
  rangers_set_by_pk?: Maybe<Rangers_Set>;
  /** fetch data from the table: "rangers.set_localized" */
  rangers_set_localized: Array<Rangers_Set_Localized>;
  /** fetch aggregated fields from the table: "rangers.set_localized" */
  rangers_set_localized_aggregate: Rangers_Set_Localized_Aggregate;
  /** fetch data from the table: "rangers.set_text" */
  rangers_set_text: Array<Rangers_Set_Text>;
  /** fetch aggregated fields from the table: "rangers.set_text" */
  rangers_set_text_aggregate: Rangers_Set_Text_Aggregate;
  /** fetch data from the table: "rangers.set_text" using primary key columns */
  rangers_set_text_by_pk?: Maybe<Rangers_Set_Text>;
  /** fetch data from the table: "rangers.set_type" */
  rangers_set_type: Array<Rangers_Set_Type>;
  /** fetch aggregated fields from the table: "rangers.set_type" */
  rangers_set_type_aggregate: Rangers_Set_Type_Aggregate;
  /** fetch data from the table: "rangers.set_type" using primary key columns */
  rangers_set_type_by_pk?: Maybe<Rangers_Set_Type>;
  /** fetch data from the table: "rangers.set_type_localized" */
  rangers_set_type_localized: Array<Rangers_Set_Type_Localized>;
  /** fetch aggregated fields from the table: "rangers.set_type_localized" */
  rangers_set_type_localized_aggregate: Rangers_Set_Type_Localized_Aggregate;
  /** fetch data from the table: "rangers.set_type_text" */
  rangers_set_type_text: Array<Rangers_Set_Type_Text>;
  /** fetch aggregated fields from the table: "rangers.set_type_text" */
  rangers_set_type_text_aggregate: Rangers_Set_Type_Text_Aggregate;
  /** fetch data from the table: "rangers.set_type_text" using primary key columns */
  rangers_set_type_text_by_pk?: Maybe<Rangers_Set_Type_Text>;
  /** fetch data from the table: "rangers.subset" */
  rangers_subset: Array<Rangers_Subset>;
  /** fetch aggregated fields from the table: "rangers.subset" */
  rangers_subset_aggregate: Rangers_Subset_Aggregate;
  /** fetch data from the table: "rangers.subset" using primary key columns */
  rangers_subset_by_pk?: Maybe<Rangers_Subset>;
  /** fetch data from the table: "rangers.subset_localized" */
  rangers_subset_localized: Array<Rangers_Subset_Localized>;
  /** fetch aggregated fields from the table: "rangers.subset_localized" */
  rangers_subset_localized_aggregate: Rangers_Subset_Localized_Aggregate;
  /** fetch data from the table: "rangers.subset_text" */
  rangers_subset_text: Array<Rangers_Subset_Text>;
  /** fetch aggregated fields from the table: "rangers.subset_text" */
  rangers_subset_text_aggregate: Rangers_Subset_Text_Aggregate;
  /** fetch data from the table: "rangers.subset_text" using primary key columns */
  rangers_subset_text_by_pk?: Maybe<Rangers_Subset_Text>;
  /** fetch data from the table: "rangers.taboo_set" */
  rangers_taboo_set: Array<Rangers_Taboo_Set>;
  /** fetch aggregated fields from the table: "rangers.taboo_set" */
  rangers_taboo_set_aggregate: Rangers_Taboo_Set_Aggregate;
  /** fetch data from the table: "rangers.taboo_set" using primary key columns */
  rangers_taboo_set_by_pk?: Maybe<Rangers_Taboo_Set>;
  /** fetch data from the table: "rangers.taboo_set_localized" */
  rangers_taboo_set_localized: Array<Rangers_Taboo_Set_Localized>;
  /** fetch aggregated fields from the table: "rangers.taboo_set_localized" */
  rangers_taboo_set_localized_aggregate: Rangers_Taboo_Set_Localized_Aggregate;
  /** fetch data from the table: "rangers.taboo_set_text" */
  rangers_taboo_set_text: Array<Rangers_Taboo_Set_Text>;
  /** fetch aggregated fields from the table: "rangers.taboo_set_text" */
  rangers_taboo_set_text_aggregate: Rangers_Taboo_Set_Text_Aggregate;
  /** fetch data from the table: "rangers.taboo_set_text" using primary key columns */
  rangers_taboo_set_text_by_pk?: Maybe<Rangers_Taboo_Set_Text>;
  /** fetch data from the table: "rangers.token" */
  rangers_token: Array<Rangers_Token>;
  /** fetch aggregated fields from the table: "rangers.token" */
  rangers_token_aggregate: Rangers_Token_Aggregate;
  /** fetch data from the table: "rangers.token" using primary key columns */
  rangers_token_by_pk?: Maybe<Rangers_Token>;
  /** fetch data from the table: "rangers.token_text" */
  rangers_token_text: Array<Rangers_Token_Text>;
  /** fetch aggregated fields from the table: "rangers.token_text" */
  rangers_token_text_aggregate: Rangers_Token_Text_Aggregate;
  /** fetch data from the table: "rangers.token_text" using primary key columns */
  rangers_token_text_by_pk?: Maybe<Rangers_Token_Text>;
  /** fetch data from the table: "rangers.type" */
  rangers_type: Array<Rangers_Type>;
  /** fetch aggregated fields from the table: "rangers.type" */
  rangers_type_aggregate: Rangers_Type_Aggregate;
  /** fetch data from the table: "rangers.type" using primary key columns */
  rangers_type_by_pk?: Maybe<Rangers_Type>;
  /** fetch data from the table: "rangers.type_localized" */
  rangers_type_localized: Array<Rangers_Type_Localized>;
  /** fetch aggregated fields from the table: "rangers.type_localized" */
  rangers_type_localized_aggregate: Rangers_Type_Localized_Aggregate;
  /** fetch data from the table: "rangers.type_text" */
  rangers_type_text: Array<Rangers_Type_Text>;
  /** fetch aggregated fields from the table: "rangers.type_text" */
  rangers_type_text_aggregate: Rangers_Type_Text_Aggregate;
  /** fetch data from the table: "rangers.type_text" using primary key columns */
  rangers_type_text_by_pk?: Maybe<Rangers_Type_Text>;
  /** fetch data from the table: "rangers.user_campaign" */
  rangers_user_campaign: Array<Rangers_User_Campaign>;
  /** fetch aggregated fields from the table: "rangers.user_campaign" */
  rangers_user_campaign_aggregate: Rangers_User_Campaign_Aggregate;
  /** fetch data from the table: "rangers.user_friends" */
  rangers_user_friends: Array<Rangers_User_Friends>;
  /** fetch aggregated fields from the table: "rangers.user_friends" */
  rangers_user_friends_aggregate: Rangers_User_Friends_Aggregate;
  /** fetch data from the table: "rangers.user_received_friend_requests" */
  rangers_user_received_friend_requests: Array<Rangers_User_Received_Friend_Requests>;
  /** fetch aggregated fields from the table: "rangers.user_received_friend_requests" */
  rangers_user_received_friend_requests_aggregate: Rangers_User_Received_Friend_Requests_Aggregate;
  /** fetch data from the table: "rangers.user_role" */
  rangers_user_role: Array<Rangers_User_Role>;
  /** fetch aggregated fields from the table: "rangers.user_role" */
  rangers_user_role_aggregate: Rangers_User_Role_Aggregate;
  /** fetch data from the table: "rangers.user_role" using primary key columns */
  rangers_user_role_by_pk?: Maybe<Rangers_User_Role>;
  /** fetch data from the table: "rangers.user_sent_friend_requests" */
  rangers_user_sent_friend_requests: Array<Rangers_User_Sent_Friend_Requests>;
  /** fetch aggregated fields from the table: "rangers.user_sent_friend_requests" */
  rangers_user_sent_friend_requests_aggregate: Rangers_User_Sent_Friend_Requests_Aggregate;
  /** fetch data from the table: "rangers.user_settings" */
  rangers_user_settings: Array<Rangers_User_Settings>;
  /** fetch aggregated fields from the table: "rangers.user_settings" */
  rangers_user_settings_aggregate: Rangers_User_Settings_Aggregate;
  /** fetch data from the table: "rangers.user_settings" using primary key columns */
  rangers_user_settings_by_pk?: Maybe<Rangers_User_Settings>;
  /** fetch data from the table: "rangers.users" */
  rangers_users: Array<Rangers_Users>;
  /** fetch aggregated fields from the table: "rangers.users" */
  rangers_users_aggregate: Rangers_Users_Aggregate;
  /** fetch data from the table: "rangers.users" using primary key columns */
  rangers_users_by_pk?: Maybe<Rangers_Users>;
  /** fetch data from the table: "taboo_set" */
  taboo_set: Array<Taboo_Set>;
  /** fetch aggregated fields from the table: "taboo_set" */
  taboo_set_aggregate: Taboo_Set_Aggregate;
  /** fetch data from the table: "taboo_set" using primary key columns */
  taboo_set_by_pk?: Maybe<Taboo_Set>;
  /** fetch data from the table: "user_campaigns" */
  user_campaigns: Array<User_Campaigns>;
  /** fetch aggregated fields from the table: "user_campaigns" */
  user_campaigns_aggregate: User_Campaigns_Aggregate;
  /** fetch data from the table: "user_flag" */
  user_flag: Array<User_Flag>;
  /** fetch aggregated fields from the table: "user_flag" */
  user_flag_aggregate: User_Flag_Aggregate;
  /** fetch data from the table: "user_flag" using primary key columns */
  user_flag_by_pk?: Maybe<User_Flag>;
  /** fetch data from the table: "user_flag_type" */
  user_flag_type: Array<User_Flag_Type>;
  /** fetch aggregated fields from the table: "user_flag_type" */
  user_flag_type_aggregate: User_Flag_Type_Aggregate;
  /** fetch data from the table: "user_flag_type" using primary key columns */
  user_flag_type_by_pk?: Maybe<User_Flag_Type>;
  /** fetch data from the table: "user_friends" */
  user_friends: Array<User_Friends>;
  /** fetch aggregated fields from the table: "user_friends" */
  user_friends_aggregate: User_Friends_Aggregate;
  /** fetch data from the table: "user_received_friend_requests" */
  user_received_friend_requests: Array<User_Received_Friend_Requests>;
  /** fetch aggregated fields from the table: "user_received_friend_requests" */
  user_received_friend_requests_aggregate: User_Received_Friend_Requests_Aggregate;
  /** fetch data from the table: "user_sent_friend_requests" */
  user_sent_friend_requests: Array<User_Sent_Friend_Requests>;
  /** fetch aggregated fields from the table: "user_sent_friend_requests" */
  user_sent_friend_requests_aggregate: User_Sent_Friend_Requests_Aggregate;
  /** fetch data from the table: "user_settings" */
  user_settings: Array<User_Settings>;
  /** fetch aggregated fields from the table: "user_settings" */
  user_settings_aggregate: User_Settings_Aggregate;
  /** fetch data from the table: "user_settings" using primary key columns */
  user_settings_by_pk?: Maybe<User_Settings>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  usersSearch?: Maybe<UsersSearchOutput>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
};


export type Query_RootAll_CardArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


export type Query_RootAll_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


export type Query_RootAll_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootAll_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


export type Query_RootAll_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


export type Query_RootAll_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootAll_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_Order_By>>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};


export type Query_RootAll_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_Order_By>>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};


export type Query_RootAll_Card_Updated_By_PkArgs = {
  locale: Scalars['String']['input'];
};


export type Query_RootAll_Card_Updated_By_VersionArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_By_Version_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_By_Version_Order_By>>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};


export type Query_RootAll_Card_Updated_By_Version_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_By_Version_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_By_Version_Order_By>>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};


export type Query_RootAll_Card_Updated_By_Version_By_PkArgs = {
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
};


export type Query_RootArkhamdb_AuthArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Auth_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Auth_Order_By>>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};


export type Query_RootArkhamdb_Auth_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Auth_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Auth_Order_By>>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};


export type Query_RootArkhamdb_Auth_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Query_RootArkhamdb_DeckArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Deck_Order_By>>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};


export type Query_RootArkhamdb_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Deck_Order_By>>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};


export type Query_RootArkhamdb_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootBase_DecksArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


export type Query_RootBase_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


export type Query_RootCampaignArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Order_By>>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};


export type Query_RootCampaign_AccessArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


export type Query_RootCampaign_Access_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


export type Query_RootCampaign_Access_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootCampaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Order_By>>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};


export type Query_RootCampaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootCampaign_DeckArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


export type Query_RootCampaign_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


export type Query_RootCampaign_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootCampaign_DifficultyArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Difficulty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Difficulty_Order_By>>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};


export type Query_RootCampaign_Difficulty_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Difficulty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Difficulty_Order_By>>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};


export type Query_RootCampaign_Difficulty_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootCampaign_GuideArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Guide_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Guide_Order_By>>;
  where?: InputMaybe<Campaign_Guide_Bool_Exp>;
};


export type Query_RootCampaign_Guide_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Guide_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Guide_Order_By>>;
  where?: InputMaybe<Campaign_Guide_Bool_Exp>;
};


export type Query_RootCampaign_InvestigatorArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


export type Query_RootCampaign_Investigator_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


export type Query_RootCampaign_Investigator_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


export type Query_RootCampaigns_By_CycleArgs = {
  distinct_on?: InputMaybe<Array<Campaigns_By_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaigns_By_Cycle_Order_By>>;
  where?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
};


export type Query_RootCampaigns_By_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaigns_By_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaigns_By_Cycle_Order_By>>;
  where?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
};


export type Query_RootCardArgs = {
  distinct_on?: InputMaybe<Array<Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Order_By>>;
  where?: InputMaybe<Card_Bool_Exp>;
};


export type Query_RootCard_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Order_By>>;
  where?: InputMaybe<Card_Bool_Exp>;
};


export type Query_RootCard_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootCard_CycleArgs = {
  distinct_on?: InputMaybe<Array<Card_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Cycle_Order_By>>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};


export type Query_RootCard_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Cycle_Order_By>>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};


export type Query_RootCard_Cycle_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootCard_Encounter_SetArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


export type Query_RootCard_Encounter_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


export type Query_RootCard_Encounter_Set_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootCard_PackArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


export type Query_RootCard_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


export type Query_RootCard_Pack_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootCard_Subtype_NameArgs = {
  distinct_on?: InputMaybe<Array<Card_Subtype_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Subtype_Name_Order_By>>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};


export type Query_RootCard_Subtype_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Subtype_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Subtype_Name_Order_By>>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};


export type Query_RootCard_Subtype_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootCard_TextArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


export type Query_RootCard_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


export type Query_RootCard_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootCard_Type_CodeArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Code_Order_By>>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};


export type Query_RootCard_Type_Code_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Code_Order_By>>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};


export type Query_RootCard_Type_Code_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootCard_Type_NameArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Name_Order_By>>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};


export type Query_RootCard_Type_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Name_Order_By>>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};


export type Query_RootCard_Type_Name_By_PkArgs = {
  code: Card_Type_Code_Enum;
  locale: Scalars['String']['input'];
};


export type Query_RootChaos_Bag_ResultArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


export type Query_RootChaos_Bag_Result_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


export type Query_RootChaos_Bag_Result_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootChaos_Bag_Tarot_ModeArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};


export type Query_RootChaos_Bag_Tarot_Mode_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};


export type Query_RootChaos_Bag_Tarot_Mode_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootConquest_CardArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Order_By>>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};


export type Query_RootConquest_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Order_By>>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};


export type Query_RootConquest_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Card_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Localized_Order_By>>;
  where?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
};


export type Query_RootConquest_Card_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Localized_Order_By>>;
  where?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
};


export type Query_RootConquest_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Text_Order_By>>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};


export type Query_RootConquest_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Text_Order_By>>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};


export type Query_RootConquest_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Updated_Order_By>>;
  where?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
};


export type Query_RootConquest_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Updated_Order_By>>;
  where?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
};


export type Query_RootConquest_CommentArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


export type Query_RootConquest_Comment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


export type Query_RootConquest_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootConquest_CycleArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};


export type Query_RootConquest_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};


export type Query_RootConquest_Cycle_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Cycle_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Text_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};


export type Query_RootConquest_Cycle_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Text_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};


export type Query_RootConquest_Cycle_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_DeckArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


export type Query_RootConquest_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


export type Query_RootConquest_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootConquest_Deck_CopyArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Copy_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};


export type Query_RootConquest_Deck_Copy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Copy_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};


export type Query_RootConquest_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


export type Query_RootConquest_Deck_LikeArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Like_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};


export type Query_RootConquest_Deck_Like_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Like_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};


export type Query_RootConquest_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Query_RootConquest_FactionArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};


export type Query_RootConquest_Faction_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};


export type Query_RootConquest_Faction_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Faction_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Text_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};


export type Query_RootConquest_Faction_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Text_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};


export type Query_RootConquest_Faction_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_LoyaltyArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};


export type Query_RootConquest_Loyalty_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};


export type Query_RootConquest_Loyalty_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Loyalty_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Text_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};


export type Query_RootConquest_Loyalty_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Text_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};


export type Query_RootConquest_Loyalty_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_PackArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};


export type Query_RootConquest_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};


export type Query_RootConquest_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Pack_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Text_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};


export type Query_RootConquest_Pack_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Text_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};


export type Query_RootConquest_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_TypeArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Order_By>>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};


export type Query_RootConquest_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Order_By>>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};


export type Query_RootConquest_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Text_Order_By>>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};


export type Query_RootConquest_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Text_Order_By>>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};


export type Query_RootConquest_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_User_RoleArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Role_Order_By>>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};


export type Query_RootConquest_User_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Role_Order_By>>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};


export type Query_RootConquest_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_User_SettingsArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


export type Query_RootConquest_User_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


export type Query_RootConquest_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Query_RootConquest_UsersArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Users_Order_By>>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};


export type Query_RootConquest_Users_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Users_Order_By>>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};


export type Query_RootConquest_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootCycleArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Order_By>>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};


export type Query_RootCycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Order_By>>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};


export type Query_RootCycle_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootCycle_NameArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


export type Query_RootCycle_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


export type Query_RootCycle_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootFaction_NameArgs = {
  distinct_on?: InputMaybe<Array<Faction_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faction_Name_Order_By>>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};


export type Query_RootFaction_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faction_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faction_Name_Order_By>>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};


export type Query_RootFaction_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootFaqArgs = {
  distinct_on?: InputMaybe<Array<Faq_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Order_By>>;
  where?: InputMaybe<Faq_Bool_Exp>;
};


export type Query_RootFaq_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faq_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Order_By>>;
  where?: InputMaybe<Faq_Bool_Exp>;
};


export type Query_RootFaq_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootFaq_TextArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


export type Query_RootFaq_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


export type Query_RootFaq_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootFriend_StatusArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Order_By>>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};


export type Query_RootFriend_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Order_By>>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};


export type Query_RootFriend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


export type Query_RootFriend_Status_TypeArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};


export type Query_RootFriend_Status_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};


export type Query_RootFriend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootFull_CardArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Order_By>>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};


export type Query_RootFull_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Order_By>>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};


export type Query_RootFull_Card_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootFull_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


export type Query_RootFull_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


export type Query_RootFull_Card_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootGenderArgs = {
  distinct_on?: InputMaybe<Array<Gender_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Gender_Order_By>>;
  where?: InputMaybe<Gender_Bool_Exp>;
};


export type Query_RootGender_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Gender_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Gender_Order_By>>;
  where?: InputMaybe<Gender_Bool_Exp>;
};


export type Query_RootGender_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootGuide_AchievementArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


export type Query_RootGuide_Achievement_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


export type Query_RootGuide_Achievement_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


export type Query_RootGuide_InputArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


export type Query_RootGuide_Input_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


export type Query_RootGuide_Input_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


export type Query_RootInvestigator_DataArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


export type Query_RootInvestigator_Data_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


export type Query_RootInvestigator_Data_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


export type Query_RootLatest_DecksArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


export type Query_RootLatest_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


export type Query_RootLocal_DecksArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


export type Query_RootLocal_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


export type Query_RootPackArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


export type Query_RootPack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


export type Query_RootPack_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootPack_NameArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


export type Query_RootPack_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


export type Query_RootPack_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_AreaArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Order_By>>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};


export type Query_RootRangers_Area_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Order_By>>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};


export type Query_RootRangers_Area_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Area_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Text_Order_By>>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};


export type Query_RootRangers_Area_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Text_Order_By>>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};


export type Query_RootRangers_Area_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_AspectArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};


export type Query_RootRangers_Aspect_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};


export type Query_RootRangers_Aspect_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Aspect_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
};


export type Query_RootRangers_Aspect_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
};


export type Query_RootRangers_Aspect_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Text_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};


export type Query_RootRangers_Aspect_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Text_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};


export type Query_RootRangers_Aspect_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_CampaignArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


export type Query_RootRangers_Campaign_AccessArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Access_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};


export type Query_RootRangers_Campaign_Access_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Access_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};


export type Query_RootRangers_Campaign_Access_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Query_RootRangers_Campaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


export type Query_RootRangers_Campaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootRangers_CardArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Order_By>>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};


export type Query_RootRangers_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Order_By>>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};


export type Query_RootRangers_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Card_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Query_RootRangers_Card_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Query_RootRangers_Card_SearchArgs = {
  args?: InputMaybe<Rangers_Card_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Query_RootRangers_Card_Search_AggregateArgs = {
  args?: InputMaybe<Rangers_Card_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Query_RootRangers_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


export type Query_RootRangers_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


export type Query_RootRangers_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Updated_Order_By>>;
  where?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
};


export type Query_RootRangers_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Updated_Order_By>>;
  where?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
};


export type Query_RootRangers_CommentArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


export type Query_RootRangers_Comment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


export type Query_RootRangers_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootRangers_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


export type Query_RootRangers_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


export type Query_RootRangers_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootRangers_Deck_CopyArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Copy_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};


export type Query_RootRangers_Deck_Copy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Copy_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};


export type Query_RootRangers_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


export type Query_RootRangers_Deck_LikeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};


export type Query_RootRangers_Deck_Like_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};


export type Query_RootRangers_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Query_RootRangers_Deck_Like_CountArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Count_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Count_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};


export type Query_RootRangers_Deck_Like_Count_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Count_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Count_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};


export type Query_RootRangers_Deck_Like_Count_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
};


export type Query_RootRangers_Deck_RankArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Rank_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Rank_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
};


export type Query_RootRangers_Deck_Rank_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Rank_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Rank_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
};


export type Query_RootRangers_Deck_SearchArgs = {
  args?: InputMaybe<Rangers_Deck_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Query_RootRangers_Deck_Search_AggregateArgs = {
  args?: InputMaybe<Rangers_Deck_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Query_RootRangers_Faq_EntryArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Faq_Entry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Faq_Entry_Order_By>>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};


export type Query_RootRangers_Faq_Entry_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Faq_Entry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Faq_Entry_Order_By>>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};


export type Query_RootRangers_Faq_Entry_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Friend_StatusArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};


export type Query_RootRangers_Friend_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};


export type Query_RootRangers_Friend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


export type Query_RootRangers_Friend_Status_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};


export type Query_RootRangers_Friend_Status_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};


export type Query_RootRangers_Friend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootRangers_Latest_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


export type Query_RootRangers_Latest_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


export type Query_RootRangers_LocaleArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Locale_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Locale_Order_By>>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};


export type Query_RootRangers_Locale_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Locale_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Locale_Order_By>>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};


export type Query_RootRangers_Locale_By_PkArgs = {
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_PackArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};


export type Query_RootRangers_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};


export type Query_RootRangers_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Pack_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Localized_Bool_Exp>;
};


export type Query_RootRangers_Pack_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Localized_Bool_Exp>;
};


export type Query_RootRangers_Pack_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


export type Query_RootRangers_Pack_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


export type Query_RootRangers_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_Search_All_DecksArgs = {
  args?: InputMaybe<Rangers_Search_All_Decks_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Query_RootRangers_Search_All_Decks_AggregateArgs = {
  args?: InputMaybe<Rangers_Search_All_Decks_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Query_RootRangers_Search_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Query_RootRangers_Search_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Query_RootRangers_SetArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Order_By>>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};


export type Query_RootRangers_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Order_By>>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};


export type Query_RootRangers_Set_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Set_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


export type Query_RootRangers_Set_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


export type Query_RootRangers_Set_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


export type Query_RootRangers_Set_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


export type Query_RootRangers_Set_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_Set_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Set_Type_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_SubsetArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Bool_Exp>;
};


export type Query_RootRangers_Subset_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Bool_Exp>;
};


export type Query_RootRangers_Subset_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Subset_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Localized_Bool_Exp>;
};


export type Query_RootRangers_Subset_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Localized_Bool_Exp>;
};


export type Query_RootRangers_Subset_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Text_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Text_Bool_Exp>;
};


export type Query_RootRangers_Subset_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Text_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Text_Bool_Exp>;
};


export type Query_RootRangers_Subset_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_Taboo_SetArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Bool_Exp>;
};


export type Query_RootRangers_Taboo_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Bool_Exp>;
};


export type Query_RootRangers_Taboo_Set_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Taboo_Set_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Localized_Bool_Exp>;
};


export type Query_RootRangers_Taboo_Set_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Localized_Bool_Exp>;
};


export type Query_RootRangers_Taboo_Set_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Text_Bool_Exp>;
};


export type Query_RootRangers_Taboo_Set_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Text_Bool_Exp>;
};


export type Query_RootRangers_Taboo_Set_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_TokenArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Order_By>>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};


export type Query_RootRangers_Token_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Order_By>>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};


export type Query_RootRangers_Token_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Token_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Text_Order_By>>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};


export type Query_RootRangers_Token_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Text_Order_By>>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};


export type Query_RootRangers_Token_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Order_By>>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};


export type Query_RootRangers_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Order_By>>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};


export type Query_RootRangers_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Type_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
};


export type Query_RootRangers_Type_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
};


export type Query_RootRangers_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};


export type Query_RootRangers_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};


export type Query_RootRangers_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_User_CampaignArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


export type Query_RootRangers_User_Campaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


export type Query_RootRangers_User_FriendsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


export type Query_RootRangers_User_Friends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


export type Query_RootRangers_User_Received_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


export type Query_RootRangers_User_Received_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


export type Query_RootRangers_User_RoleArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Role_Order_By>>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};


export type Query_RootRangers_User_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Role_Order_By>>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};


export type Query_RootRangers_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_User_Sent_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


export type Query_RootRangers_User_Sent_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


export type Query_RootRangers_User_SettingsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Settings_Order_By>>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};


export type Query_RootRangers_User_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Settings_Order_By>>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};


export type Query_RootRangers_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Query_RootRangers_UsersArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Users_Order_By>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


export type Query_RootRangers_Users_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Users_Order_By>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


export type Query_RootRangers_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootTaboo_SetArgs = {
  distinct_on?: InputMaybe<Array<Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Taboo_Set_Order_By>>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};


export type Query_RootTaboo_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Taboo_Set_Order_By>>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};


export type Query_RootTaboo_Set_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootUser_CampaignsArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


export type Query_RootUser_Campaigns_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


export type Query_RootUser_FlagArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


export type Query_RootUser_Flag_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


export type Query_RootUser_Flag_By_PkArgs = {
  flag: User_Flag_Type_Enum;
  user_id: Scalars['String']['input'];
};


export type Query_RootUser_Flag_TypeArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Type_Order_By>>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};


export type Query_RootUser_Flag_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Type_Order_By>>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};


export type Query_RootUser_Flag_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootUser_FriendsArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


export type Query_RootUser_Friends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


export type Query_RootUser_Received_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


export type Query_RootUser_Received_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


export type Query_RootUser_Sent_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


export type Query_RootUser_Sent_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


export type Query_RootUser_SettingsArgs = {
  distinct_on?: InputMaybe<Array<User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Settings_Order_By>>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};


export type Query_RootUser_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Settings_Order_By>>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};


export type Query_RootUser_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Query_RootUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsersSearchArgs = {
  args: UsersSearchInput;
};


export type Query_RootUsers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsers_By_PkArgs = {
  id: Scalars['String']['input'];
};

/** columns and relationships of "rangers.area" */
export type Rangers_Area = {
  __typename?: 'rangers_area';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.area" */
export type Rangers_Area_Aggregate = {
  __typename?: 'rangers_area_aggregate';
  aggregate?: Maybe<Rangers_Area_Aggregate_Fields>;
  nodes: Array<Rangers_Area>;
};

/** aggregate fields of "rangers.area" */
export type Rangers_Area_Aggregate_Fields = {
  __typename?: 'rangers_area_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Area_Max_Fields>;
  min?: Maybe<Rangers_Area_Min_Fields>;
};


/** aggregate fields of "rangers.area" */
export type Rangers_Area_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Area_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.area". All fields are combined with a logical 'AND'. */
export type Rangers_Area_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Area_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Area_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Area_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.area" */
export enum Rangers_Area_Constraint {
  /** unique or primary key constraint on columns "id" */
  AreaPkey = 'area_pkey'
}

/** input type for inserting data into table "rangers.area" */
export type Rangers_Area_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Area_Max_Fields = {
  __typename?: 'rangers_area_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Area_Min_Fields = {
  __typename?: 'rangers_area_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.area" */
export type Rangers_Area_Mutation_Response = {
  __typename?: 'rangers_area_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Area>;
};

/** on_conflict condition type for table "rangers.area" */
export type Rangers_Area_On_Conflict = {
  constraint: Rangers_Area_Constraint;
  update_columns?: Array<Rangers_Area_Update_Column>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.area". */
export type Rangers_Area_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.area */
export type Rangers_Area_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.area" */
export enum Rangers_Area_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.area" */
export type Rangers_Area_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_area" */
export type Rangers_Area_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Area_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Area_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.area_text" */
export type Rangers_Area_Text = {
  __typename?: 'rangers_area_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.area_text" */
export type Rangers_Area_Text_Aggregate = {
  __typename?: 'rangers_area_text_aggregate';
  aggregate?: Maybe<Rangers_Area_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Area_Text>;
};

/** aggregate fields of "rangers.area_text" */
export type Rangers_Area_Text_Aggregate_Fields = {
  __typename?: 'rangers_area_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Area_Text_Max_Fields>;
  min?: Maybe<Rangers_Area_Text_Min_Fields>;
};


/** aggregate fields of "rangers.area_text" */
export type Rangers_Area_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Area_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.area_text". All fields are combined with a logical 'AND'. */
export type Rangers_Area_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Area_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Area_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.area_text" */
export enum Rangers_Area_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  AreaTextPkey = 'area_text_pkey'
}

/** input type for inserting data into table "rangers.area_text" */
export type Rangers_Area_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Area_Text_Max_Fields = {
  __typename?: 'rangers_area_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Area_Text_Min_Fields = {
  __typename?: 'rangers_area_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.area_text" */
export type Rangers_Area_Text_Mutation_Response = {
  __typename?: 'rangers_area_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Area_Text>;
};

/** on_conflict condition type for table "rangers.area_text" */
export type Rangers_Area_Text_On_Conflict = {
  constraint: Rangers_Area_Text_Constraint;
  update_columns?: Array<Rangers_Area_Text_Update_Column>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.area_text". */
export type Rangers_Area_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.area_text */
export type Rangers_Area_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.area_text" */
export enum Rangers_Area_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.area_text" */
export type Rangers_Area_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_area_text" */
export type Rangers_Area_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Area_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Area_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.area_text" */
export enum Rangers_Area_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Area_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Area_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Area_Text_Bool_Exp;
};

/** update columns of table "rangers.area" */
export enum Rangers_Area_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Area_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Area_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Area_Bool_Exp;
};

/** columns and relationships of "rangers.aspect" */
export type Rangers_Aspect = {
  __typename?: 'rangers_aspect';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.aspect" */
export type Rangers_Aspect_Aggregate = {
  __typename?: 'rangers_aspect_aggregate';
  aggregate?: Maybe<Rangers_Aspect_Aggregate_Fields>;
  nodes: Array<Rangers_Aspect>;
};

/** aggregate fields of "rangers.aspect" */
export type Rangers_Aspect_Aggregate_Fields = {
  __typename?: 'rangers_aspect_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Aspect_Max_Fields>;
  min?: Maybe<Rangers_Aspect_Min_Fields>;
};


/** aggregate fields of "rangers.aspect" */
export type Rangers_Aspect_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Aspect_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.aspect". All fields are combined with a logical 'AND'. */
export type Rangers_Aspect_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Aspect_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Aspect_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Aspect_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  short_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.aspect" */
export enum Rangers_Aspect_Constraint {
  /** unique or primary key constraint on columns "id" */
  AspectPkey = 'aspect_pkey'
}

/** input type for inserting data into table "rangers.aspect" */
export type Rangers_Aspect_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.aspect_localized" */
export type Rangers_Aspect_Localized = {
  __typename?: 'rangers_aspect_localized';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_short_name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.aspect_localized" */
export type Rangers_Aspect_Localized_Aggregate = {
  __typename?: 'rangers_aspect_localized_aggregate';
  aggregate?: Maybe<Rangers_Aspect_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Aspect_Localized>;
};

/** aggregate fields of "rangers.aspect_localized" */
export type Rangers_Aspect_Localized_Aggregate_Fields = {
  __typename?: 'rangers_aspect_localized_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Aspect_Localized_Max_Fields>;
  min?: Maybe<Rangers_Aspect_Localized_Min_Fields>;
};


/** aggregate fields of "rangers.aspect_localized" */
export type Rangers_Aspect_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Aspect_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.aspect_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Aspect_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Aspect_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Aspect_Localized_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_short_name?: InputMaybe<String_Comparison_Exp>;
  short_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Aspect_Localized_Max_Fields = {
  __typename?: 'rangers_aspect_localized_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_short_name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Aspect_Localized_Min_Fields = {
  __typename?: 'rangers_aspect_localized_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_short_name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.aspect_localized". */
export type Rangers_Aspect_Localized_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_short_name?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.aspect_localized" */
export enum Rangers_Aspect_Localized_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealShortName = 'real_short_name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "rangers_aspect_localized" */
export type Rangers_Aspect_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Aspect_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Aspect_Localized_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_short_name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Aspect_Max_Fields = {
  __typename?: 'rangers_aspect_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Aspect_Min_Fields = {
  __typename?: 'rangers_aspect_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.aspect" */
export type Rangers_Aspect_Mutation_Response = {
  __typename?: 'rangers_aspect_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Aspect>;
};

/** on_conflict condition type for table "rangers.aspect" */
export type Rangers_Aspect_On_Conflict = {
  constraint: Rangers_Aspect_Constraint;
  update_columns?: Array<Rangers_Aspect_Update_Column>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.aspect". */
export type Rangers_Aspect_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.aspect */
export type Rangers_Aspect_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.aspect" */
export enum Rangers_Aspect_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.aspect" */
export type Rangers_Aspect_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_aspect" */
export type Rangers_Aspect_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Aspect_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Aspect_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.aspect_text" */
export type Rangers_Aspect_Text = {
  __typename?: 'rangers_aspect_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  short_name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.aspect_text" */
export type Rangers_Aspect_Text_Aggregate = {
  __typename?: 'rangers_aspect_text_aggregate';
  aggregate?: Maybe<Rangers_Aspect_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Aspect_Text>;
};

/** aggregate fields of "rangers.aspect_text" */
export type Rangers_Aspect_Text_Aggregate_Fields = {
  __typename?: 'rangers_aspect_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Aspect_Text_Max_Fields>;
  min?: Maybe<Rangers_Aspect_Text_Min_Fields>;
};


/** aggregate fields of "rangers.aspect_text" */
export type Rangers_Aspect_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Aspect_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.aspect_text". All fields are combined with a logical 'AND'. */
export type Rangers_Aspect_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Aspect_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Aspect_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  short_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.aspect_text" */
export enum Rangers_Aspect_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  AspectTextPkey = 'aspect_text_pkey'
}

/** input type for inserting data into table "rangers.aspect_text" */
export type Rangers_Aspect_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Aspect_Text_Max_Fields = {
  __typename?: 'rangers_aspect_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Aspect_Text_Min_Fields = {
  __typename?: 'rangers_aspect_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.aspect_text" */
export type Rangers_Aspect_Text_Mutation_Response = {
  __typename?: 'rangers_aspect_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Aspect_Text>;
};

/** on_conflict condition type for table "rangers.aspect_text" */
export type Rangers_Aspect_Text_On_Conflict = {
  constraint: Rangers_Aspect_Text_Constraint;
  update_columns?: Array<Rangers_Aspect_Text_Update_Column>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.aspect_text". */
export type Rangers_Aspect_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.aspect_text */
export type Rangers_Aspect_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.aspect_text" */
export enum Rangers_Aspect_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.aspect_text" */
export type Rangers_Aspect_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_aspect_text" */
export type Rangers_Aspect_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Aspect_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Aspect_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.aspect_text" */
export enum Rangers_Aspect_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Aspect_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Aspect_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Aspect_Text_Bool_Exp;
};

/** update columns of table "rangers.aspect" */
export enum Rangers_Aspect_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Aspect_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Aspect_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Aspect_Bool_Exp;
};

/** columns and relationships of "rangers.campaign" */
export type Rangers_Campaign = {
  __typename?: 'rangers_campaign';
  /** An array relationship */
  access: Array<Rangers_User_Campaign>;
  /** An aggregate relationship */
  access_aggregate: Rangers_User_Campaign_Aggregate;
  calendar: Scalars['jsonb']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  creator: Rangers_Users;
  current_location?: Maybe<Scalars['String']['output']>;
  current_path_terrain?: Maybe<Scalars['String']['output']>;
  cycle_id: Scalars['String']['output'];
  day: Scalars['Int']['output'];
  events: Scalars['jsonb']['output'];
  extended_calendar?: Maybe<Scalars['Boolean']['output']>;
  history: Scalars['jsonb']['output'];
  id: Scalars['Int']['output'];
  /** An array relationship */
  latest_decks: Array<Rangers_Latest_Deck>;
  /** An aggregate relationship */
  latest_decks_aggregate: Rangers_Latest_Deck_Aggregate;
  missions: Scalars['jsonb']['output'];
  name: Scalars['String']['output'];
  next_campaign_id?: Maybe<Scalars['Int']['output']>;
  notes: Scalars['jsonb']['output'];
  /** An object relationship */
  previous_campaign?: Maybe<Rangers_Campaign>;
  removed: Scalars['jsonb']['output'];
  rewards: Scalars['jsonb']['output'];
  updated_at: Scalars['timestamptz']['output'];
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignAccessArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignAccess_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignCalendarArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignEventsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignHistoryArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignLatest_DecksArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignLatest_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignMissionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignNotesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignRemovedArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignRewardsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "rangers.campaign_access" */
export type Rangers_Campaign_Access = {
  __typename?: 'rangers_campaign_access';
  /** An object relationship */
  campaign: Rangers_Campaign;
  campaign_id: Scalars['Int']['output'];
  /** An object relationship */
  user: Rangers_Users;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "rangers.campaign_access" */
export type Rangers_Campaign_Access_Aggregate = {
  __typename?: 'rangers_campaign_access_aggregate';
  aggregate?: Maybe<Rangers_Campaign_Access_Aggregate_Fields>;
  nodes: Array<Rangers_Campaign_Access>;
};

/** aggregate fields of "rangers.campaign_access" */
export type Rangers_Campaign_Access_Aggregate_Fields = {
  __typename?: 'rangers_campaign_access_aggregate_fields';
  avg?: Maybe<Rangers_Campaign_Access_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Campaign_Access_Max_Fields>;
  min?: Maybe<Rangers_Campaign_Access_Min_Fields>;
  stddev?: Maybe<Rangers_Campaign_Access_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Campaign_Access_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Campaign_Access_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Campaign_Access_Sum_Fields>;
  var_pop?: Maybe<Rangers_Campaign_Access_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Campaign_Access_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Campaign_Access_Variance_Fields>;
};


/** aggregate fields of "rangers.campaign_access" */
export type Rangers_Campaign_Access_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Campaign_Access_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Campaign_Access_Avg_Fields = {
  __typename?: 'rangers_campaign_access_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.campaign_access". All fields are combined with a logical 'AND'. */
export type Rangers_Campaign_Access_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Campaign_Access_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Campaign_Access_Bool_Exp>>;
  campaign?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.campaign_access" */
export enum Rangers_Campaign_Access_Constraint {
  /** unique or primary key constraint on columns "user_id", "campaign_id" */
  CampaignAccessPkey = 'campaign_access_pkey'
}

/** input type for incrementing numeric columns in table "rangers.campaign_access" */
export type Rangers_Campaign_Access_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.campaign_access" */
export type Rangers_Campaign_Access_Insert_Input = {
  campaign?: InputMaybe<Rangers_Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Campaign_Access_Max_Fields = {
  __typename?: 'rangers_campaign_access_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Campaign_Access_Min_Fields = {
  __typename?: 'rangers_campaign_access_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.campaign_access" */
export type Rangers_Campaign_Access_Mutation_Response = {
  __typename?: 'rangers_campaign_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Campaign_Access>;
};

/** on_conflict condition type for table "rangers.campaign_access" */
export type Rangers_Campaign_Access_On_Conflict = {
  constraint: Rangers_Campaign_Access_Constraint;
  update_columns?: Array<Rangers_Campaign_Access_Update_Column>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.campaign_access". */
export type Rangers_Campaign_Access_Order_By = {
  campaign?: InputMaybe<Rangers_Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.campaign_access */
export type Rangers_Campaign_Access_Pk_Columns_Input = {
  campaign_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};

/** select columns of table "rangers.campaign_access" */
export enum Rangers_Campaign_Access_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.campaign_access" */
export type Rangers_Campaign_Access_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Campaign_Access_Stddev_Fields = {
  __typename?: 'rangers_campaign_access_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Campaign_Access_Stddev_Pop_Fields = {
  __typename?: 'rangers_campaign_access_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Campaign_Access_Stddev_Samp_Fields = {
  __typename?: 'rangers_campaign_access_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_campaign_access" */
export type Rangers_Campaign_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Campaign_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Campaign_Access_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Campaign_Access_Sum_Fields = {
  __typename?: 'rangers_campaign_access_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.campaign_access" */
export enum Rangers_Campaign_Access_Update_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_Campaign_Access_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Campaign_Access_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Campaign_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Campaign_Access_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Campaign_Access_Var_Pop_Fields = {
  __typename?: 'rangers_campaign_access_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Campaign_Access_Var_Samp_Fields = {
  __typename?: 'rangers_campaign_access_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Campaign_Access_Variance_Fields = {
  __typename?: 'rangers_campaign_access_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregated selection of "rangers.campaign" */
export type Rangers_Campaign_Aggregate = {
  __typename?: 'rangers_campaign_aggregate';
  aggregate?: Maybe<Rangers_Campaign_Aggregate_Fields>;
  nodes: Array<Rangers_Campaign>;
};

/** aggregate fields of "rangers.campaign" */
export type Rangers_Campaign_Aggregate_Fields = {
  __typename?: 'rangers_campaign_aggregate_fields';
  avg?: Maybe<Rangers_Campaign_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Campaign_Max_Fields>;
  min?: Maybe<Rangers_Campaign_Min_Fields>;
  stddev?: Maybe<Rangers_Campaign_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Campaign_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Campaign_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Campaign_Sum_Fields>;
  var_pop?: Maybe<Rangers_Campaign_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Campaign_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Campaign_Variance_Fields>;
};


/** aggregate fields of "rangers.campaign" */
export type Rangers_Campaign_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Campaign_Append_Input = {
  calendar?: InputMaybe<Scalars['jsonb']['input']>;
  events?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  missions?: InputMaybe<Scalars['jsonb']['input']>;
  notes?: InputMaybe<Scalars['jsonb']['input']>;
  removed?: InputMaybe<Scalars['jsonb']['input']>;
  rewards?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Campaign_Avg_Fields = {
  __typename?: 'rangers_campaign_avg_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.campaign". All fields are combined with a logical 'AND'. */
export type Rangers_Campaign_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Campaign_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Campaign_Bool_Exp>>;
  access?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
  access_aggregate?: InputMaybe<Rangers_User_Campaign_Aggregate_Bool_Exp>;
  calendar?: InputMaybe<Jsonb_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  creator?: InputMaybe<Rangers_Users_Bool_Exp>;
  current_location?: InputMaybe<String_Comparison_Exp>;
  current_path_terrain?: InputMaybe<String_Comparison_Exp>;
  cycle_id?: InputMaybe<String_Comparison_Exp>;
  day?: InputMaybe<Int_Comparison_Exp>;
  events?: InputMaybe<Jsonb_Comparison_Exp>;
  extended_calendar?: InputMaybe<Boolean_Comparison_Exp>;
  history?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  latest_decks?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
  latest_decks_aggregate?: InputMaybe<Rangers_Latest_Deck_Aggregate_Bool_Exp>;
  missions?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  next_campaign_id?: InputMaybe<Int_Comparison_Exp>;
  notes?: InputMaybe<Jsonb_Comparison_Exp>;
  previous_campaign?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  removed?: InputMaybe<Jsonb_Comparison_Exp>;
  rewards?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.campaign" */
export enum Rangers_Campaign_Constraint {
  /** unique or primary key constraint on columns "id" */
  CampaignPkey = 'campaign_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Rangers_Campaign_Delete_At_Path_Input = {
  calendar?: InputMaybe<Array<Scalars['String']['input']>>;
  events?: InputMaybe<Array<Scalars['String']['input']>>;
  history?: InputMaybe<Array<Scalars['String']['input']>>;
  missions?: InputMaybe<Array<Scalars['String']['input']>>;
  notes?: InputMaybe<Array<Scalars['String']['input']>>;
  removed?: InputMaybe<Array<Scalars['String']['input']>>;
  rewards?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Rangers_Campaign_Delete_Elem_Input = {
  calendar?: InputMaybe<Scalars['Int']['input']>;
  events?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<Scalars['Int']['input']>;
  missions?: InputMaybe<Scalars['Int']['input']>;
  notes?: InputMaybe<Scalars['Int']['input']>;
  removed?: InputMaybe<Scalars['Int']['input']>;
  rewards?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Rangers_Campaign_Delete_Key_Input = {
  calendar?: InputMaybe<Scalars['String']['input']>;
  events?: InputMaybe<Scalars['String']['input']>;
  history?: InputMaybe<Scalars['String']['input']>;
  missions?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  removed?: InputMaybe<Scalars['String']['input']>;
  rewards?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "rangers.campaign" */
export type Rangers_Campaign_Inc_Input = {
  day?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  next_campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.campaign" */
export type Rangers_Campaign_Insert_Input = {
  access?: InputMaybe<Rangers_User_Campaign_Arr_Rel_Insert_Input>;
  calendar?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  creator?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  current_location?: InputMaybe<Scalars['String']['input']>;
  current_path_terrain?: InputMaybe<Scalars['String']['input']>;
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  events?: InputMaybe<Scalars['jsonb']['input']>;
  extended_calendar?: InputMaybe<Scalars['Boolean']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  latest_decks?: InputMaybe<Rangers_Latest_Deck_Arr_Rel_Insert_Input>;
  missions?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  notes?: InputMaybe<Scalars['jsonb']['input']>;
  previous_campaign?: InputMaybe<Rangers_Campaign_Obj_Rel_Insert_Input>;
  removed?: InputMaybe<Scalars['jsonb']['input']>;
  rewards?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Campaign_Max_Fields = {
  __typename?: 'rangers_campaign_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  current_location?: Maybe<Scalars['String']['output']>;
  current_path_terrain?: Maybe<Scalars['String']['output']>;
  cycle_id?: Maybe<Scalars['String']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_campaign_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Campaign_Min_Fields = {
  __typename?: 'rangers_campaign_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  current_location?: Maybe<Scalars['String']['output']>;
  current_path_terrain?: Maybe<Scalars['String']['output']>;
  cycle_id?: Maybe<Scalars['String']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_campaign_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.campaign" */
export type Rangers_Campaign_Mutation_Response = {
  __typename?: 'rangers_campaign_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Campaign>;
};

/** input type for inserting object relation for remote table "rangers.campaign" */
export type Rangers_Campaign_Obj_Rel_Insert_Input = {
  data: Rangers_Campaign_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Campaign_On_Conflict>;
};

/** on_conflict condition type for table "rangers.campaign" */
export type Rangers_Campaign_On_Conflict = {
  constraint: Rangers_Campaign_Constraint;
  update_columns?: Array<Rangers_Campaign_Update_Column>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.campaign". */
export type Rangers_Campaign_Order_By = {
  access_aggregate?: InputMaybe<Rangers_User_Campaign_Aggregate_Order_By>;
  calendar?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  creator?: InputMaybe<Rangers_Users_Order_By>;
  current_location?: InputMaybe<Order_By>;
  current_path_terrain?: InputMaybe<Order_By>;
  cycle_id?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  events?: InputMaybe<Order_By>;
  extended_calendar?: InputMaybe<Order_By>;
  history?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latest_decks_aggregate?: InputMaybe<Rangers_Latest_Deck_Aggregate_Order_By>;
  missions?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  next_campaign_id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  previous_campaign?: InputMaybe<Rangers_Campaign_Order_By>;
  removed?: InputMaybe<Order_By>;
  rewards?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.campaign */
export type Rangers_Campaign_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Campaign_Prepend_Input = {
  calendar?: InputMaybe<Scalars['jsonb']['input']>;
  events?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  missions?: InputMaybe<Scalars['jsonb']['input']>;
  notes?: InputMaybe<Scalars['jsonb']['input']>;
  removed?: InputMaybe<Scalars['jsonb']['input']>;
  rewards?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "rangers.campaign" */
export enum Rangers_Campaign_Select_Column {
  /** column name */
  Calendar = 'calendar',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentLocation = 'current_location',
  /** column name */
  CurrentPathTerrain = 'current_path_terrain',
  /** column name */
  CycleId = 'cycle_id',
  /** column name */
  Day = 'day',
  /** column name */
  Events = 'events',
  /** column name */
  ExtendedCalendar = 'extended_calendar',
  /** column name */
  History = 'history',
  /** column name */
  Id = 'id',
  /** column name */
  Missions = 'missions',
  /** column name */
  Name = 'name',
  /** column name */
  NextCampaignId = 'next_campaign_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  Removed = 'removed',
  /** column name */
  Rewards = 'rewards',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.campaign" */
export type Rangers_Campaign_Set_Input = {
  calendar?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  current_location?: InputMaybe<Scalars['String']['input']>;
  current_path_terrain?: InputMaybe<Scalars['String']['input']>;
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  events?: InputMaybe<Scalars['jsonb']['input']>;
  extended_calendar?: InputMaybe<Scalars['Boolean']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  missions?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  notes?: InputMaybe<Scalars['jsonb']['input']>;
  removed?: InputMaybe<Scalars['jsonb']['input']>;
  rewards?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Campaign_Stddev_Fields = {
  __typename?: 'rangers_campaign_stddev_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Campaign_Stddev_Pop_Fields = {
  __typename?: 'rangers_campaign_stddev_pop_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Campaign_Stddev_Samp_Fields = {
  __typename?: 'rangers_campaign_stddev_samp_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_campaign" */
export type Rangers_Campaign_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Campaign_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Campaign_Stream_Cursor_Value_Input = {
  calendar?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  current_location?: InputMaybe<Scalars['String']['input']>;
  current_path_terrain?: InputMaybe<Scalars['String']['input']>;
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  events?: InputMaybe<Scalars['jsonb']['input']>;
  extended_calendar?: InputMaybe<Scalars['Boolean']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  missions?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  notes?: InputMaybe<Scalars['jsonb']['input']>;
  removed?: InputMaybe<Scalars['jsonb']['input']>;
  rewards?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Campaign_Sum_Fields = {
  __typename?: 'rangers_campaign_sum_fields';
  day?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  next_campaign_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.campaign" */
export enum Rangers_Campaign_Update_Column {
  /** column name */
  Calendar = 'calendar',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentLocation = 'current_location',
  /** column name */
  CurrentPathTerrain = 'current_path_terrain',
  /** column name */
  CycleId = 'cycle_id',
  /** column name */
  Day = 'day',
  /** column name */
  Events = 'events',
  /** column name */
  ExtendedCalendar = 'extended_calendar',
  /** column name */
  History = 'history',
  /** column name */
  Id = 'id',
  /** column name */
  Missions = 'missions',
  /** column name */
  Name = 'name',
  /** column name */
  NextCampaignId = 'next_campaign_id',
  /** column name */
  Notes = 'notes',
  /** column name */
  Removed = 'removed',
  /** column name */
  Rewards = 'rewards',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_Campaign_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Rangers_Campaign_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Rangers_Campaign_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Rangers_Campaign_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Rangers_Campaign_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Campaign_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Rangers_Campaign_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Campaign_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Campaign_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Campaign_Var_Pop_Fields = {
  __typename?: 'rangers_campaign_var_pop_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Campaign_Var_Samp_Fields = {
  __typename?: 'rangers_campaign_var_samp_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Campaign_Variance_Fields = {
  __typename?: 'rangers_campaign_variance_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.card" */
export type Rangers_Card = {
  __typename?: 'rangers_card';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  crest_challenge?: Maybe<Scalars['String']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id: Scalars['String']['output'];
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  locations?: Maybe<Scalars['jsonb']['output']>;
  mountain_challenge?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  progress_fixed?: Maybe<Scalars['Boolean']['output']>;
  quantity: Scalars['Int']['output'];
  set_id: Scalars['String']['output'];
  set_position: Scalars['Int']['output'];
  spoiler?: Maybe<Scalars['Boolean']['output']>;
  subset_id?: Maybe<Scalars['String']['output']>;
  subset_position?: Maybe<Scalars['Int']['output']>;
  sun_challenge?: Maybe<Scalars['String']['output']>;
  taboo_id?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  translations: Array<Rangers_Card_Text>;
  /** An aggregate relationship */
  translations_aggregate: Rangers_Card_Text_Aggregate;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.card" */
export type Rangers_CardLocationsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.card" */
export type Rangers_CardTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


/** columns and relationships of "rangers.card" */
export type Rangers_CardTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};

/** aggregated selection of "rangers.card" */
export type Rangers_Card_Aggregate = {
  __typename?: 'rangers_card_aggregate';
  aggregate?: Maybe<Rangers_Card_Aggregate_Fields>;
  nodes: Array<Rangers_Card>;
};

/** aggregate fields of "rangers.card" */
export type Rangers_Card_Aggregate_Fields = {
  __typename?: 'rangers_card_aggregate_fields';
  avg?: Maybe<Rangers_Card_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Card_Max_Fields>;
  min?: Maybe<Rangers_Card_Min_Fields>;
  stddev?: Maybe<Rangers_Card_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Card_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Card_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Card_Sum_Fields>;
  var_pop?: Maybe<Rangers_Card_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Card_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Card_Variance_Fields>;
};


/** aggregate fields of "rangers.card" */
export type Rangers_Card_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Card_Append_Input = {
  locations?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Card_Avg_Fields = {
  __typename?: 'rangers_card_avg_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.card". All fields are combined with a logical 'AND'. */
export type Rangers_Card_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Card_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Card_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Card_Bool_Exp>>;
  approach_conflict?: InputMaybe<Int_Comparison_Exp>;
  approach_connection?: InputMaybe<Int_Comparison_Exp>;
  approach_exploration?: InputMaybe<Int_Comparison_Exp>;
  approach_reason?: InputMaybe<Int_Comparison_Exp>;
  area_id?: InputMaybe<String_Comparison_Exp>;
  aspect_id?: InputMaybe<String_Comparison_Exp>;
  back_card_id?: InputMaybe<String_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  crest_challenge?: InputMaybe<String_Comparison_Exp>;
  deck_limit?: InputMaybe<Int_Comparison_Exp>;
  equip?: InputMaybe<Int_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  guide_entry?: InputMaybe<String_Comparison_Exp>;
  harm?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  level?: InputMaybe<Int_Comparison_Exp>;
  locations?: InputMaybe<Jsonb_Comparison_Exp>;
  mountain_challenge?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  objective?: InputMaybe<String_Comparison_Exp>;
  pack_id?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  presence?: InputMaybe<Int_Comparison_Exp>;
  progress?: InputMaybe<Int_Comparison_Exp>;
  progress_fixed?: InputMaybe<Boolean_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  set_id?: InputMaybe<String_Comparison_Exp>;
  set_position?: InputMaybe<Int_Comparison_Exp>;
  spoiler?: InputMaybe<Boolean_Comparison_Exp>;
  subset_id?: InputMaybe<String_Comparison_Exp>;
  subset_position?: InputMaybe<Int_Comparison_Exp>;
  sun_challenge?: InputMaybe<String_Comparison_Exp>;
  taboo_id?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  token_count?: InputMaybe<Int_Comparison_Exp>;
  token_id?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Rangers_Card_Text_Aggregate_Bool_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.card" */
export enum Rangers_Card_Constraint {
  /** unique or primary key constraint on columns "id" */
  CardPkey = 'card_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Rangers_Card_Delete_At_Path_Input = {
  locations?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Rangers_Card_Delete_Elem_Input = {
  locations?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Rangers_Card_Delete_Key_Input = {
  locations?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "rangers.card" */
export type Rangers_Card_Inc_Input = {
  approach_conflict?: InputMaybe<Scalars['Int']['input']>;
  approach_connection?: InputMaybe<Scalars['Int']['input']>;
  approach_exploration?: InputMaybe<Scalars['Int']['input']>;
  approach_reason?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  equip?: InputMaybe<Scalars['Int']['input']>;
  harm?: InputMaybe<Scalars['Int']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  presence?: InputMaybe<Scalars['Int']['input']>;
  progress?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  set_position?: InputMaybe<Scalars['Int']['input']>;
  subset_position?: InputMaybe<Scalars['Int']['input']>;
  token_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.card" */
export type Rangers_Card_Insert_Input = {
  approach_conflict?: InputMaybe<Scalars['Int']['input']>;
  approach_connection?: InputMaybe<Scalars['Int']['input']>;
  approach_exploration?: InputMaybe<Scalars['Int']['input']>;
  approach_reason?: InputMaybe<Scalars['Int']['input']>;
  area_id?: InputMaybe<Scalars['String']['input']>;
  aspect_id?: InputMaybe<Scalars['String']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  crest_challenge?: InputMaybe<Scalars['String']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  equip?: InputMaybe<Scalars['Int']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  guide_entry?: InputMaybe<Scalars['String']['input']>;
  harm?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  locations?: InputMaybe<Scalars['jsonb']['input']>;
  mountain_challenge?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  presence?: InputMaybe<Scalars['Int']['input']>;
  progress?: InputMaybe<Scalars['Int']['input']>;
  progress_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  set_position?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  subset_id?: InputMaybe<Scalars['String']['input']>;
  subset_position?: InputMaybe<Scalars['Int']['input']>;
  sun_challenge?: InputMaybe<Scalars['String']['input']>;
  taboo_id?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  token_count?: InputMaybe<Scalars['Int']['input']>;
  token_id?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Rangers_Card_Text_Arr_Rel_Insert_Input>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.card_localized" */
export type Rangers_Card_Localized = {
  __typename?: 'rangers_card_localized';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  area_name?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  aspect_name?: Maybe<Scalars['String']['output']>;
  aspect_short_name?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  crest_challenge?: Maybe<Scalars['String']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  locations?: Maybe<Scalars['jsonb']['output']>;
  mountain_challenge?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  pack_short_name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  progress_fixed?: Maybe<Scalars['Boolean']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_crest_challenge?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_mountain_challenge?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_objective?: Maybe<Scalars['String']['output']>;
  real_sun_challenge?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_name?: Maybe<Scalars['String']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  set_type_id?: Maybe<Scalars['String']['output']>;
  set_type_name?: Maybe<Scalars['String']['output']>;
  spoiler?: Maybe<Scalars['Boolean']['output']>;
  subset_id?: Maybe<Scalars['String']['output']>;
  subset_name?: Maybe<Scalars['String']['output']>;
  subset_pack_id?: Maybe<Scalars['String']['output']>;
  subset_pack_name?: Maybe<Scalars['String']['output']>;
  subset_position?: Maybe<Scalars['Int']['output']>;
  subset_set_id?: Maybe<Scalars['String']['output']>;
  subset_set_name?: Maybe<Scalars['String']['output']>;
  subset_size?: Maybe<Scalars['Int']['output']>;
  sun_challenge?: Maybe<Scalars['String']['output']>;
  taboo_date?: Maybe<Scalars['timestamptz']['output']>;
  taboo_id?: Maybe<Scalars['String']['output']>;
  taboo_is_current?: Maybe<Scalars['Boolean']['output']>;
  taboo_name?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  token_name?: Maybe<Scalars['String']['output']>;
  token_plurals?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.card_localized" */
export type Rangers_Card_LocalizedLocationsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "rangers.card_localized" */
export type Rangers_Card_Localized_Aggregate = {
  __typename?: 'rangers_card_localized_aggregate';
  aggregate?: Maybe<Rangers_Card_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Card_Localized>;
};

/** aggregate fields of "rangers.card_localized" */
export type Rangers_Card_Localized_Aggregate_Fields = {
  __typename?: 'rangers_card_localized_aggregate_fields';
  avg?: Maybe<Rangers_Card_Localized_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Card_Localized_Max_Fields>;
  min?: Maybe<Rangers_Card_Localized_Min_Fields>;
  stddev?: Maybe<Rangers_Card_Localized_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Card_Localized_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Card_Localized_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Card_Localized_Sum_Fields>;
  var_pop?: Maybe<Rangers_Card_Localized_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Card_Localized_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Card_Localized_Variance_Fields>;
};


/** aggregate fields of "rangers.card_localized" */
export type Rangers_Card_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Card_Localized_Avg_Fields = {
  __typename?: 'rangers_card_localized_avg_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  subset_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.card_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Card_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Card_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Card_Localized_Bool_Exp>>;
  approach_conflict?: InputMaybe<Int_Comparison_Exp>;
  approach_connection?: InputMaybe<Int_Comparison_Exp>;
  approach_exploration?: InputMaybe<Int_Comparison_Exp>;
  approach_reason?: InputMaybe<Int_Comparison_Exp>;
  area_id?: InputMaybe<String_Comparison_Exp>;
  area_name?: InputMaybe<String_Comparison_Exp>;
  aspect_id?: InputMaybe<String_Comparison_Exp>;
  aspect_name?: InputMaybe<String_Comparison_Exp>;
  aspect_short_name?: InputMaybe<String_Comparison_Exp>;
  back_card_id?: InputMaybe<String_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  crest_challenge?: InputMaybe<String_Comparison_Exp>;
  deck_limit?: InputMaybe<Int_Comparison_Exp>;
  equip?: InputMaybe<Int_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  guide_entry?: InputMaybe<String_Comparison_Exp>;
  harm?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  level?: InputMaybe<Int_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  locations?: InputMaybe<Jsonb_Comparison_Exp>;
  mountain_challenge?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  objective?: InputMaybe<String_Comparison_Exp>;
  pack_id?: InputMaybe<String_Comparison_Exp>;
  pack_name?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  pack_short_name?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  presence?: InputMaybe<Int_Comparison_Exp>;
  progress?: InputMaybe<Int_Comparison_Exp>;
  progress_fixed?: InputMaybe<Boolean_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  real_crest_challenge?: InputMaybe<String_Comparison_Exp>;
  real_flavor?: InputMaybe<String_Comparison_Exp>;
  real_imagesrc?: InputMaybe<String_Comparison_Exp>;
  real_mountain_challenge?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_objective?: InputMaybe<String_Comparison_Exp>;
  real_sun_challenge?: InputMaybe<String_Comparison_Exp>;
  real_text?: InputMaybe<String_Comparison_Exp>;
  real_traits?: InputMaybe<String_Comparison_Exp>;
  set_id?: InputMaybe<String_Comparison_Exp>;
  set_name?: InputMaybe<String_Comparison_Exp>;
  set_position?: InputMaybe<Int_Comparison_Exp>;
  set_size?: InputMaybe<Int_Comparison_Exp>;
  set_type_id?: InputMaybe<String_Comparison_Exp>;
  set_type_name?: InputMaybe<String_Comparison_Exp>;
  spoiler?: InputMaybe<Boolean_Comparison_Exp>;
  subset_id?: InputMaybe<String_Comparison_Exp>;
  subset_name?: InputMaybe<String_Comparison_Exp>;
  subset_pack_id?: InputMaybe<String_Comparison_Exp>;
  subset_pack_name?: InputMaybe<String_Comparison_Exp>;
  subset_position?: InputMaybe<Int_Comparison_Exp>;
  subset_set_id?: InputMaybe<String_Comparison_Exp>;
  subset_set_name?: InputMaybe<String_Comparison_Exp>;
  subset_size?: InputMaybe<Int_Comparison_Exp>;
  sun_challenge?: InputMaybe<String_Comparison_Exp>;
  taboo_date?: InputMaybe<Timestamptz_Comparison_Exp>;
  taboo_id?: InputMaybe<String_Comparison_Exp>;
  taboo_is_current?: InputMaybe<Boolean_Comparison_Exp>;
  taboo_name?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  token_count?: InputMaybe<Int_Comparison_Exp>;
  token_id?: InputMaybe<String_Comparison_Exp>;
  token_name?: InputMaybe<String_Comparison_Exp>;
  token_plurals?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  type_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Card_Localized_Max_Fields = {
  __typename?: 'rangers_card_localized_max_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  area_name?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  aspect_name?: Maybe<Scalars['String']['output']>;
  aspect_short_name?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  crest_challenge?: Maybe<Scalars['String']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  mountain_challenge?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  pack_short_name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_crest_challenge?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_mountain_challenge?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_objective?: Maybe<Scalars['String']['output']>;
  real_sun_challenge?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_name?: Maybe<Scalars['String']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  set_type_id?: Maybe<Scalars['String']['output']>;
  set_type_name?: Maybe<Scalars['String']['output']>;
  subset_id?: Maybe<Scalars['String']['output']>;
  subset_name?: Maybe<Scalars['String']['output']>;
  subset_pack_id?: Maybe<Scalars['String']['output']>;
  subset_pack_name?: Maybe<Scalars['String']['output']>;
  subset_position?: Maybe<Scalars['Int']['output']>;
  subset_set_id?: Maybe<Scalars['String']['output']>;
  subset_set_name?: Maybe<Scalars['String']['output']>;
  subset_size?: Maybe<Scalars['Int']['output']>;
  sun_challenge?: Maybe<Scalars['String']['output']>;
  taboo_date?: Maybe<Scalars['timestamptz']['output']>;
  taboo_id?: Maybe<Scalars['String']['output']>;
  taboo_name?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  token_name?: Maybe<Scalars['String']['output']>;
  token_plurals?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Card_Localized_Min_Fields = {
  __typename?: 'rangers_card_localized_min_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  area_name?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  aspect_name?: Maybe<Scalars['String']['output']>;
  aspect_short_name?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  crest_challenge?: Maybe<Scalars['String']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  mountain_challenge?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  pack_short_name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_crest_challenge?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_mountain_challenge?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_objective?: Maybe<Scalars['String']['output']>;
  real_sun_challenge?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_name?: Maybe<Scalars['String']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  set_type_id?: Maybe<Scalars['String']['output']>;
  set_type_name?: Maybe<Scalars['String']['output']>;
  subset_id?: Maybe<Scalars['String']['output']>;
  subset_name?: Maybe<Scalars['String']['output']>;
  subset_pack_id?: Maybe<Scalars['String']['output']>;
  subset_pack_name?: Maybe<Scalars['String']['output']>;
  subset_position?: Maybe<Scalars['Int']['output']>;
  subset_set_id?: Maybe<Scalars['String']['output']>;
  subset_set_name?: Maybe<Scalars['String']['output']>;
  subset_size?: Maybe<Scalars['Int']['output']>;
  sun_challenge?: Maybe<Scalars['String']['output']>;
  taboo_date?: Maybe<Scalars['timestamptz']['output']>;
  taboo_id?: Maybe<Scalars['String']['output']>;
  taboo_name?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  token_name?: Maybe<Scalars['String']['output']>;
  token_plurals?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.card_localized". */
export type Rangers_Card_Localized_Order_By = {
  approach_conflict?: InputMaybe<Order_By>;
  approach_connection?: InputMaybe<Order_By>;
  approach_exploration?: InputMaybe<Order_By>;
  approach_reason?: InputMaybe<Order_By>;
  area_id?: InputMaybe<Order_By>;
  area_name?: InputMaybe<Order_By>;
  aspect_id?: InputMaybe<Order_By>;
  aspect_name?: InputMaybe<Order_By>;
  aspect_short_name?: InputMaybe<Order_By>;
  back_card_id?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  crest_challenge?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  equip?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  guide_entry?: InputMaybe<Order_By>;
  harm?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  locations?: InputMaybe<Order_By>;
  mountain_challenge?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  objective?: InputMaybe<Order_By>;
  pack_id?: InputMaybe<Order_By>;
  pack_name?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  pack_short_name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  presence?: InputMaybe<Order_By>;
  progress?: InputMaybe<Order_By>;
  progress_fixed?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_crest_challenge?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_imagesrc?: InputMaybe<Order_By>;
  real_mountain_challenge?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_objective?: InputMaybe<Order_By>;
  real_sun_challenge?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  set_id?: InputMaybe<Order_By>;
  set_name?: InputMaybe<Order_By>;
  set_position?: InputMaybe<Order_By>;
  set_size?: InputMaybe<Order_By>;
  set_type_id?: InputMaybe<Order_By>;
  set_type_name?: InputMaybe<Order_By>;
  spoiler?: InputMaybe<Order_By>;
  subset_id?: InputMaybe<Order_By>;
  subset_name?: InputMaybe<Order_By>;
  subset_pack_id?: InputMaybe<Order_By>;
  subset_pack_name?: InputMaybe<Order_By>;
  subset_position?: InputMaybe<Order_By>;
  subset_set_id?: InputMaybe<Order_By>;
  subset_set_name?: InputMaybe<Order_By>;
  subset_size?: InputMaybe<Order_By>;
  sun_challenge?: InputMaybe<Order_By>;
  taboo_date?: InputMaybe<Order_By>;
  taboo_id?: InputMaybe<Order_By>;
  taboo_is_current?: InputMaybe<Order_By>;
  taboo_name?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  token_count?: InputMaybe<Order_By>;
  token_id?: InputMaybe<Order_By>;
  token_name?: InputMaybe<Order_By>;
  token_plurals?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  type_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.card_localized" */
export enum Rangers_Card_Localized_Select_Column {
  /** column name */
  ApproachConflict = 'approach_conflict',
  /** column name */
  ApproachConnection = 'approach_connection',
  /** column name */
  ApproachExploration = 'approach_exploration',
  /** column name */
  ApproachReason = 'approach_reason',
  /** column name */
  AreaId = 'area_id',
  /** column name */
  AreaName = 'area_name',
  /** column name */
  AspectId = 'aspect_id',
  /** column name */
  AspectName = 'aspect_name',
  /** column name */
  AspectShortName = 'aspect_short_name',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  CrestChallenge = 'crest_challenge',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  Equip = 'equip',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  GuideEntry = 'guide_entry',
  /** column name */
  Harm = 'harm',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Level = 'level',
  /** column name */
  Locale = 'locale',
  /** column name */
  Locations = 'locations',
  /** column name */
  MountainChallenge = 'mountain_challenge',
  /** column name */
  Name = 'name',
  /** column name */
  Objective = 'objective',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  PackName = 'pack_name',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  PackShortName = 'pack_short_name',
  /** column name */
  Position = 'position',
  /** column name */
  Presence = 'presence',
  /** column name */
  Progress = 'progress',
  /** column name */
  ProgressFixed = 'progress_fixed',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealCrestChallenge = 'real_crest_challenge',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealImagesrc = 'real_imagesrc',
  /** column name */
  RealMountainChallenge = 'real_mountain_challenge',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealObjective = 'real_objective',
  /** column name */
  RealSunChallenge = 'real_sun_challenge',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  SetId = 'set_id',
  /** column name */
  SetName = 'set_name',
  /** column name */
  SetPosition = 'set_position',
  /** column name */
  SetSize = 'set_size',
  /** column name */
  SetTypeId = 'set_type_id',
  /** column name */
  SetTypeName = 'set_type_name',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  SubsetId = 'subset_id',
  /** column name */
  SubsetName = 'subset_name',
  /** column name */
  SubsetPackId = 'subset_pack_id',
  /** column name */
  SubsetPackName = 'subset_pack_name',
  /** column name */
  SubsetPosition = 'subset_position',
  /** column name */
  SubsetSetId = 'subset_set_id',
  /** column name */
  SubsetSetName = 'subset_set_name',
  /** column name */
  SubsetSize = 'subset_size',
  /** column name */
  SunChallenge = 'sun_challenge',
  /** column name */
  TabooDate = 'taboo_date',
  /** column name */
  TabooId = 'taboo_id',
  /** column name */
  TabooIsCurrent = 'taboo_is_current',
  /** column name */
  TabooName = 'taboo_name',
  /** column name */
  Text = 'text',
  /** column name */
  TokenCount = 'token_count',
  /** column name */
  TokenId = 'token_id',
  /** column name */
  TokenName = 'token_name',
  /** column name */
  TokenPlurals = 'token_plurals',
  /** column name */
  Traits = 'traits',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  TypeName = 'type_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Rangers_Card_Localized_Stddev_Fields = {
  __typename?: 'rangers_card_localized_stddev_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  subset_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Card_Localized_Stddev_Pop_Fields = {
  __typename?: 'rangers_card_localized_stddev_pop_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  subset_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Card_Localized_Stddev_Samp_Fields = {
  __typename?: 'rangers_card_localized_stddev_samp_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  subset_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_card_localized" */
export type Rangers_Card_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Card_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Card_Localized_Stream_Cursor_Value_Input = {
  approach_conflict?: InputMaybe<Scalars['Int']['input']>;
  approach_connection?: InputMaybe<Scalars['Int']['input']>;
  approach_exploration?: InputMaybe<Scalars['Int']['input']>;
  approach_reason?: InputMaybe<Scalars['Int']['input']>;
  area_id?: InputMaybe<Scalars['String']['input']>;
  area_name?: InputMaybe<Scalars['String']['input']>;
  aspect_id?: InputMaybe<Scalars['String']['input']>;
  aspect_name?: InputMaybe<Scalars['String']['input']>;
  aspect_short_name?: InputMaybe<Scalars['String']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  crest_challenge?: InputMaybe<Scalars['String']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  equip?: InputMaybe<Scalars['Int']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  guide_entry?: InputMaybe<Scalars['String']['input']>;
  harm?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  locations?: InputMaybe<Scalars['jsonb']['input']>;
  mountain_challenge?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  pack_name?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  pack_short_name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  presence?: InputMaybe<Scalars['Int']['input']>;
  progress?: InputMaybe<Scalars['Int']['input']>;
  progress_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_crest_challenge?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_imagesrc?: InputMaybe<Scalars['String']['input']>;
  real_mountain_challenge?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_objective?: InputMaybe<Scalars['String']['input']>;
  real_sun_challenge?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  set_name?: InputMaybe<Scalars['String']['input']>;
  set_position?: InputMaybe<Scalars['Int']['input']>;
  set_size?: InputMaybe<Scalars['Int']['input']>;
  set_type_id?: InputMaybe<Scalars['String']['input']>;
  set_type_name?: InputMaybe<Scalars['String']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  subset_id?: InputMaybe<Scalars['String']['input']>;
  subset_name?: InputMaybe<Scalars['String']['input']>;
  subset_pack_id?: InputMaybe<Scalars['String']['input']>;
  subset_pack_name?: InputMaybe<Scalars['String']['input']>;
  subset_position?: InputMaybe<Scalars['Int']['input']>;
  subset_set_id?: InputMaybe<Scalars['String']['input']>;
  subset_set_name?: InputMaybe<Scalars['String']['input']>;
  subset_size?: InputMaybe<Scalars['Int']['input']>;
  sun_challenge?: InputMaybe<Scalars['String']['input']>;
  taboo_date?: InputMaybe<Scalars['timestamptz']['input']>;
  taboo_id?: InputMaybe<Scalars['String']['input']>;
  taboo_is_current?: InputMaybe<Scalars['Boolean']['input']>;
  taboo_name?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  token_count?: InputMaybe<Scalars['Int']['input']>;
  token_id?: InputMaybe<Scalars['String']['input']>;
  token_name?: InputMaybe<Scalars['String']['input']>;
  token_plurals?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  type_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Card_Localized_Sum_Fields = {
  __typename?: 'rangers_card_localized_sum_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  subset_position?: Maybe<Scalars['Int']['output']>;
  subset_size?: Maybe<Scalars['Int']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
};

/** aggregate var_pop on columns */
export type Rangers_Card_Localized_Var_Pop_Fields = {
  __typename?: 'rangers_card_localized_var_pop_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  subset_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Card_Localized_Var_Samp_Fields = {
  __typename?: 'rangers_card_localized_var_samp_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  subset_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Card_Localized_Variance_Fields = {
  __typename?: 'rangers_card_localized_variance_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  subset_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type Rangers_Card_Max_Fields = {
  __typename?: 'rangers_card_max_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  crest_challenge?: Maybe<Scalars['String']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  mountain_challenge?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  subset_id?: Maybe<Scalars['String']['output']>;
  subset_position?: Maybe<Scalars['Int']['output']>;
  sun_challenge?: Maybe<Scalars['String']['output']>;
  taboo_id?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Card_Min_Fields = {
  __typename?: 'rangers_card_min_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  crest_challenge?: Maybe<Scalars['String']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  mountain_challenge?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  subset_id?: Maybe<Scalars['String']['output']>;
  subset_position?: Maybe<Scalars['Int']['output']>;
  sun_challenge?: Maybe<Scalars['String']['output']>;
  taboo_id?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.card" */
export type Rangers_Card_Mutation_Response = {
  __typename?: 'rangers_card_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Card>;
};

/** on_conflict condition type for table "rangers.card" */
export type Rangers_Card_On_Conflict = {
  constraint: Rangers_Card_Constraint;
  update_columns?: Array<Rangers_Card_Update_Column>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.card". */
export type Rangers_Card_Order_By = {
  approach_conflict?: InputMaybe<Order_By>;
  approach_connection?: InputMaybe<Order_By>;
  approach_exploration?: InputMaybe<Order_By>;
  approach_reason?: InputMaybe<Order_By>;
  area_id?: InputMaybe<Order_By>;
  aspect_id?: InputMaybe<Order_By>;
  back_card_id?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  crest_challenge?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  equip?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  guide_entry?: InputMaybe<Order_By>;
  harm?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  locations?: InputMaybe<Order_By>;
  mountain_challenge?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  objective?: InputMaybe<Order_By>;
  pack_id?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  presence?: InputMaybe<Order_By>;
  progress?: InputMaybe<Order_By>;
  progress_fixed?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  set_id?: InputMaybe<Order_By>;
  set_position?: InputMaybe<Order_By>;
  spoiler?: InputMaybe<Order_By>;
  subset_id?: InputMaybe<Order_By>;
  subset_position?: InputMaybe<Order_By>;
  sun_challenge?: InputMaybe<Order_By>;
  taboo_id?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  token_count?: InputMaybe<Order_By>;
  token_id?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Rangers_Card_Text_Aggregate_Order_By>;
  type_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.card */
export type Rangers_Card_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Card_Prepend_Input = {
  locations?: InputMaybe<Scalars['jsonb']['input']>;
};

export type Rangers_Card_Search_Args = {
  _limit?: InputMaybe<Scalars['Int']['input']>;
  _offset?: InputMaybe<Scalars['Int']['input']>;
  aspect_in?: InputMaybe<Scalars['_text']['input']>;
  level_eq?: InputMaybe<Scalars['Int']['input']>;
  level_gt?: InputMaybe<Scalars['Int']['input']>;
  level_lt?: InputMaybe<Scalars['Int']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  pack_in?: InputMaybe<Scalars['_text']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  search_flavor?: InputMaybe<Scalars['Boolean']['input']>;
  search_text?: InputMaybe<Scalars['Boolean']['input']>;
  search_traits?: InputMaybe<Scalars['Boolean']['input']>;
  set_in?: InputMaybe<Scalars['_text']['input']>;
  type_in?: InputMaybe<Scalars['_text']['input']>;
};

/** select columns of table "rangers.card" */
export enum Rangers_Card_Select_Column {
  /** column name */
  ApproachConflict = 'approach_conflict',
  /** column name */
  ApproachConnection = 'approach_connection',
  /** column name */
  ApproachExploration = 'approach_exploration',
  /** column name */
  ApproachReason = 'approach_reason',
  /** column name */
  AreaId = 'area_id',
  /** column name */
  AspectId = 'aspect_id',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  CrestChallenge = 'crest_challenge',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  Equip = 'equip',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  GuideEntry = 'guide_entry',
  /** column name */
  Harm = 'harm',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Level = 'level',
  /** column name */
  Locations = 'locations',
  /** column name */
  MountainChallenge = 'mountain_challenge',
  /** column name */
  Name = 'name',
  /** column name */
  Objective = 'objective',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  Position = 'position',
  /** column name */
  Presence = 'presence',
  /** column name */
  Progress = 'progress',
  /** column name */
  ProgressFixed = 'progress_fixed',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  SetId = 'set_id',
  /** column name */
  SetPosition = 'set_position',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  SubsetId = 'subset_id',
  /** column name */
  SubsetPosition = 'subset_position',
  /** column name */
  SunChallenge = 'sun_challenge',
  /** column name */
  TabooId = 'taboo_id',
  /** column name */
  Text = 'text',
  /** column name */
  TokenCount = 'token_count',
  /** column name */
  TokenId = 'token_id',
  /** column name */
  Traits = 'traits',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.card" */
export type Rangers_Card_Set_Input = {
  approach_conflict?: InputMaybe<Scalars['Int']['input']>;
  approach_connection?: InputMaybe<Scalars['Int']['input']>;
  approach_exploration?: InputMaybe<Scalars['Int']['input']>;
  approach_reason?: InputMaybe<Scalars['Int']['input']>;
  area_id?: InputMaybe<Scalars['String']['input']>;
  aspect_id?: InputMaybe<Scalars['String']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  crest_challenge?: InputMaybe<Scalars['String']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  equip?: InputMaybe<Scalars['Int']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  guide_entry?: InputMaybe<Scalars['String']['input']>;
  harm?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  locations?: InputMaybe<Scalars['jsonb']['input']>;
  mountain_challenge?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  presence?: InputMaybe<Scalars['Int']['input']>;
  progress?: InputMaybe<Scalars['Int']['input']>;
  progress_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  set_position?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  subset_id?: InputMaybe<Scalars['String']['input']>;
  subset_position?: InputMaybe<Scalars['Int']['input']>;
  sun_challenge?: InputMaybe<Scalars['String']['input']>;
  taboo_id?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  token_count?: InputMaybe<Scalars['Int']['input']>;
  token_id?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Card_Stddev_Fields = {
  __typename?: 'rangers_card_stddev_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Card_Stddev_Pop_Fields = {
  __typename?: 'rangers_card_stddev_pop_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Card_Stddev_Samp_Fields = {
  __typename?: 'rangers_card_stddev_samp_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_card" */
export type Rangers_Card_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Card_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Card_Stream_Cursor_Value_Input = {
  approach_conflict?: InputMaybe<Scalars['Int']['input']>;
  approach_connection?: InputMaybe<Scalars['Int']['input']>;
  approach_exploration?: InputMaybe<Scalars['Int']['input']>;
  approach_reason?: InputMaybe<Scalars['Int']['input']>;
  area_id?: InputMaybe<Scalars['String']['input']>;
  aspect_id?: InputMaybe<Scalars['String']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  crest_challenge?: InputMaybe<Scalars['String']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  equip?: InputMaybe<Scalars['Int']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  guide_entry?: InputMaybe<Scalars['String']['input']>;
  harm?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  locations?: InputMaybe<Scalars['jsonb']['input']>;
  mountain_challenge?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  presence?: InputMaybe<Scalars['Int']['input']>;
  progress?: InputMaybe<Scalars['Int']['input']>;
  progress_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  set_position?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  subset_id?: InputMaybe<Scalars['String']['input']>;
  subset_position?: InputMaybe<Scalars['Int']['input']>;
  sun_challenge?: InputMaybe<Scalars['String']['input']>;
  taboo_id?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  token_count?: InputMaybe<Scalars['Int']['input']>;
  token_id?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Card_Sum_Fields = {
  __typename?: 'rangers_card_sum_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  subset_position?: Maybe<Scalars['Int']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "rangers.card_text" */
export type Rangers_Card_Text = {
  __typename?: 'rangers_card_text';
  crest_challenge?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  imagesrc?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  mountain_challenge?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  sun_challenge?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.card_text" */
export type Rangers_Card_Text_Aggregate = {
  __typename?: 'rangers_card_text_aggregate';
  aggregate?: Maybe<Rangers_Card_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Card_Text>;
};

export type Rangers_Card_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Card_Text_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Card_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.card_text" */
export type Rangers_Card_Text_Aggregate_Fields = {
  __typename?: 'rangers_card_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Card_Text_Max_Fields>;
  min?: Maybe<Rangers_Card_Text_Min_Fields>;
};


/** aggregate fields of "rangers.card_text" */
export type Rangers_Card_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.card_text" */
export type Rangers_Card_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Card_Text_Max_Order_By>;
  min?: InputMaybe<Rangers_Card_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.card_text" */
export type Rangers_Card_Text_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Card_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Card_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "rangers.card_text". All fields are combined with a logical 'AND'. */
export type Rangers_Card_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Card_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Card_Text_Bool_Exp>>;
  crest_challenge?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  mountain_challenge?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  objective?: InputMaybe<String_Comparison_Exp>;
  sun_challenge?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.card_text" */
export enum Rangers_Card_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  CardTextPkey = 'card_text_pkey'
}

/** input type for inserting data into table "rangers.card_text" */
export type Rangers_Card_Text_Insert_Input = {
  crest_challenge?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  mountain_challenge?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  sun_challenge?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Card_Text_Max_Fields = {
  __typename?: 'rangers_card_text_max_fields';
  crest_challenge?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  mountain_challenge?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  sun_challenge?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "rangers.card_text" */
export type Rangers_Card_Text_Max_Order_By = {
  crest_challenge?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  mountain_challenge?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  objective?: InputMaybe<Order_By>;
  sun_challenge?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Card_Text_Min_Fields = {
  __typename?: 'rangers_card_text_min_fields';
  crest_challenge?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  mountain_challenge?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  sun_challenge?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "rangers.card_text" */
export type Rangers_Card_Text_Min_Order_By = {
  crest_challenge?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  mountain_challenge?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  objective?: InputMaybe<Order_By>;
  sun_challenge?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.card_text" */
export type Rangers_Card_Text_Mutation_Response = {
  __typename?: 'rangers_card_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Card_Text>;
};

/** on_conflict condition type for table "rangers.card_text" */
export type Rangers_Card_Text_On_Conflict = {
  constraint: Rangers_Card_Text_Constraint;
  update_columns?: Array<Rangers_Card_Text_Update_Column>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.card_text". */
export type Rangers_Card_Text_Order_By = {
  crest_challenge?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  mountain_challenge?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  objective?: InputMaybe<Order_By>;
  sun_challenge?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.card_text */
export type Rangers_Card_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.card_text" */
export enum Rangers_Card_Text_Select_Column {
  /** column name */
  CrestChallenge = 'crest_challenge',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Locale = 'locale',
  /** column name */
  MountainChallenge = 'mountain_challenge',
  /** column name */
  Name = 'name',
  /** column name */
  Objective = 'objective',
  /** column name */
  SunChallenge = 'sun_challenge',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.card_text" */
export type Rangers_Card_Text_Set_Input = {
  crest_challenge?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  mountain_challenge?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  sun_challenge?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_card_text" */
export type Rangers_Card_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Card_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Card_Text_Stream_Cursor_Value_Input = {
  crest_challenge?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  mountain_challenge?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  sun_challenge?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.card_text" */
export enum Rangers_Card_Text_Update_Column {
  /** column name */
  CrestChallenge = 'crest_challenge',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Locale = 'locale',
  /** column name */
  MountainChallenge = 'mountain_challenge',
  /** column name */
  Name = 'name',
  /** column name */
  Objective = 'objective',
  /** column name */
  SunChallenge = 'sun_challenge',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Card_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Card_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Card_Text_Bool_Exp;
};

/** update columns of table "rangers.card" */
export enum Rangers_Card_Update_Column {
  /** column name */
  ApproachConflict = 'approach_conflict',
  /** column name */
  ApproachConnection = 'approach_connection',
  /** column name */
  ApproachExploration = 'approach_exploration',
  /** column name */
  ApproachReason = 'approach_reason',
  /** column name */
  AreaId = 'area_id',
  /** column name */
  AspectId = 'aspect_id',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  CrestChallenge = 'crest_challenge',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  Equip = 'equip',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  GuideEntry = 'guide_entry',
  /** column name */
  Harm = 'harm',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Level = 'level',
  /** column name */
  Locations = 'locations',
  /** column name */
  MountainChallenge = 'mountain_challenge',
  /** column name */
  Name = 'name',
  /** column name */
  Objective = 'objective',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  Position = 'position',
  /** column name */
  Presence = 'presence',
  /** column name */
  Progress = 'progress',
  /** column name */
  ProgressFixed = 'progress_fixed',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  SetId = 'set_id',
  /** column name */
  SetPosition = 'set_position',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  SubsetId = 'subset_id',
  /** column name */
  SubsetPosition = 'subset_position',
  /** column name */
  SunChallenge = 'sun_challenge',
  /** column name */
  TabooId = 'taboo_id',
  /** column name */
  Text = 'text',
  /** column name */
  TokenCount = 'token_count',
  /** column name */
  TokenId = 'token_id',
  /** column name */
  Traits = 'traits',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "rangers.card_updated" */
export type Rangers_Card_Updated = {
  __typename?: 'rangers_card_updated';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.card_updated" */
export type Rangers_Card_Updated_Aggregate = {
  __typename?: 'rangers_card_updated_aggregate';
  aggregate?: Maybe<Rangers_Card_Updated_Aggregate_Fields>;
  nodes: Array<Rangers_Card_Updated>;
};

/** aggregate fields of "rangers.card_updated" */
export type Rangers_Card_Updated_Aggregate_Fields = {
  __typename?: 'rangers_card_updated_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Card_Updated_Max_Fields>;
  min?: Maybe<Rangers_Card_Updated_Min_Fields>;
};


/** aggregate fields of "rangers.card_updated" */
export type Rangers_Card_Updated_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Card_Updated_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.card_updated". All fields are combined with a logical 'AND'. */
export type Rangers_Card_Updated_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Card_Updated_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Card_Updated_Bool_Exp>>;
  locale?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Card_Updated_Max_Fields = {
  __typename?: 'rangers_card_updated_max_fields';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Card_Updated_Min_Fields = {
  __typename?: 'rangers_card_updated_min_fields';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.card_updated". */
export type Rangers_Card_Updated_Order_By = {
  locale?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.card_updated" */
export enum Rangers_Card_Updated_Select_Column {
  /** column name */
  Locale = 'locale',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "rangers_card_updated" */
export type Rangers_Card_Updated_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Card_Updated_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Card_Updated_Stream_Cursor_Value_Input = {
  locale?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

export type Rangers_Card_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Rangers_Card_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Rangers_Card_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Rangers_Card_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Rangers_Card_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Card_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Rangers_Card_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Card_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Card_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Card_Var_Pop_Fields = {
  __typename?: 'rangers_card_var_pop_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Card_Var_Samp_Fields = {
  __typename?: 'rangers_card_var_samp_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Card_Variance_Fields = {
  __typename?: 'rangers_card_variance_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  subset_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.comment" */
export type Rangers_Comment = {
  __typename?: 'rangers_comment';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  deck?: Maybe<Rangers_Deck>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id: Scalars['uuid']['output'];
  /** An object relationship */
  parent?: Maybe<Rangers_Comment>;
  response_count: Scalars['Int']['output'];
  /** An array relationship */
  responses: Array<Rangers_Comment>;
  /** An aggregate relationship */
  responses_aggregate: Rangers_Comment_Aggregate;
  text?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Rangers_Users;
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "rangers.comment" */
export type Rangers_CommentResponsesArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


/** columns and relationships of "rangers.comment" */
export type Rangers_CommentResponses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};

/** aggregated selection of "rangers.comment" */
export type Rangers_Comment_Aggregate = {
  __typename?: 'rangers_comment_aggregate';
  aggregate?: Maybe<Rangers_Comment_Aggregate_Fields>;
  nodes: Array<Rangers_Comment>;
};

export type Rangers_Comment_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Comment_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Comment_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Comment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.comment" */
export type Rangers_Comment_Aggregate_Fields = {
  __typename?: 'rangers_comment_aggregate_fields';
  avg?: Maybe<Rangers_Comment_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Comment_Max_Fields>;
  min?: Maybe<Rangers_Comment_Min_Fields>;
  stddev?: Maybe<Rangers_Comment_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Comment_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Comment_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Comment_Sum_Fields>;
  var_pop?: Maybe<Rangers_Comment_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Comment_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Comment_Variance_Fields>;
};


/** aggregate fields of "rangers.comment" */
export type Rangers_Comment_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.comment" */
export type Rangers_Comment_Aggregate_Order_By = {
  avg?: InputMaybe<Rangers_Comment_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Comment_Max_Order_By>;
  min?: InputMaybe<Rangers_Comment_Min_Order_By>;
  stddev?: InputMaybe<Rangers_Comment_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Rangers_Comment_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Rangers_Comment_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Rangers_Comment_Sum_Order_By>;
  var_pop?: InputMaybe<Rangers_Comment_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Rangers_Comment_Var_Samp_Order_By>;
  variance?: InputMaybe<Rangers_Comment_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.comment" */
export type Rangers_Comment_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Comment_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Comment_On_Conflict>;
};

/** aggregate avg on columns */
export type Rangers_Comment_Avg_Fields = {
  __typename?: 'rangers_comment_avg_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "rangers.comment" */
export type Rangers_Comment_Avg_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "rangers.comment". All fields are combined with a logical 'AND'. */
export type Rangers_Comment_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Comment_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Comment_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Comment_Bool_Exp>>;
  comment_id?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  parent?: InputMaybe<Rangers_Comment_Bool_Exp>;
  response_count?: InputMaybe<Int_Comparison_Exp>;
  responses?: InputMaybe<Rangers_Comment_Bool_Exp>;
  responses_aggregate?: InputMaybe<Rangers_Comment_Aggregate_Bool_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.comment" */
export enum Rangers_Comment_Constraint {
  /** unique or primary key constraint on columns "id", "deck_id" */
  CommentIdDeckIdKey = 'comment_id_deck_id_key',
  /** unique or primary key constraint on columns "id" */
  CommentPkey = 'comment_pkey'
}

/** input type for incrementing numeric columns in table "rangers.comment" */
export type Rangers_Comment_Inc_Input = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.comment" */
export type Rangers_Comment_Insert_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  parent?: InputMaybe<Rangers_Comment_Obj_Rel_Insert_Input>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  responses?: InputMaybe<Rangers_Comment_Arr_Rel_Insert_Input>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Comment_Max_Fields = {
  __typename?: 'rangers_comment_max_fields';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.comment" */
export type Rangers_Comment_Max_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Comment_Min_Fields = {
  __typename?: 'rangers_comment_min_fields';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.comment" */
export type Rangers_Comment_Min_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.comment" */
export type Rangers_Comment_Mutation_Response = {
  __typename?: 'rangers_comment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Comment>;
};

/** input type for inserting object relation for remote table "rangers.comment" */
export type Rangers_Comment_Obj_Rel_Insert_Input = {
  data: Rangers_Comment_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Comment_On_Conflict>;
};

/** on_conflict condition type for table "rangers.comment" */
export type Rangers_Comment_On_Conflict = {
  constraint: Rangers_Comment_Constraint;
  update_columns?: Array<Rangers_Comment_Update_Column>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.comment". */
export type Rangers_Comment_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck?: InputMaybe<Rangers_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parent?: InputMaybe<Rangers_Comment_Order_By>;
  response_count?: InputMaybe<Order_By>;
  responses_aggregate?: InputMaybe<Rangers_Comment_Aggregate_Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.comment */
export type Rangers_Comment_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "rangers.comment" */
export enum Rangers_Comment_Select_Column {
  /** column name */
  CommentId = 'comment_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Id = 'id',
  /** column name */
  ResponseCount = 'response_count',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.comment" */
export type Rangers_Comment_Set_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Comment_Stddev_Fields = {
  __typename?: 'rangers_comment_stddev_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "rangers.comment" */
export type Rangers_Comment_Stddev_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Comment_Stddev_Pop_Fields = {
  __typename?: 'rangers_comment_stddev_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "rangers.comment" */
export type Rangers_Comment_Stddev_Pop_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Comment_Stddev_Samp_Fields = {
  __typename?: 'rangers_comment_stddev_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "rangers.comment" */
export type Rangers_Comment_Stddev_Samp_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "rangers_comment" */
export type Rangers_Comment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Comment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Comment_Stream_Cursor_Value_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Comment_Sum_Fields = {
  __typename?: 'rangers_comment_sum_fields';
  deck_id?: Maybe<Scalars['Int']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "rangers.comment" */
export type Rangers_Comment_Sum_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** update columns of table "rangers.comment" */
export enum Rangers_Comment_Update_Column {
  /** column name */
  CommentId = 'comment_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Id = 'id',
  /** column name */
  ResponseCount = 'response_count',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_Comment_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Comment_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Comment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Comment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Comment_Var_Pop_Fields = {
  __typename?: 'rangers_comment_var_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "rangers.comment" */
export type Rangers_Comment_Var_Pop_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Rangers_Comment_Var_Samp_Fields = {
  __typename?: 'rangers_comment_var_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "rangers.comment" */
export type Rangers_Comment_Var_Samp_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Rangers_Comment_Variance_Fields = {
  __typename?: 'rangers_comment_variance_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "rangers.comment" */
export type Rangers_Comment_Variance_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** columns and relationships of "rangers.deck" */
export type Rangers_Deck = {
  __typename?: 'rangers_deck';
  awa: Scalars['Int']['output'];
  /** An object relationship */
  base_deck?: Maybe<Rangers_Deck>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  campaign?: Maybe<Rangers_Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count: Scalars['Int']['output'];
  /** An array relationship */
  comments: Array<Rangers_Comment>;
  /** An aggregate relationship */
  comments_aggregate: Rangers_Comment_Aggregate;
  copy_count: Scalars['Int']['output'];
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  extra_slots: Scalars['jsonb']['output'];
  fit: Scalars['Int']['output'];
  foc: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  like_count?: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "rangers.deck_liked_by_user" */
  liked_by_user?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  likes?: Maybe<Rangers_Deck_Like_Count>;
  meta: Scalars['jsonb']['output'];
  name: Scalars['String']['output'];
  /** An object relationship */
  next_deck?: Maybe<Rangers_Deck>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  original_deck?: Maybe<Rangers_Deck_Copy>;
  /** An object relationship */
  previous_deck?: Maybe<Rangers_Deck>;
  published?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  rank?: Maybe<Rangers_Deck_Rank>;
  side_slots: Scalars['jsonb']['output'];
  slots: Scalars['jsonb']['output'];
  spi: Scalars['Int']['output'];
  taboo_set_id?: Maybe<Scalars['String']['output']>;
  tags: Scalars['jsonb']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  upgrade?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  user: Rangers_Users;
  user_id: Scalars['String']['output'];
  version: Scalars['Int']['output'];
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckCommentsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckComments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckExtra_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckMetaArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckSide_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckSlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckUpgradeArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "rangers.deck" */
export type Rangers_Deck_Aggregate = {
  __typename?: 'rangers_deck_aggregate';
  aggregate?: Maybe<Rangers_Deck_Aggregate_Fields>;
  nodes: Array<Rangers_Deck>;
};

/** aggregate fields of "rangers.deck" */
export type Rangers_Deck_Aggregate_Fields = {
  __typename?: 'rangers_deck_aggregate_fields';
  avg?: Maybe<Rangers_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Deck_Max_Fields>;
  min?: Maybe<Rangers_Deck_Min_Fields>;
  stddev?: Maybe<Rangers_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Deck_Sum_Fields>;
  var_pop?: Maybe<Rangers_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Deck_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Deck_Variance_Fields>;
};


/** aggregate fields of "rangers.deck" */
export type Rangers_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Deck_Append_Input = {
  extra_slots?: InputMaybe<Scalars['jsonb']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Deck_Avg_Fields = {
  __typename?: 'rangers_deck_avg_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.deck". All fields are combined with a logical 'AND'. */
export type Rangers_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Deck_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Deck_Bool_Exp>>;
  awa?: InputMaybe<Int_Comparison_Exp>;
  base_deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  base_deck_id?: InputMaybe<Int_Comparison_Exp>;
  campaign?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  comment_count?: InputMaybe<Int_Comparison_Exp>;
  comments?: InputMaybe<Rangers_Comment_Bool_Exp>;
  comments_aggregate?: InputMaybe<Rangers_Comment_Aggregate_Bool_Exp>;
  copy_count?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  extra_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  fit?: InputMaybe<Int_Comparison_Exp>;
  foc?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  like_count?: InputMaybe<Int_Comparison_Exp>;
  liked_by_user?: InputMaybe<Boolean_Comparison_Exp>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
  meta?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  next_deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  next_deck_id?: InputMaybe<Int_Comparison_Exp>;
  original_deck?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
  previous_deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  published?: InputMaybe<Boolean_Comparison_Exp>;
  rank?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
  side_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  slots?: InputMaybe<Jsonb_Comparison_Exp>;
  spi?: InputMaybe<Int_Comparison_Exp>;
  taboo_set_id?: InputMaybe<String_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  upgrade?: InputMaybe<Jsonb_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
  version?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.deck" */
export enum Rangers_Deck_Constraint {
  /** unique or primary key constraint on columns "next_deck_id" */
  DeckNextDeckIdKey = 'deck_next_deck_id_key',
  /** unique or primary key constraint on columns "id" */
  DeckPkey = 'deck_pkey'
}

/** columns and relationships of "rangers.deck_copy" */
export type Rangers_Deck_Copy = {
  __typename?: 'rangers_deck_copy';
  copy_deck_id: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  deck: Rangers_Deck;
  /** An object relationship */
  deck_copy: Rangers_Deck;
  deck_id: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Rangers_Users;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "rangers.deck_copy" */
export type Rangers_Deck_Copy_Aggregate = {
  __typename?: 'rangers_deck_copy_aggregate';
  aggregate?: Maybe<Rangers_Deck_Copy_Aggregate_Fields>;
  nodes: Array<Rangers_Deck_Copy>;
};

/** aggregate fields of "rangers.deck_copy" */
export type Rangers_Deck_Copy_Aggregate_Fields = {
  __typename?: 'rangers_deck_copy_aggregate_fields';
  avg?: Maybe<Rangers_Deck_Copy_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Deck_Copy_Max_Fields>;
  min?: Maybe<Rangers_Deck_Copy_Min_Fields>;
  stddev?: Maybe<Rangers_Deck_Copy_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Deck_Copy_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Deck_Copy_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Deck_Copy_Sum_Fields>;
  var_pop?: Maybe<Rangers_Deck_Copy_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Deck_Copy_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Deck_Copy_Variance_Fields>;
};


/** aggregate fields of "rangers.deck_copy" */
export type Rangers_Deck_Copy_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Deck_Copy_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Deck_Copy_Avg_Fields = {
  __typename?: 'rangers_deck_copy_avg_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.deck_copy". All fields are combined with a logical 'AND'. */
export type Rangers_Deck_Copy_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Deck_Copy_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Deck_Copy_Bool_Exp>>;
  copy_deck_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  deck_copy?: InputMaybe<Rangers_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.deck_copy" */
export enum Rangers_Deck_Copy_Constraint {
  /** unique or primary key constraint on columns "copy_deck_id" */
  DeckCopyCopyDeckIdKey = 'deck_copy_copy_deck_id_key',
  /** unique or primary key constraint on columns "copy_deck_id" */
  DeckCopyPkey = 'deck_copy_pkey'
}

/** input type for incrementing numeric columns in table "rangers.deck_copy" */
export type Rangers_Deck_Copy_Inc_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.deck_copy" */
export type Rangers_Deck_Copy_Insert_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  deck_copy?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Deck_Copy_Max_Fields = {
  __typename?: 'rangers_deck_copy_max_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Deck_Copy_Min_Fields = {
  __typename?: 'rangers_deck_copy_min_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.deck_copy" */
export type Rangers_Deck_Copy_Mutation_Response = {
  __typename?: 'rangers_deck_copy_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Deck_Copy>;
};

/** input type for inserting object relation for remote table "rangers.deck_copy" */
export type Rangers_Deck_Copy_Obj_Rel_Insert_Input = {
  data: Rangers_Deck_Copy_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Deck_Copy_On_Conflict>;
};

/** on_conflict condition type for table "rangers.deck_copy" */
export type Rangers_Deck_Copy_On_Conflict = {
  constraint: Rangers_Deck_Copy_Constraint;
  update_columns?: Array<Rangers_Deck_Copy_Update_Column>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.deck_copy". */
export type Rangers_Deck_Copy_Order_By = {
  copy_deck_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck?: InputMaybe<Rangers_Deck_Order_By>;
  deck_copy?: InputMaybe<Rangers_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.deck_copy */
export type Rangers_Deck_Copy_Pk_Columns_Input = {
  copy_deck_id: Scalars['Int']['input'];
};

/** select columns of table "rangers.deck_copy" */
export enum Rangers_Deck_Copy_Select_Column {
  /** column name */
  CopyDeckId = 'copy_deck_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.deck_copy" */
export type Rangers_Deck_Copy_Set_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Deck_Copy_Stddev_Fields = {
  __typename?: 'rangers_deck_copy_stddev_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Deck_Copy_Stddev_Pop_Fields = {
  __typename?: 'rangers_deck_copy_stddev_pop_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Deck_Copy_Stddev_Samp_Fields = {
  __typename?: 'rangers_deck_copy_stddev_samp_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_deck_copy" */
export type Rangers_Deck_Copy_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Deck_Copy_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Deck_Copy_Stream_Cursor_Value_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Deck_Copy_Sum_Fields = {
  __typename?: 'rangers_deck_copy_sum_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.deck_copy" */
export enum Rangers_Deck_Copy_Update_Column {
  /** column name */
  CopyDeckId = 'copy_deck_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_Deck_Copy_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Deck_Copy_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Deck_Copy_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Deck_Copy_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Deck_Copy_Var_Pop_Fields = {
  __typename?: 'rangers_deck_copy_var_pop_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Deck_Copy_Var_Samp_Fields = {
  __typename?: 'rangers_deck_copy_var_samp_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Deck_Copy_Variance_Fields = {
  __typename?: 'rangers_deck_copy_variance_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Rangers_Deck_Delete_At_Path_Input = {
  extra_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  meta?: InputMaybe<Array<Scalars['String']['input']>>;
  side_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  slots?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  upgrade?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Rangers_Deck_Delete_Elem_Input = {
  extra_slots?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['Int']['input']>;
  side_slots?: InputMaybe<Scalars['Int']['input']>;
  slots?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['Int']['input']>;
  upgrade?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Rangers_Deck_Delete_Key_Input = {
  extra_slots?: InputMaybe<Scalars['String']['input']>;
  meta?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['String']['input']>;
  slots?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
  upgrade?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "rangers.deck" */
export type Rangers_Deck_Inc_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.deck" */
export type Rangers_Deck_Insert_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign?: InputMaybe<Rangers_Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  comments?: InputMaybe<Rangers_Comment_Arr_Rel_Insert_Input>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  extra_slots?: InputMaybe<Scalars['jsonb']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Obj_Rel_Insert_Input>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  original_deck?: InputMaybe<Rangers_Deck_Copy_Obj_Rel_Insert_Input>;
  previous_deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  rank?: InputMaybe<Rangers_Deck_Rank_Obj_Rel_Insert_Input>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  taboo_set_id?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** columns and relationships of "rangers.deck_like" */
export type Rangers_Deck_Like = {
  __typename?: 'rangers_deck_like';
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  deck: Rangers_Deck;
  deck_id: Scalars['Int']['output'];
  liked: Scalars['Boolean']['output'];
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "rangers.deck_like" */
export type Rangers_Deck_Like_Aggregate = {
  __typename?: 'rangers_deck_like_aggregate';
  aggregate?: Maybe<Rangers_Deck_Like_Aggregate_Fields>;
  nodes: Array<Rangers_Deck_Like>;
};

/** aggregate fields of "rangers.deck_like" */
export type Rangers_Deck_Like_Aggregate_Fields = {
  __typename?: 'rangers_deck_like_aggregate_fields';
  avg?: Maybe<Rangers_Deck_Like_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Deck_Like_Max_Fields>;
  min?: Maybe<Rangers_Deck_Like_Min_Fields>;
  stddev?: Maybe<Rangers_Deck_Like_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Deck_Like_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Deck_Like_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Deck_Like_Sum_Fields>;
  var_pop?: Maybe<Rangers_Deck_Like_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Deck_Like_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Deck_Like_Variance_Fields>;
};


/** aggregate fields of "rangers.deck_like" */
export type Rangers_Deck_Like_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Deck_Like_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Deck_Like_Avg_Fields = {
  __typename?: 'rangers_deck_like_avg_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.deck_like". All fields are combined with a logical 'AND'. */
export type Rangers_Deck_Like_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Deck_Like_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Deck_Like_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  liked?: InputMaybe<Boolean_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.deck_like" */
export enum Rangers_Deck_Like_Constraint {
  /** unique or primary key constraint on columns "user_id", "deck_id" */
  DeckLikesPkey = 'deck_likes_pkey'
}

/** columns and relationships of "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count = {
  __typename?: 'rangers_deck_like_count';
  count: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  deck_id: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Aggregate = {
  __typename?: 'rangers_deck_like_count_aggregate';
  aggregate?: Maybe<Rangers_Deck_Like_Count_Aggregate_Fields>;
  nodes: Array<Rangers_Deck_Like_Count>;
};

/** aggregate fields of "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Aggregate_Fields = {
  __typename?: 'rangers_deck_like_count_aggregate_fields';
  avg?: Maybe<Rangers_Deck_Like_Count_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Deck_Like_Count_Max_Fields>;
  min?: Maybe<Rangers_Deck_Like_Count_Min_Fields>;
  stddev?: Maybe<Rangers_Deck_Like_Count_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Deck_Like_Count_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Deck_Like_Count_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Deck_Like_Count_Sum_Fields>;
  var_pop?: Maybe<Rangers_Deck_Like_Count_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Deck_Like_Count_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Deck_Like_Count_Variance_Fields>;
};


/** aggregate fields of "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Deck_Like_Count_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Deck_Like_Count_Avg_Fields = {
  __typename?: 'rangers_deck_like_count_avg_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.deck_like_count". All fields are combined with a logical 'AND'. */
export type Rangers_Deck_Like_Count_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Deck_Like_Count_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Deck_Like_Count_Bool_Exp>>;
  count?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.deck_like_count" */
export enum Rangers_Deck_Like_Count_Constraint {
  /** unique or primary key constraint on columns "deck_id" */
  DeckLikeCountPkey = 'deck_like_count_pkey'
}

/** input type for incrementing numeric columns in table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Inc_Input = {
  count?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Insert_Input = {
  count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Deck_Like_Count_Max_Fields = {
  __typename?: 'rangers_deck_like_count_max_fields';
  count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Deck_Like_Count_Min_Fields = {
  __typename?: 'rangers_deck_like_count_min_fields';
  count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Mutation_Response = {
  __typename?: 'rangers_deck_like_count_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Deck_Like_Count>;
};

/** input type for inserting object relation for remote table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Obj_Rel_Insert_Input = {
  data: Rangers_Deck_Like_Count_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Deck_Like_Count_On_Conflict>;
};

/** on_conflict condition type for table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_On_Conflict = {
  constraint: Rangers_Deck_Like_Count_Constraint;
  update_columns?: Array<Rangers_Deck_Like_Count_Update_Column>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.deck_like_count". */
export type Rangers_Deck_Like_Count_Order_By = {
  count?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.deck_like_count */
export type Rangers_Deck_Like_Count_Pk_Columns_Input = {
  deck_id: Scalars['Int']['input'];
};

/** select columns of table "rangers.deck_like_count" */
export enum Rangers_Deck_Like_Count_Select_Column {
  /** column name */
  Count = 'count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Set_Input = {
  count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Deck_Like_Count_Stddev_Fields = {
  __typename?: 'rangers_deck_like_count_stddev_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Deck_Like_Count_Stddev_Pop_Fields = {
  __typename?: 'rangers_deck_like_count_stddev_pop_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Deck_Like_Count_Stddev_Samp_Fields = {
  __typename?: 'rangers_deck_like_count_stddev_samp_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_deck_like_count" */
export type Rangers_Deck_Like_Count_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Deck_Like_Count_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Deck_Like_Count_Stream_Cursor_Value_Input = {
  count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Deck_Like_Count_Sum_Fields = {
  __typename?: 'rangers_deck_like_count_sum_fields';
  count?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.deck_like_count" */
export enum Rangers_Deck_Like_Count_Update_Column {
  /** column name */
  Count = 'count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Deck_Like_Count_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Deck_Like_Count_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Deck_Like_Count_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Deck_Like_Count_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Deck_Like_Count_Var_Pop_Fields = {
  __typename?: 'rangers_deck_like_count_var_pop_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Deck_Like_Count_Var_Samp_Fields = {
  __typename?: 'rangers_deck_like_count_var_samp_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Deck_Like_Count_Variance_Fields = {
  __typename?: 'rangers_deck_like_count_variance_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** input type for incrementing numeric columns in table "rangers.deck_like" */
export type Rangers_Deck_Like_Inc_Input = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.deck_like" */
export type Rangers_Deck_Like_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Deck_Like_Max_Fields = {
  __typename?: 'rangers_deck_like_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Deck_Like_Min_Fields = {
  __typename?: 'rangers_deck_like_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.deck_like" */
export type Rangers_Deck_Like_Mutation_Response = {
  __typename?: 'rangers_deck_like_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Deck_Like>;
};

/** on_conflict condition type for table "rangers.deck_like" */
export type Rangers_Deck_Like_On_Conflict = {
  constraint: Rangers_Deck_Like_Constraint;
  update_columns?: Array<Rangers_Deck_Like_Update_Column>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.deck_like". */
export type Rangers_Deck_Like_Order_By = {
  created_at?: InputMaybe<Order_By>;
  deck?: InputMaybe<Rangers_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  liked?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.deck_like */
export type Rangers_Deck_Like_Pk_Columns_Input = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};

/** select columns of table "rangers.deck_like" */
export enum Rangers_Deck_Like_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Liked = 'liked',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.deck_like" */
export type Rangers_Deck_Like_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Deck_Like_Stddev_Fields = {
  __typename?: 'rangers_deck_like_stddev_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Deck_Like_Stddev_Pop_Fields = {
  __typename?: 'rangers_deck_like_stddev_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Deck_Like_Stddev_Samp_Fields = {
  __typename?: 'rangers_deck_like_stddev_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_deck_like" */
export type Rangers_Deck_Like_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Deck_Like_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Deck_Like_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Deck_Like_Sum_Fields = {
  __typename?: 'rangers_deck_like_sum_fields';
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.deck_like" */
export enum Rangers_Deck_Like_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Liked = 'liked',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_Deck_Like_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Deck_Like_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Deck_Like_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Deck_Like_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Deck_Like_Var_Pop_Fields = {
  __typename?: 'rangers_deck_like_var_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Deck_Like_Var_Samp_Fields = {
  __typename?: 'rangers_deck_like_var_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Deck_Like_Variance_Fields = {
  __typename?: 'rangers_deck_like_variance_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type Rangers_Deck_Max_Fields = {
  __typename?: 'rangers_deck_max_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  taboo_set_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Rangers_Deck_Min_Fields = {
  __typename?: 'rangers_deck_min_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  taboo_set_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "rangers.deck" */
export type Rangers_Deck_Mutation_Response = {
  __typename?: 'rangers_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Deck>;
};

/** input type for inserting object relation for remote table "rangers.deck" */
export type Rangers_Deck_Obj_Rel_Insert_Input = {
  data: Rangers_Deck_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Deck_On_Conflict>;
};

/** on_conflict condition type for table "rangers.deck" */
export type Rangers_Deck_On_Conflict = {
  constraint: Rangers_Deck_Constraint;
  update_columns?: Array<Rangers_Deck_Update_Column>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.deck". */
export type Rangers_Deck_Order_By = {
  awa?: InputMaybe<Order_By>;
  base_deck?: InputMaybe<Rangers_Deck_Order_By>;
  base_deck_id?: InputMaybe<Order_By>;
  campaign?: InputMaybe<Rangers_Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  comment_count?: InputMaybe<Order_By>;
  comments_aggregate?: InputMaybe<Rangers_Comment_Aggregate_Order_By>;
  copy_count?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  extra_slots?: InputMaybe<Order_By>;
  fit?: InputMaybe<Order_By>;
  foc?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  like_count?: InputMaybe<Order_By>;
  liked_by_user?: InputMaybe<Order_By>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Order_By>;
  meta?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  next_deck?: InputMaybe<Rangers_Deck_Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  original_deck?: InputMaybe<Rangers_Deck_Copy_Order_By>;
  previous_deck?: InputMaybe<Rangers_Deck_Order_By>;
  published?: InputMaybe<Order_By>;
  rank?: InputMaybe<Rangers_Deck_Rank_Order_By>;
  side_slots?: InputMaybe<Order_By>;
  slots?: InputMaybe<Order_By>;
  spi?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  upgrade?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.deck */
export type Rangers_Deck_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Deck_Prepend_Input = {
  extra_slots?: InputMaybe<Scalars['jsonb']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
};

/** columns and relationships of "rangers.deck_rank" */
export type Rangers_Deck_Rank = {
  __typename?: 'rangers_deck_rank';
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['bigint']['output']>;
  score?: Maybe<Scalars['float8']['output']>;
};

/** aggregated selection of "rangers.deck_rank" */
export type Rangers_Deck_Rank_Aggregate = {
  __typename?: 'rangers_deck_rank_aggregate';
  aggregate?: Maybe<Rangers_Deck_Rank_Aggregate_Fields>;
  nodes: Array<Rangers_Deck_Rank>;
};

/** aggregate fields of "rangers.deck_rank" */
export type Rangers_Deck_Rank_Aggregate_Fields = {
  __typename?: 'rangers_deck_rank_aggregate_fields';
  avg?: Maybe<Rangers_Deck_Rank_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Deck_Rank_Max_Fields>;
  min?: Maybe<Rangers_Deck_Rank_Min_Fields>;
  stddev?: Maybe<Rangers_Deck_Rank_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Deck_Rank_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Deck_Rank_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Deck_Rank_Sum_Fields>;
  var_pop?: Maybe<Rangers_Deck_Rank_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Deck_Rank_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Deck_Rank_Variance_Fields>;
};


/** aggregate fields of "rangers.deck_rank" */
export type Rangers_Deck_Rank_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Deck_Rank_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Deck_Rank_Avg_Fields = {
  __typename?: 'rangers_deck_rank_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.deck_rank". All fields are combined with a logical 'AND'. */
export type Rangers_Deck_Rank_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Deck_Rank_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Deck_Rank_Bool_Exp>>;
  id?: InputMaybe<Int_Comparison_Exp>;
  like_count?: InputMaybe<Bigint_Comparison_Exp>;
  score?: InputMaybe<Float8_Comparison_Exp>;
};

/** input type for inserting data into table "rangers.deck_rank" */
export type Rangers_Deck_Rank_Insert_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['bigint']['input']>;
  score?: InputMaybe<Scalars['float8']['input']>;
};

/** aggregate max on columns */
export type Rangers_Deck_Rank_Max_Fields = {
  __typename?: 'rangers_deck_rank_max_fields';
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['bigint']['output']>;
  score?: Maybe<Scalars['float8']['output']>;
};

/** aggregate min on columns */
export type Rangers_Deck_Rank_Min_Fields = {
  __typename?: 'rangers_deck_rank_min_fields';
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['bigint']['output']>;
  score?: Maybe<Scalars['float8']['output']>;
};

/** input type for inserting object relation for remote table "rangers.deck_rank" */
export type Rangers_Deck_Rank_Obj_Rel_Insert_Input = {
  data: Rangers_Deck_Rank_Insert_Input;
};

/** Ordering options when selecting data from "rangers.deck_rank". */
export type Rangers_Deck_Rank_Order_By = {
  id?: InputMaybe<Order_By>;
  like_count?: InputMaybe<Order_By>;
  score?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.deck_rank" */
export enum Rangers_Deck_Rank_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Score = 'score'
}

/** aggregate stddev on columns */
export type Rangers_Deck_Rank_Stddev_Fields = {
  __typename?: 'rangers_deck_rank_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Deck_Rank_Stddev_Pop_Fields = {
  __typename?: 'rangers_deck_rank_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Deck_Rank_Stddev_Samp_Fields = {
  __typename?: 'rangers_deck_rank_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_deck_rank" */
export type Rangers_Deck_Rank_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Deck_Rank_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Deck_Rank_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['bigint']['input']>;
  score?: InputMaybe<Scalars['float8']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Deck_Rank_Sum_Fields = {
  __typename?: 'rangers_deck_rank_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['bigint']['output']>;
  score?: Maybe<Scalars['float8']['output']>;
};

/** aggregate var_pop on columns */
export type Rangers_Deck_Rank_Var_Pop_Fields = {
  __typename?: 'rangers_deck_rank_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Deck_Rank_Var_Samp_Fields = {
  __typename?: 'rangers_deck_rank_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Deck_Rank_Variance_Fields = {
  __typename?: 'rangers_deck_rank_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

export type Rangers_Deck_Search_Args = {
  _limit?: InputMaybe<Scalars['Int']['input']>;
  _offset?: InputMaybe<Scalars['Int']['input']>;
  _taboo_set_id?: InputMaybe<Scalars['_text']['input']>;
  awa_eq?: InputMaybe<Scalars['Int']['input']>;
  background?: InputMaybe<Scalars['_text']['input']>;
  fit_eq?: InputMaybe<Scalars['Int']['input']>;
  foc_eq?: InputMaybe<Scalars['Int']['input']>;
  role?: InputMaybe<Scalars['_text']['input']>;
  specialty?: InputMaybe<Scalars['_text']['input']>;
  spi_eq?: InputMaybe<Scalars['Int']['input']>;
  user_id_eq?: InputMaybe<Scalars['String']['input']>;
};

/** select columns of table "rangers.deck" */
export enum Rangers_Deck_Select_Column {
  /** column name */
  Awa = 'awa',
  /** column name */
  BaseDeckId = 'base_deck_id',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CommentCount = 'comment_count',
  /** column name */
  CopyCount = 'copy_count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  ExtraSlots = 'extra_slots',
  /** column name */
  Fit = 'fit',
  /** column name */
  Foc = 'foc',
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  Published = 'published',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Spi = 'spi',
  /** column name */
  TabooSetId = 'taboo_set_id',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Upgrade = 'upgrade',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "rangers.deck" */
export type Rangers_Deck_Set_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  extra_slots?: InputMaybe<Scalars['jsonb']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  taboo_set_id?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Deck_Stddev_Fields = {
  __typename?: 'rangers_deck_stddev_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Deck_Stddev_Pop_Fields = {
  __typename?: 'rangers_deck_stddev_pop_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Deck_Stddev_Samp_Fields = {
  __typename?: 'rangers_deck_stddev_samp_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_deck" */
export type Rangers_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Deck_Stream_Cursor_Value_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  extra_slots?: InputMaybe<Scalars['jsonb']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  taboo_set_id?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Deck_Sum_Fields = {
  __typename?: 'rangers_deck_sum_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.deck" */
export enum Rangers_Deck_Update_Column {
  /** column name */
  Awa = 'awa',
  /** column name */
  BaseDeckId = 'base_deck_id',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CommentCount = 'comment_count',
  /** column name */
  CopyCount = 'copy_count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  ExtraSlots = 'extra_slots',
  /** column name */
  Fit = 'fit',
  /** column name */
  Foc = 'foc',
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  Published = 'published',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Spi = 'spi',
  /** column name */
  TabooSetId = 'taboo_set_id',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Upgrade = 'upgrade',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Version = 'version'
}

export type Rangers_Deck_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Rangers_Deck_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Rangers_Deck_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Rangers_Deck_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Rangers_Deck_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Deck_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Rangers_Deck_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Deck_Var_Pop_Fields = {
  __typename?: 'rangers_deck_var_pop_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Deck_Var_Samp_Fields = {
  __typename?: 'rangers_deck_var_samp_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Deck_Variance_Fields = {
  __typename?: 'rangers_deck_variance_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.faq_entry" */
export type Rangers_Faq_Entry = {
  __typename?: 'rangers_faq_entry';
  card_id: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['String']['output'];
  lang: Scalars['String']['output'];
  text: Scalars['String']['output'];
};

/** aggregated selection of "rangers.faq_entry" */
export type Rangers_Faq_Entry_Aggregate = {
  __typename?: 'rangers_faq_entry_aggregate';
  aggregate?: Maybe<Rangers_Faq_Entry_Aggregate_Fields>;
  nodes: Array<Rangers_Faq_Entry>;
};

/** aggregate fields of "rangers.faq_entry" */
export type Rangers_Faq_Entry_Aggregate_Fields = {
  __typename?: 'rangers_faq_entry_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Faq_Entry_Max_Fields>;
  min?: Maybe<Rangers_Faq_Entry_Min_Fields>;
};


/** aggregate fields of "rangers.faq_entry" */
export type Rangers_Faq_Entry_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Faq_Entry_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.faq_entry". All fields are combined with a logical 'AND'. */
export type Rangers_Faq_Entry_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Faq_Entry_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Faq_Entry_Bool_Exp>>;
  card_id?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  lang?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.faq_entry" */
export enum Rangers_Faq_Entry_Constraint {
  /** unique or primary key constraint on columns "id" */
  FaqEntryPkey = 'faq_entry_pkey'
}

/** input type for inserting data into table "rangers.faq_entry" */
export type Rangers_Faq_Entry_Insert_Input = {
  card_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  lang?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Faq_Entry_Max_Fields = {
  __typename?: 'rangers_faq_entry_max_fields';
  card_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  lang?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Faq_Entry_Min_Fields = {
  __typename?: 'rangers_faq_entry_min_fields';
  card_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  lang?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.faq_entry" */
export type Rangers_Faq_Entry_Mutation_Response = {
  __typename?: 'rangers_faq_entry_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Faq_Entry>;
};

/** on_conflict condition type for table "rangers.faq_entry" */
export type Rangers_Faq_Entry_On_Conflict = {
  constraint: Rangers_Faq_Entry_Constraint;
  update_columns?: Array<Rangers_Faq_Entry_Update_Column>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.faq_entry". */
export type Rangers_Faq_Entry_Order_By = {
  card_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lang?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.faq_entry */
export type Rangers_Faq_Entry_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.faq_entry" */
export enum Rangers_Faq_Entry_Select_Column {
  /** column name */
  CardId = 'card_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  Text = 'text'
}

/** input type for updating data in table "rangers.faq_entry" */
export type Rangers_Faq_Entry_Set_Input = {
  card_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  lang?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_faq_entry" */
export type Rangers_Faq_Entry_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Faq_Entry_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Faq_Entry_Stream_Cursor_Value_Input = {
  card_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  lang?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "rangers.faq_entry" */
export enum Rangers_Faq_Entry_Update_Column {
  /** column name */
  CardId = 'card_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  Text = 'text'
}

export type Rangers_Faq_Entry_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Faq_Entry_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Faq_Entry_Bool_Exp;
};

/** columns and relationships of "rangers.friend_status" */
export type Rangers_Friend_Status = {
  __typename?: 'rangers_friend_status';
  status: Rangers_Friend_Status_Type_Enum;
  user_id_a: Scalars['String']['output'];
  user_id_b: Scalars['String']['output'];
};

/** aggregated selection of "rangers.friend_status" */
export type Rangers_Friend_Status_Aggregate = {
  __typename?: 'rangers_friend_status_aggregate';
  aggregate?: Maybe<Rangers_Friend_Status_Aggregate_Fields>;
  nodes: Array<Rangers_Friend_Status>;
};

/** aggregate fields of "rangers.friend_status" */
export type Rangers_Friend_Status_Aggregate_Fields = {
  __typename?: 'rangers_friend_status_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Friend_Status_Max_Fields>;
  min?: Maybe<Rangers_Friend_Status_Min_Fields>;
};


/** aggregate fields of "rangers.friend_status" */
export type Rangers_Friend_Status_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Friend_Status_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.friend_status". All fields are combined with a logical 'AND'. */
export type Rangers_Friend_Status_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Friend_Status_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Friend_Status_Bool_Exp>>;
  status?: InputMaybe<Rangers_Friend_Status_Type_Enum_Comparison_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.friend_status" */
export enum Rangers_Friend_Status_Constraint {
  /** unique or primary key constraint on columns "user_id_b", "user_id_a" */
  FriendStatusPkey = 'friend_status_pkey'
}

/** input type for inserting data into table "rangers.friend_status" */
export type Rangers_Friend_Status_Insert_Input = {
  status?: InputMaybe<Rangers_Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Friend_Status_Max_Fields = {
  __typename?: 'rangers_friend_status_max_fields';
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Friend_Status_Min_Fields = {
  __typename?: 'rangers_friend_status_min_fields';
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.friend_status" */
export type Rangers_Friend_Status_Mutation_Response = {
  __typename?: 'rangers_friend_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Friend_Status>;
};

/** on_conflict condition type for table "rangers.friend_status" */
export type Rangers_Friend_Status_On_Conflict = {
  constraint: Rangers_Friend_Status_Constraint;
  update_columns?: Array<Rangers_Friend_Status_Update_Column>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.friend_status". */
export type Rangers_Friend_Status_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.friend_status */
export type Rangers_Friend_Status_Pk_Columns_Input = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};

/** select columns of table "rangers.friend_status" */
export enum Rangers_Friend_Status_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "rangers.friend_status" */
export type Rangers_Friend_Status_Set_Input = {
  status?: InputMaybe<Rangers_Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_friend_status" */
export type Rangers_Friend_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Friend_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Friend_Status_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Rangers_Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type = {
  __typename?: 'rangers_friend_status_type';
  value: Scalars['String']['output'];
};

/** aggregated selection of "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Aggregate = {
  __typename?: 'rangers_friend_status_type_aggregate';
  aggregate?: Maybe<Rangers_Friend_Status_Type_Aggregate_Fields>;
  nodes: Array<Rangers_Friend_Status_Type>;
};

/** aggregate fields of "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Aggregate_Fields = {
  __typename?: 'rangers_friend_status_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Friend_Status_Type_Max_Fields>;
  min?: Maybe<Rangers_Friend_Status_Type_Min_Fields>;
};


/** aggregate fields of "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Friend_Status_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.friend_status_type". All fields are combined with a logical 'AND'. */
export type Rangers_Friend_Status_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Friend_Status_Type_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Friend_Status_Type_Bool_Exp>>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.friend_status_type" */
export enum Rangers_Friend_Status_Type_Constraint {
  /** unique or primary key constraint on columns "value" */
  FriendStatusTypePkey = 'friend_status_type_pkey'
}

export enum Rangers_Friend_Status_Type_Enum {
  Friend = 'friend',
  None = 'none',
  Received = 'received',
  Sent = 'sent'
}

/** Boolean expression to compare columns of type "rangers_friend_status_type_enum". All fields are combined with logical 'AND'. */
export type Rangers_Friend_Status_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Rangers_Friend_Status_Type_Enum>;
  _in?: InputMaybe<Array<Rangers_Friend_Status_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Rangers_Friend_Status_Type_Enum>;
  _nin?: InputMaybe<Array<Rangers_Friend_Status_Type_Enum>>;
};

/** input type for inserting data into table "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Insert_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Friend_Status_Type_Max_Fields = {
  __typename?: 'rangers_friend_status_type_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Friend_Status_Type_Min_Fields = {
  __typename?: 'rangers_friend_status_type_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Mutation_Response = {
  __typename?: 'rangers_friend_status_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Friend_Status_Type>;
};

/** on_conflict condition type for table "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_On_Conflict = {
  constraint: Rangers_Friend_Status_Type_Constraint;
  update_columns?: Array<Rangers_Friend_Status_Type_Update_Column>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.friend_status_type". */
export type Rangers_Friend_Status_Type_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.friend_status_type */
export type Rangers_Friend_Status_Type_Pk_Columns_Input = {
  value: Scalars['String']['input'];
};

/** select columns of table "rangers.friend_status_type" */
export enum Rangers_Friend_Status_Type_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Set_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_friend_status_type" */
export type Rangers_Friend_Status_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Friend_Status_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Friend_Status_Type_Stream_Cursor_Value_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "rangers.friend_status_type" */
export enum Rangers_Friend_Status_Type_Update_Column {
  /** column name */
  Value = 'value'
}

export type Rangers_Friend_Status_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Friend_Status_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Friend_Status_Type_Bool_Exp;
};

/** update columns of table "rangers.friend_status" */
export enum Rangers_Friend_Status_Update_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

export type Rangers_Friend_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Friend_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Friend_Status_Bool_Exp;
};

/** columns and relationships of "rangers.latest_deck" */
export type Rangers_Latest_Deck = {
  __typename?: 'rangers_latest_deck';
  /** An object relationship */
  campaign?: Maybe<Rangers_Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  deck?: Maybe<Rangers_Deck>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rangers.latest_deck" */
export type Rangers_Latest_Deck_Aggregate = {
  __typename?: 'rangers_latest_deck_aggregate';
  aggregate?: Maybe<Rangers_Latest_Deck_Aggregate_Fields>;
  nodes: Array<Rangers_Latest_Deck>;
};

export type Rangers_Latest_Deck_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Latest_Deck_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Latest_Deck_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.latest_deck" */
export type Rangers_Latest_Deck_Aggregate_Fields = {
  __typename?: 'rangers_latest_deck_aggregate_fields';
  avg?: Maybe<Rangers_Latest_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Latest_Deck_Max_Fields>;
  min?: Maybe<Rangers_Latest_Deck_Min_Fields>;
  stddev?: Maybe<Rangers_Latest_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Latest_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Latest_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Latest_Deck_Sum_Fields>;
  var_pop?: Maybe<Rangers_Latest_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Latest_Deck_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Latest_Deck_Variance_Fields>;
};


/** aggregate fields of "rangers.latest_deck" */
export type Rangers_Latest_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Aggregate_Order_By = {
  avg?: InputMaybe<Rangers_Latest_Deck_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Latest_Deck_Max_Order_By>;
  min?: InputMaybe<Rangers_Latest_Deck_Min_Order_By>;
  stddev?: InputMaybe<Rangers_Latest_Deck_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Rangers_Latest_Deck_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Rangers_Latest_Deck_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Rangers_Latest_Deck_Sum_Order_By>;
  var_pop?: InputMaybe<Rangers_Latest_Deck_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Rangers_Latest_Deck_Var_Samp_Order_By>;
  variance?: InputMaybe<Rangers_Latest_Deck_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Latest_Deck_Insert_Input>;
};

/** aggregate avg on columns */
export type Rangers_Latest_Deck_Avg_Fields = {
  __typename?: 'rangers_latest_deck_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "rangers.latest_deck". All fields are combined with a logical 'AND'. */
export type Rangers_Latest_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Latest_Deck_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Latest_Deck_Bool_Exp>>;
  campaign?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Insert_Input = {
  campaign?: InputMaybe<Rangers_Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Latest_Deck_Max_Fields = {
  __typename?: 'rangers_latest_deck_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Latest_Deck_Min_Fields = {
  __typename?: 'rangers_latest_deck_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Mutation_Response = {
  __typename?: 'rangers_latest_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Latest_Deck>;
};

/** Ordering options when selecting data from "rangers.latest_deck". */
export type Rangers_Latest_Deck_Order_By = {
  campaign?: InputMaybe<Rangers_Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  deck?: InputMaybe<Rangers_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.latest_deck" */
export enum Rangers_Latest_Deck_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Latest_Deck_Stddev_Fields = {
  __typename?: 'rangers_latest_deck_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Latest_Deck_Stddev_Pop_Fields = {
  __typename?: 'rangers_latest_deck_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Latest_Deck_Stddev_Samp_Fields = {
  __typename?: 'rangers_latest_deck_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "rangers_latest_deck" */
export type Rangers_Latest_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Latest_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Latest_Deck_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Latest_Deck_Sum_Fields = {
  __typename?: 'rangers_latest_deck_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

export type Rangers_Latest_Deck_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Latest_Deck_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Latest_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Latest_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Latest_Deck_Var_Pop_Fields = {
  __typename?: 'rangers_latest_deck_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Rangers_Latest_Deck_Var_Samp_Fields = {
  __typename?: 'rangers_latest_deck_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Rangers_Latest_Deck_Variance_Fields = {
  __typename?: 'rangers_latest_deck_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "rangers.locale" */
export type Rangers_Locale = {
  __typename?: 'rangers_locale';
  locale: Scalars['String']['output'];
};

/** aggregated selection of "rangers.locale" */
export type Rangers_Locale_Aggregate = {
  __typename?: 'rangers_locale_aggregate';
  aggregate?: Maybe<Rangers_Locale_Aggregate_Fields>;
  nodes: Array<Rangers_Locale>;
};

/** aggregate fields of "rangers.locale" */
export type Rangers_Locale_Aggregate_Fields = {
  __typename?: 'rangers_locale_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Locale_Max_Fields>;
  min?: Maybe<Rangers_Locale_Min_Fields>;
};


/** aggregate fields of "rangers.locale" */
export type Rangers_Locale_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Locale_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.locale". All fields are combined with a logical 'AND'. */
export type Rangers_Locale_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Locale_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Locale_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Locale_Bool_Exp>>;
  locale?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.locale" */
export enum Rangers_Locale_Constraint {
  /** unique or primary key constraint on columns "locale" */
  LocalePkey = 'locale_pkey'
}

/** input type for inserting data into table "rangers.locale" */
export type Rangers_Locale_Insert_Input = {
  locale?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Locale_Max_Fields = {
  __typename?: 'rangers_locale_max_fields';
  locale?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Locale_Min_Fields = {
  __typename?: 'rangers_locale_min_fields';
  locale?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.locale" */
export type Rangers_Locale_Mutation_Response = {
  __typename?: 'rangers_locale_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Locale>;
};

/** on_conflict condition type for table "rangers.locale" */
export type Rangers_Locale_On_Conflict = {
  constraint: Rangers_Locale_Constraint;
  update_columns?: Array<Rangers_Locale_Update_Column>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.locale". */
export type Rangers_Locale_Order_By = {
  locale?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.locale */
export type Rangers_Locale_Pk_Columns_Input = {
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.locale" */
export enum Rangers_Locale_Select_Column {
  /** column name */
  Locale = 'locale'
}

/** input type for updating data in table "rangers.locale" */
export type Rangers_Locale_Set_Input = {
  locale?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_locale" */
export type Rangers_Locale_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Locale_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Locale_Stream_Cursor_Value_Input = {
  locale?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "rangers.locale" */
export enum Rangers_Locale_Update_Column {
  /** column name */
  Locale = 'locale'
}

export type Rangers_Locale_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Locale_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Locale_Bool_Exp;
};

/** columns and relationships of "rangers.pack" */
export type Rangers_Pack = {
  __typename?: 'rangers_pack';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  position?: Maybe<Scalars['Int']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  translations: Array<Rangers_Pack_Text>;
  /** An aggregate relationship */
  translations_aggregate: Rangers_Pack_Text_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.pack" */
export type Rangers_PackTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


/** columns and relationships of "rangers.pack" */
export type Rangers_PackTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};

/** aggregated selection of "rangers.pack" */
export type Rangers_Pack_Aggregate = {
  __typename?: 'rangers_pack_aggregate';
  aggregate?: Maybe<Rangers_Pack_Aggregate_Fields>;
  nodes: Array<Rangers_Pack>;
};

/** aggregate fields of "rangers.pack" */
export type Rangers_Pack_Aggregate_Fields = {
  __typename?: 'rangers_pack_aggregate_fields';
  avg?: Maybe<Rangers_Pack_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Pack_Max_Fields>;
  min?: Maybe<Rangers_Pack_Min_Fields>;
  stddev?: Maybe<Rangers_Pack_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Pack_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Pack_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Pack_Sum_Fields>;
  var_pop?: Maybe<Rangers_Pack_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Pack_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Pack_Variance_Fields>;
};


/** aggregate fields of "rangers.pack" */
export type Rangers_Pack_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Pack_Avg_Fields = {
  __typename?: 'rangers_pack_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.pack". All fields are combined with a logical 'AND'. */
export type Rangers_Pack_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Pack_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Pack_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Pack_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  short_name?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Rangers_Pack_Text_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.pack" */
export enum Rangers_Pack_Constraint {
  /** unique or primary key constraint on columns "id" */
  PackPkey = 'pack_pkey'
}

/** input type for incrementing numeric columns in table "rangers.pack" */
export type Rangers_Pack_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.pack" */
export type Rangers_Pack_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Rangers_Pack_Text_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.pack_localized" */
export type Rangers_Pack_Localized = {
  __typename?: 'rangers_pack_localized';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_short_name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.pack_localized" */
export type Rangers_Pack_Localized_Aggregate = {
  __typename?: 'rangers_pack_localized_aggregate';
  aggregate?: Maybe<Rangers_Pack_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Pack_Localized>;
};

/** aggregate fields of "rangers.pack_localized" */
export type Rangers_Pack_Localized_Aggregate_Fields = {
  __typename?: 'rangers_pack_localized_aggregate_fields';
  avg?: Maybe<Rangers_Pack_Localized_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Pack_Localized_Max_Fields>;
  min?: Maybe<Rangers_Pack_Localized_Min_Fields>;
  stddev?: Maybe<Rangers_Pack_Localized_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Pack_Localized_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Pack_Localized_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Pack_Localized_Sum_Fields>;
  var_pop?: Maybe<Rangers_Pack_Localized_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Pack_Localized_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Pack_Localized_Variance_Fields>;
};


/** aggregate fields of "rangers.pack_localized" */
export type Rangers_Pack_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Pack_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Pack_Localized_Avg_Fields = {
  __typename?: 'rangers_pack_localized_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.pack_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Pack_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Pack_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Pack_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Pack_Localized_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_short_name?: InputMaybe<String_Comparison_Exp>;
  short_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Pack_Localized_Max_Fields = {
  __typename?: 'rangers_pack_localized_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_short_name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Pack_Localized_Min_Fields = {
  __typename?: 'rangers_pack_localized_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_short_name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.pack_localized". */
export type Rangers_Pack_Localized_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_short_name?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.pack_localized" */
export enum Rangers_Pack_Localized_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealShortName = 'real_short_name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Rangers_Pack_Localized_Stddev_Fields = {
  __typename?: 'rangers_pack_localized_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Pack_Localized_Stddev_Pop_Fields = {
  __typename?: 'rangers_pack_localized_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Pack_Localized_Stddev_Samp_Fields = {
  __typename?: 'rangers_pack_localized_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_pack_localized" */
export type Rangers_Pack_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Pack_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Pack_Localized_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_short_name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Pack_Localized_Sum_Fields = {
  __typename?: 'rangers_pack_localized_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** aggregate var_pop on columns */
export type Rangers_Pack_Localized_Var_Pop_Fields = {
  __typename?: 'rangers_pack_localized_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Pack_Localized_Var_Samp_Fields = {
  __typename?: 'rangers_pack_localized_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Pack_Localized_Variance_Fields = {
  __typename?: 'rangers_pack_localized_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type Rangers_Pack_Max_Fields = {
  __typename?: 'rangers_pack_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Pack_Min_Fields = {
  __typename?: 'rangers_pack_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.pack" */
export type Rangers_Pack_Mutation_Response = {
  __typename?: 'rangers_pack_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Pack>;
};

/** on_conflict condition type for table "rangers.pack" */
export type Rangers_Pack_On_Conflict = {
  constraint: Rangers_Pack_Constraint;
  update_columns?: Array<Rangers_Pack_Update_Column>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.pack". */
export type Rangers_Pack_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Rangers_Pack_Text_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.pack */
export type Rangers_Pack_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.pack" */
export enum Rangers_Pack_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.pack" */
export type Rangers_Pack_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Pack_Stddev_Fields = {
  __typename?: 'rangers_pack_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Pack_Stddev_Pop_Fields = {
  __typename?: 'rangers_pack_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Pack_Stddev_Samp_Fields = {
  __typename?: 'rangers_pack_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_pack" */
export type Rangers_Pack_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Pack_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Pack_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Pack_Sum_Fields = {
  __typename?: 'rangers_pack_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "rangers.pack_text" */
export type Rangers_Pack_Text = {
  __typename?: 'rangers_pack_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.pack_text" */
export type Rangers_Pack_Text_Aggregate = {
  __typename?: 'rangers_pack_text_aggregate';
  aggregate?: Maybe<Rangers_Pack_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Pack_Text>;
};

export type Rangers_Pack_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Pack_Text_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Pack_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.pack_text" */
export type Rangers_Pack_Text_Aggregate_Fields = {
  __typename?: 'rangers_pack_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Pack_Text_Max_Fields>;
  min?: Maybe<Rangers_Pack_Text_Min_Fields>;
};


/** aggregate fields of "rangers.pack_text" */
export type Rangers_Pack_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.pack_text" */
export type Rangers_Pack_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Pack_Text_Max_Order_By>;
  min?: InputMaybe<Rangers_Pack_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.pack_text" */
export type Rangers_Pack_Text_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Pack_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Pack_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "rangers.pack_text". All fields are combined with a logical 'AND'. */
export type Rangers_Pack_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Pack_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Pack_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  short_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.pack_text" */
export enum Rangers_Pack_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  PackTextPkey = 'pack_text_pkey'
}

/** input type for inserting data into table "rangers.pack_text" */
export type Rangers_Pack_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Pack_Text_Max_Fields = {
  __typename?: 'rangers_pack_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "rangers.pack_text" */
export type Rangers_Pack_Text_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Pack_Text_Min_Fields = {
  __typename?: 'rangers_pack_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "rangers.pack_text" */
export type Rangers_Pack_Text_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.pack_text" */
export type Rangers_Pack_Text_Mutation_Response = {
  __typename?: 'rangers_pack_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Pack_Text>;
};

/** on_conflict condition type for table "rangers.pack_text" */
export type Rangers_Pack_Text_On_Conflict = {
  constraint: Rangers_Pack_Text_Constraint;
  update_columns?: Array<Rangers_Pack_Text_Update_Column>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.pack_text". */
export type Rangers_Pack_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.pack_text */
export type Rangers_Pack_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.pack_text" */
export enum Rangers_Pack_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.pack_text" */
export type Rangers_Pack_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_pack_text" */
export type Rangers_Pack_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Pack_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Pack_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.pack_text" */
export enum Rangers_Pack_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Pack_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Pack_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Pack_Text_Bool_Exp;
};

/** update columns of table "rangers.pack" */
export enum Rangers_Pack_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Pack_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Pack_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Pack_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Pack_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Pack_Var_Pop_Fields = {
  __typename?: 'rangers_pack_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Pack_Var_Samp_Fields = {
  __typename?: 'rangers_pack_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Pack_Variance_Fields = {
  __typename?: 'rangers_pack_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

export type Rangers_Publish_Deck_Args = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

export type Rangers_Remove_Campaign_Args = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

export type Rangers_Remove_Campaign_Deck_Args = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  old_campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

export type Rangers_Search_All_Decks_Args = {
  _limit?: InputMaybe<Scalars['Int']['input']>;
  _offset?: InputMaybe<Scalars['Int']['input']>;
  _taboo_set_id?: InputMaybe<Scalars['_text']['input']>;
  awa_eq?: InputMaybe<Scalars['Int']['input']>;
  background?: InputMaybe<Scalars['_text']['input']>;
  fit_eq?: InputMaybe<Scalars['Int']['input']>;
  foc_eq?: InputMaybe<Scalars['Int']['input']>;
  role?: InputMaybe<Scalars['_text']['input']>;
  specialty?: InputMaybe<Scalars['_text']['input']>;
  spi_eq?: InputMaybe<Scalars['Int']['input']>;
  user_id_eq?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_Deck = {
  __typename?: 'rangers_search_deck';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "rangers.search_deck_liked_by_user" */
  liked_by_user?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  likes?: Maybe<Rangers_Deck_Like_Count>;
  meta?: Maybe<Scalars['jsonb']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  published?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  rank?: Maybe<Rangers_Deck_Rank>;
  side_slots?: Maybe<Scalars['jsonb']['output']>;
  slots?: Maybe<Scalars['jsonb']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  taboo_set_id?: Maybe<Scalars['String']['output']>;
  tags?: Maybe<Scalars['jsonb']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  upgrade?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_DeckMetaArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_DeckSide_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_DeckSlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_DeckTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_DeckUpgradeArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

export type Rangers_Search_Deck_Aggregate = {
  __typename?: 'rangers_search_deck_aggregate';
  aggregate?: Maybe<Rangers_Search_Deck_Aggregate_Fields>;
  nodes: Array<Rangers_Search_Deck>;
};

/** aggregate fields of "rangers.search_deck" */
export type Rangers_Search_Deck_Aggregate_Fields = {
  __typename?: 'rangers_search_deck_aggregate_fields';
  avg?: Maybe<Rangers_Search_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Search_Deck_Max_Fields>;
  min?: Maybe<Rangers_Search_Deck_Min_Fields>;
  stddev?: Maybe<Rangers_Search_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Search_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Search_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Search_Deck_Sum_Fields>;
  var_pop?: Maybe<Rangers_Search_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Search_Deck_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Search_Deck_Variance_Fields>;
};


/** aggregate fields of "rangers.search_deck" */
export type Rangers_Search_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Search_Deck_Append_Input = {
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Search_Deck_Avg_Fields = {
  __typename?: 'rangers_search_deck_avg_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.search_deck". All fields are combined with a logical 'AND'. */
export type Rangers_Search_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Search_Deck_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Search_Deck_Bool_Exp>>;
  awa?: InputMaybe<Int_Comparison_Exp>;
  base_deck_id?: InputMaybe<Int_Comparison_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  comment_count?: InputMaybe<Int_Comparison_Exp>;
  copy_count?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  fit?: InputMaybe<Int_Comparison_Exp>;
  foc?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  like_count?: InputMaybe<Int_Comparison_Exp>;
  liked_by_user?: InputMaybe<Boolean_Comparison_Exp>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
  meta?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  next_deck_id?: InputMaybe<Int_Comparison_Exp>;
  published?: InputMaybe<Boolean_Comparison_Exp>;
  rank?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
  side_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  slots?: InputMaybe<Jsonb_Comparison_Exp>;
  spi?: InputMaybe<Int_Comparison_Exp>;
  taboo_set_id?: InputMaybe<String_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  upgrade?: InputMaybe<Jsonb_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
  version?: InputMaybe<Int_Comparison_Exp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Rangers_Search_Deck_Delete_At_Path_Input = {
  meta?: InputMaybe<Array<Scalars['String']['input']>>;
  side_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  slots?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  upgrade?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Rangers_Search_Deck_Delete_Elem_Input = {
  meta?: InputMaybe<Scalars['Int']['input']>;
  side_slots?: InputMaybe<Scalars['Int']['input']>;
  slots?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['Int']['input']>;
  upgrade?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Rangers_Search_Deck_Delete_Key_Input = {
  meta?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['String']['input']>;
  slots?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
  upgrade?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "rangers.search_deck" */
export type Rangers_Search_Deck_Inc_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.search_deck" */
export type Rangers_Search_Deck_Insert_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Obj_Rel_Insert_Input>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  rank?: InputMaybe<Rangers_Deck_Rank_Obj_Rel_Insert_Input>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  taboo_set_id?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Rangers_Search_Deck_Max_Fields = {
  __typename?: 'rangers_search_deck_max_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  taboo_set_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Rangers_Search_Deck_Min_Fields = {
  __typename?: 'rangers_search_deck_min_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  taboo_set_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "rangers.search_deck" */
export type Rangers_Search_Deck_Mutation_Response = {
  __typename?: 'rangers_search_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Search_Deck>;
};

/** Ordering options when selecting data from "rangers.search_deck". */
export type Rangers_Search_Deck_Order_By = {
  awa?: InputMaybe<Order_By>;
  base_deck_id?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  comment_count?: InputMaybe<Order_By>;
  copy_count?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  fit?: InputMaybe<Order_By>;
  foc?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  like_count?: InputMaybe<Order_By>;
  liked_by_user?: InputMaybe<Order_By>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Order_By>;
  meta?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  published?: InputMaybe<Order_By>;
  rank?: InputMaybe<Rangers_Deck_Rank_Order_By>;
  side_slots?: InputMaybe<Order_By>;
  slots?: InputMaybe<Order_By>;
  spi?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  upgrade?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Search_Deck_Prepend_Input = {
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "rangers.search_deck" */
export enum Rangers_Search_Deck_Select_Column {
  /** column name */
  Awa = 'awa',
  /** column name */
  BaseDeckId = 'base_deck_id',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CommentCount = 'comment_count',
  /** column name */
  CopyCount = 'copy_count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Fit = 'fit',
  /** column name */
  Foc = 'foc',
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  Published = 'published',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Spi = 'spi',
  /** column name */
  TabooSetId = 'taboo_set_id',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Upgrade = 'upgrade',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "rangers.search_deck" */
export type Rangers_Search_Deck_Set_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  taboo_set_id?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Search_Deck_Stddev_Fields = {
  __typename?: 'rangers_search_deck_stddev_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Search_Deck_Stddev_Pop_Fields = {
  __typename?: 'rangers_search_deck_stddev_pop_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Search_Deck_Stddev_Samp_Fields = {
  __typename?: 'rangers_search_deck_stddev_samp_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_search_deck" */
export type Rangers_Search_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Search_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Search_Deck_Stream_Cursor_Value_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  taboo_set_id?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Search_Deck_Sum_Fields = {
  __typename?: 'rangers_search_deck_sum_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

export type Rangers_Search_Deck_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Rangers_Search_Deck_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Rangers_Search_Deck_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Rangers_Search_Deck_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Rangers_Search_Deck_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Search_Deck_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Rangers_Search_Deck_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Search_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Search_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Search_Deck_Var_Pop_Fields = {
  __typename?: 'rangers_search_deck_var_pop_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Search_Deck_Var_Samp_Fields = {
  __typename?: 'rangers_search_deck_var_samp_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Search_Deck_Variance_Fields = {
  __typename?: 'rangers_search_deck_variance_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.set" */
export type Rangers_Set = {
  __typename?: 'rangers_set';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  size?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  translations: Array<Rangers_Set_Text>;
  /** An aggregate relationship */
  translations_aggregate: Rangers_Set_Text_Aggregate;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.set" */
export type Rangers_SetTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


/** columns and relationships of "rangers.set" */
export type Rangers_SetTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};

/** aggregated selection of "rangers.set" */
export type Rangers_Set_Aggregate = {
  __typename?: 'rangers_set_aggregate';
  aggregate?: Maybe<Rangers_Set_Aggregate_Fields>;
  nodes: Array<Rangers_Set>;
};

/** aggregate fields of "rangers.set" */
export type Rangers_Set_Aggregate_Fields = {
  __typename?: 'rangers_set_aggregate_fields';
  avg?: Maybe<Rangers_Set_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Max_Fields>;
  min?: Maybe<Rangers_Set_Min_Fields>;
  stddev?: Maybe<Rangers_Set_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Set_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Set_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Set_Sum_Fields>;
  var_pop?: Maybe<Rangers_Set_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Set_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Set_Variance_Fields>;
};


/** aggregate fields of "rangers.set" */
export type Rangers_Set_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Set_Avg_Fields = {
  __typename?: 'rangers_set_avg_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.set". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  size?: InputMaybe<Int_Comparison_Exp>;
  translations?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Rangers_Set_Text_Aggregate_Bool_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

export type Rangers_Set_Campaign_Deck_Args = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  new_campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** unique or primary key constraints on table "rangers.set" */
export enum Rangers_Set_Constraint {
  /** unique or primary key constraint on columns "id" */
  SetPkey = 'set_pkey'
}

export type Rangers_Set_Handle_Args = {
  handle?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "rangers.set" */
export type Rangers_Set_Inc_Input = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.set" */
export type Rangers_Set_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<Rangers_Set_Text_Arr_Rel_Insert_Input>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.set_localized" */
export type Rangers_Set_Localized = {
  __typename?: 'rangers_set_localized';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.set_localized" */
export type Rangers_Set_Localized_Aggregate = {
  __typename?: 'rangers_set_localized_aggregate';
  aggregate?: Maybe<Rangers_Set_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Set_Localized>;
};

export type Rangers_Set_Localized_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Set_Localized_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Set_Localized_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.set_localized" */
export type Rangers_Set_Localized_Aggregate_Fields = {
  __typename?: 'rangers_set_localized_aggregate_fields';
  avg?: Maybe<Rangers_Set_Localized_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Localized_Max_Fields>;
  min?: Maybe<Rangers_Set_Localized_Min_Fields>;
  stddev?: Maybe<Rangers_Set_Localized_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Set_Localized_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Set_Localized_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Set_Localized_Sum_Fields>;
  var_pop?: Maybe<Rangers_Set_Localized_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Set_Localized_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Set_Localized_Variance_Fields>;
};


/** aggregate fields of "rangers.set_localized" */
export type Rangers_Set_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.set_localized" */
export type Rangers_Set_Localized_Aggregate_Order_By = {
  avg?: InputMaybe<Rangers_Set_Localized_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Set_Localized_Max_Order_By>;
  min?: InputMaybe<Rangers_Set_Localized_Min_Order_By>;
  stddev?: InputMaybe<Rangers_Set_Localized_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Rangers_Set_Localized_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Rangers_Set_Localized_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Rangers_Set_Localized_Sum_Order_By>;
  var_pop?: InputMaybe<Rangers_Set_Localized_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Rangers_Set_Localized_Var_Samp_Order_By>;
  variance?: InputMaybe<Rangers_Set_Localized_Variance_Order_By>;
};

/** aggregate avg on columns */
export type Rangers_Set_Localized_Avg_Fields = {
  __typename?: 'rangers_set_localized_avg_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Avg_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "rangers.set_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Localized_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  size?: InputMaybe<Int_Comparison_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  type_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Set_Localized_Max_Fields = {
  __typename?: 'rangers_set_localized_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  type_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Set_Localized_Min_Fields = {
  __typename?: 'rangers_set_localized_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  type_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** Ordering options when selecting data from "rangers.set_localized". */
export type Rangers_Set_Localized_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  type_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.set_localized" */
export enum Rangers_Set_Localized_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  RealName = 'real_name',
  /** column name */
  Size = 'size',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  TypeName = 'type_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Rangers_Set_Localized_Stddev_Fields = {
  __typename?: 'rangers_set_localized_stddev_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Stddev_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Set_Localized_Stddev_Pop_Fields = {
  __typename?: 'rangers_set_localized_stddev_pop_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Stddev_Pop_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Set_Localized_Stddev_Samp_Fields = {
  __typename?: 'rangers_set_localized_stddev_samp_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Stddev_Samp_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "rangers_set_localized" */
export type Rangers_Set_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Localized_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  type_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Set_Localized_Sum_Fields = {
  __typename?: 'rangers_set_localized_sum_fields';
  size?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Sum_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate var_pop on columns */
export type Rangers_Set_Localized_Var_Pop_Fields = {
  __typename?: 'rangers_set_localized_var_pop_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Var_Pop_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Rangers_Set_Localized_Var_Samp_Fields = {
  __typename?: 'rangers_set_localized_var_samp_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Var_Samp_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Rangers_Set_Localized_Variance_Fields = {
  __typename?: 'rangers_set_localized_variance_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Variance_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate max on columns */
export type Rangers_Set_Max_Fields = {
  __typename?: 'rangers_set_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Set_Min_Fields = {
  __typename?: 'rangers_set_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.set" */
export type Rangers_Set_Mutation_Response = {
  __typename?: 'rangers_set_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Set>;
};

/** on_conflict condition type for table "rangers.set" */
export type Rangers_Set_On_Conflict = {
  constraint: Rangers_Set_Constraint;
  update_columns?: Array<Rangers_Set_Update_Column>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.set". */
export type Rangers_Set_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Rangers_Set_Text_Aggregate_Order_By>;
  type_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.set */
export type Rangers_Set_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.set" */
export enum Rangers_Set_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Size = 'size',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.set" */
export type Rangers_Set_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Set_Stddev_Fields = {
  __typename?: 'rangers_set_stddev_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Set_Stddev_Pop_Fields = {
  __typename?: 'rangers_set_stddev_pop_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Set_Stddev_Samp_Fields = {
  __typename?: 'rangers_set_stddev_samp_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_set" */
export type Rangers_Set_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Set_Sum_Fields = {
  __typename?: 'rangers_set_sum_fields';
  size?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "rangers.set_text" */
export type Rangers_Set_Text = {
  __typename?: 'rangers_set_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.set_text" */
export type Rangers_Set_Text_Aggregate = {
  __typename?: 'rangers_set_text_aggregate';
  aggregate?: Maybe<Rangers_Set_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Set_Text>;
};

export type Rangers_Set_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Set_Text_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Set_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.set_text" */
export type Rangers_Set_Text_Aggregate_Fields = {
  __typename?: 'rangers_set_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Text_Max_Fields>;
  min?: Maybe<Rangers_Set_Text_Min_Fields>;
};


/** aggregate fields of "rangers.set_text" */
export type Rangers_Set_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.set_text" */
export type Rangers_Set_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Set_Text_Max_Order_By>;
  min?: InputMaybe<Rangers_Set_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.set_text" */
export type Rangers_Set_Text_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Set_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Set_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "rangers.set_text". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.set_text" */
export enum Rangers_Set_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  SetTextPkey = 'set_text_pkey'
}

/** input type for inserting data into table "rangers.set_text" */
export type Rangers_Set_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Set_Text_Max_Fields = {
  __typename?: 'rangers_set_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "rangers.set_text" */
export type Rangers_Set_Text_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Set_Text_Min_Fields = {
  __typename?: 'rangers_set_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "rangers.set_text" */
export type Rangers_Set_Text_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.set_text" */
export type Rangers_Set_Text_Mutation_Response = {
  __typename?: 'rangers_set_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Set_Text>;
};

/** on_conflict condition type for table "rangers.set_text" */
export type Rangers_Set_Text_On_Conflict = {
  constraint: Rangers_Set_Text_Constraint;
  update_columns?: Array<Rangers_Set_Text_Update_Column>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.set_text". */
export type Rangers_Set_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.set_text */
export type Rangers_Set_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.set_text" */
export enum Rangers_Set_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.set_text" */
export type Rangers_Set_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_set_text" */
export type Rangers_Set_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.set_text" */
export enum Rangers_Set_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Set_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Set_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Set_Text_Bool_Exp;
};

/** columns and relationships of "rangers.set_type" */
export type Rangers_Set_Type = {
  __typename?: 'rangers_set_type';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  translations: Array<Rangers_Set_Type_Text>;
  /** An aggregate relationship */
  translations_aggregate: Rangers_Set_Type_Text_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.set_type" */
export type Rangers_Set_TypeTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


/** columns and relationships of "rangers.set_type" */
export type Rangers_Set_TypeTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};

/** aggregated selection of "rangers.set_type" */
export type Rangers_Set_Type_Aggregate = {
  __typename?: 'rangers_set_type_aggregate';
  aggregate?: Maybe<Rangers_Set_Type_Aggregate_Fields>;
  nodes: Array<Rangers_Set_Type>;
};

/** aggregate fields of "rangers.set_type" */
export type Rangers_Set_Type_Aggregate_Fields = {
  __typename?: 'rangers_set_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Type_Max_Fields>;
  min?: Maybe<Rangers_Set_Type_Min_Fields>;
};


/** aggregate fields of "rangers.set_type" */
export type Rangers_Set_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.set_type". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Type_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Type_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Rangers_Set_Type_Text_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.set_type" */
export enum Rangers_Set_Type_Constraint {
  /** unique or primary key constraint on columns "id" */
  SetTypePkey = 'set_type_pkey'
}

/** input type for inserting data into table "rangers.set_type" */
export type Rangers_Set_Type_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Rangers_Set_Type_Text_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.set_type_localized" */
export type Rangers_Set_Type_Localized = {
  __typename?: 'rangers_set_type_localized';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  sets: Array<Rangers_Set_Localized>;
  /** An aggregate relationship */
  sets_aggregate: Rangers_Set_Localized_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.set_type_localized" */
export type Rangers_Set_Type_LocalizedSetsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


/** columns and relationships of "rangers.set_type_localized" */
export type Rangers_Set_Type_LocalizedSets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};

/** aggregated selection of "rangers.set_type_localized" */
export type Rangers_Set_Type_Localized_Aggregate = {
  __typename?: 'rangers_set_type_localized_aggregate';
  aggregate?: Maybe<Rangers_Set_Type_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Set_Type_Localized>;
};

/** aggregate fields of "rangers.set_type_localized" */
export type Rangers_Set_Type_Localized_Aggregate_Fields = {
  __typename?: 'rangers_set_type_localized_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Type_Localized_Max_Fields>;
  min?: Maybe<Rangers_Set_Type_Localized_Min_Fields>;
};


/** aggregate fields of "rangers.set_type_localized" */
export type Rangers_Set_Type_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Type_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.set_type_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Type_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Type_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Type_Localized_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  sets?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
  sets_aggregate?: InputMaybe<Rangers_Set_Localized_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Set_Type_Localized_Max_Fields = {
  __typename?: 'rangers_set_type_localized_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Set_Type_Localized_Min_Fields = {
  __typename?: 'rangers_set_type_localized_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.set_type_localized". */
export type Rangers_Set_Type_Localized_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  sets_aggregate?: InputMaybe<Rangers_Set_Localized_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.set_type_localized" */
export enum Rangers_Set_Type_Localized_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  RealName = 'real_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "rangers_set_type_localized" */
export type Rangers_Set_Type_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Type_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Type_Localized_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Set_Type_Max_Fields = {
  __typename?: 'rangers_set_type_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Set_Type_Min_Fields = {
  __typename?: 'rangers_set_type_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.set_type" */
export type Rangers_Set_Type_Mutation_Response = {
  __typename?: 'rangers_set_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Set_Type>;
};

/** on_conflict condition type for table "rangers.set_type" */
export type Rangers_Set_Type_On_Conflict = {
  constraint: Rangers_Set_Type_Constraint;
  update_columns?: Array<Rangers_Set_Type_Update_Column>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.set_type". */
export type Rangers_Set_Type_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Rangers_Set_Type_Text_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.set_type */
export type Rangers_Set_Type_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.set_type" */
export enum Rangers_Set_Type_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.set_type" */
export type Rangers_Set_Type_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_set_type" */
export type Rangers_Set_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Type_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.set_type_text" */
export type Rangers_Set_Type_Text = {
  __typename?: 'rangers_set_type_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Aggregate = {
  __typename?: 'rangers_set_type_text_aggregate';
  aggregate?: Maybe<Rangers_Set_Type_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Set_Type_Text>;
};

export type Rangers_Set_Type_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Set_Type_Text_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Set_Type_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Aggregate_Fields = {
  __typename?: 'rangers_set_type_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Type_Text_Max_Fields>;
  min?: Maybe<Rangers_Set_Type_Text_Min_Fields>;
};


/** aggregate fields of "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Set_Type_Text_Max_Order_By>;
  min?: InputMaybe<Rangers_Set_Type_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Set_Type_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Set_Type_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "rangers.set_type_text". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Type_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Type_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Type_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.set_type_text" */
export enum Rangers_Set_Type_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  SetTypeTextPkey = 'set_type_text_pkey'
}

/** input type for inserting data into table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Set_Type_Text_Max_Fields = {
  __typename?: 'rangers_set_type_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Set_Type_Text_Min_Fields = {
  __typename?: 'rangers_set_type_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Mutation_Response = {
  __typename?: 'rangers_set_type_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Set_Type_Text>;
};

/** on_conflict condition type for table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_On_Conflict = {
  constraint: Rangers_Set_Type_Text_Constraint;
  update_columns?: Array<Rangers_Set_Type_Text_Update_Column>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.set_type_text". */
export type Rangers_Set_Type_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.set_type_text */
export type Rangers_Set_Type_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.set_type_text" */
export enum Rangers_Set_Type_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_set_type_text" */
export type Rangers_Set_Type_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Type_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Type_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.set_type_text" */
export enum Rangers_Set_Type_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Set_Type_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Set_Type_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Set_Type_Text_Bool_Exp;
};

/** update columns of table "rangers.set_type" */
export enum Rangers_Set_Type_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Set_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Set_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Set_Type_Bool_Exp;
};

/** update columns of table "rangers.set" */
export enum Rangers_Set_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Size = 'size',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Set_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Set_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Set_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Set_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Set_Var_Pop_Fields = {
  __typename?: 'rangers_set_var_pop_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Set_Var_Samp_Fields = {
  __typename?: 'rangers_set_var_samp_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Set_Variance_Fields = {
  __typename?: 'rangers_set_variance_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.subset" */
export type Rangers_Subset = {
  __typename?: 'rangers_subset';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  pack_id: Scalars['String']['output'];
  set_id: Scalars['String']['output'];
  size: Scalars['Int']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.subset" */
export type Rangers_Subset_Aggregate = {
  __typename?: 'rangers_subset_aggregate';
  aggregate?: Maybe<Rangers_Subset_Aggregate_Fields>;
  nodes: Array<Rangers_Subset>;
};

/** aggregate fields of "rangers.subset" */
export type Rangers_Subset_Aggregate_Fields = {
  __typename?: 'rangers_subset_aggregate_fields';
  avg?: Maybe<Rangers_Subset_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Subset_Max_Fields>;
  min?: Maybe<Rangers_Subset_Min_Fields>;
  stddev?: Maybe<Rangers_Subset_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Subset_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Subset_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Subset_Sum_Fields>;
  var_pop?: Maybe<Rangers_Subset_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Subset_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Subset_Variance_Fields>;
};


/** aggregate fields of "rangers.subset" */
export type Rangers_Subset_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Subset_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Subset_Avg_Fields = {
  __typename?: 'rangers_subset_avg_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.subset". All fields are combined with a logical 'AND'. */
export type Rangers_Subset_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Subset_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Subset_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Subset_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  pack_id?: InputMaybe<String_Comparison_Exp>;
  set_id?: InputMaybe<String_Comparison_Exp>;
  size?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.subset" */
export enum Rangers_Subset_Constraint {
  /** unique or primary key constraint on columns "id" */
  SubsetPkey = 'subset_pkey'
}

/** input type for incrementing numeric columns in table "rangers.subset" */
export type Rangers_Subset_Inc_Input = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.subset" */
export type Rangers_Subset_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.subset_localized" */
export type Rangers_Subset_Localized = {
  __typename?: 'rangers_subset_localized';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  pack_short_name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_name?: Maybe<Scalars['String']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  set_type_id?: Maybe<Scalars['String']['output']>;
  set_type_name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.subset_localized" */
export type Rangers_Subset_Localized_Aggregate = {
  __typename?: 'rangers_subset_localized_aggregate';
  aggregate?: Maybe<Rangers_Subset_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Subset_Localized>;
};

/** aggregate fields of "rangers.subset_localized" */
export type Rangers_Subset_Localized_Aggregate_Fields = {
  __typename?: 'rangers_subset_localized_aggregate_fields';
  avg?: Maybe<Rangers_Subset_Localized_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Subset_Localized_Max_Fields>;
  min?: Maybe<Rangers_Subset_Localized_Min_Fields>;
  stddev?: Maybe<Rangers_Subset_Localized_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Subset_Localized_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Subset_Localized_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Subset_Localized_Sum_Fields>;
  var_pop?: Maybe<Rangers_Subset_Localized_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Subset_Localized_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Subset_Localized_Variance_Fields>;
};


/** aggregate fields of "rangers.subset_localized" */
export type Rangers_Subset_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Subset_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Subset_Localized_Avg_Fields = {
  __typename?: 'rangers_subset_localized_avg_fields';
  pack_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  size?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.subset_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Subset_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Subset_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Subset_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Subset_Localized_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  pack_id?: InputMaybe<String_Comparison_Exp>;
  pack_name?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  pack_short_name?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  set_id?: InputMaybe<String_Comparison_Exp>;
  set_name?: InputMaybe<String_Comparison_Exp>;
  set_size?: InputMaybe<Int_Comparison_Exp>;
  set_type_id?: InputMaybe<String_Comparison_Exp>;
  set_type_name?: InputMaybe<String_Comparison_Exp>;
  size?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Subset_Localized_Max_Fields = {
  __typename?: 'rangers_subset_localized_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  pack_short_name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_name?: Maybe<Scalars['String']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  set_type_id?: Maybe<Scalars['String']['output']>;
  set_type_name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Subset_Localized_Min_Fields = {
  __typename?: 'rangers_subset_localized_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  pack_short_name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_name?: Maybe<Scalars['String']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  set_type_id?: Maybe<Scalars['String']['output']>;
  set_type_name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.subset_localized". */
export type Rangers_Subset_Localized_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  pack_id?: InputMaybe<Order_By>;
  pack_name?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  pack_short_name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  set_id?: InputMaybe<Order_By>;
  set_name?: InputMaybe<Order_By>;
  set_size?: InputMaybe<Order_By>;
  set_type_id?: InputMaybe<Order_By>;
  set_type_name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.subset_localized" */
export enum Rangers_Subset_Localized_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  PackName = 'pack_name',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  PackShortName = 'pack_short_name',
  /** column name */
  RealName = 'real_name',
  /** column name */
  SetId = 'set_id',
  /** column name */
  SetName = 'set_name',
  /** column name */
  SetSize = 'set_size',
  /** column name */
  SetTypeId = 'set_type_id',
  /** column name */
  SetTypeName = 'set_type_name',
  /** column name */
  Size = 'size',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Rangers_Subset_Localized_Stddev_Fields = {
  __typename?: 'rangers_subset_localized_stddev_fields';
  pack_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Subset_Localized_Stddev_Pop_Fields = {
  __typename?: 'rangers_subset_localized_stddev_pop_fields';
  pack_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Subset_Localized_Stddev_Samp_Fields = {
  __typename?: 'rangers_subset_localized_stddev_samp_fields';
  pack_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  size?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_subset_localized" */
export type Rangers_Subset_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Subset_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Subset_Localized_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  pack_name?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  pack_short_name?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  set_name?: InputMaybe<Scalars['String']['input']>;
  set_size?: InputMaybe<Scalars['Int']['input']>;
  set_type_id?: InputMaybe<Scalars['String']['input']>;
  set_type_name?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Subset_Localized_Sum_Fields = {
  __typename?: 'rangers_subset_localized_sum_fields';
  pack_position?: Maybe<Scalars['Int']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
};

/** aggregate var_pop on columns */
export type Rangers_Subset_Localized_Var_Pop_Fields = {
  __typename?: 'rangers_subset_localized_var_pop_fields';
  pack_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Subset_Localized_Var_Samp_Fields = {
  __typename?: 'rangers_subset_localized_var_samp_fields';
  pack_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Subset_Localized_Variance_Fields = {
  __typename?: 'rangers_subset_localized_variance_fields';
  pack_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type Rangers_Subset_Max_Fields = {
  __typename?: 'rangers_subset_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Subset_Min_Fields = {
  __typename?: 'rangers_subset_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.subset" */
export type Rangers_Subset_Mutation_Response = {
  __typename?: 'rangers_subset_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Subset>;
};

/** on_conflict condition type for table "rangers.subset" */
export type Rangers_Subset_On_Conflict = {
  constraint: Rangers_Subset_Constraint;
  update_columns?: Array<Rangers_Subset_Update_Column>;
  where?: InputMaybe<Rangers_Subset_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.subset". */
export type Rangers_Subset_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  pack_id?: InputMaybe<Order_By>;
  set_id?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.subset */
export type Rangers_Subset_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.subset" */
export enum Rangers_Subset_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  SetId = 'set_id',
  /** column name */
  Size = 'size',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.subset" */
export type Rangers_Subset_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Subset_Stddev_Fields = {
  __typename?: 'rangers_subset_stddev_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Subset_Stddev_Pop_Fields = {
  __typename?: 'rangers_subset_stddev_pop_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Subset_Stddev_Samp_Fields = {
  __typename?: 'rangers_subset_stddev_samp_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_subset" */
export type Rangers_Subset_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Subset_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Subset_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Subset_Sum_Fields = {
  __typename?: 'rangers_subset_sum_fields';
  size?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "rangers.subset_text" */
export type Rangers_Subset_Text = {
  __typename?: 'rangers_subset_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.subset_text" */
export type Rangers_Subset_Text_Aggregate = {
  __typename?: 'rangers_subset_text_aggregate';
  aggregate?: Maybe<Rangers_Subset_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Subset_Text>;
};

/** aggregate fields of "rangers.subset_text" */
export type Rangers_Subset_Text_Aggregate_Fields = {
  __typename?: 'rangers_subset_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Subset_Text_Max_Fields>;
  min?: Maybe<Rangers_Subset_Text_Min_Fields>;
};


/** aggregate fields of "rangers.subset_text" */
export type Rangers_Subset_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Subset_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.subset_text". All fields are combined with a logical 'AND'. */
export type Rangers_Subset_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Subset_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Subset_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Subset_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.subset_text" */
export enum Rangers_Subset_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  SubsetTextPkey = 'subset_text_pkey'
}

/** input type for inserting data into table "rangers.subset_text" */
export type Rangers_Subset_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Subset_Text_Max_Fields = {
  __typename?: 'rangers_subset_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Subset_Text_Min_Fields = {
  __typename?: 'rangers_subset_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.subset_text" */
export type Rangers_Subset_Text_Mutation_Response = {
  __typename?: 'rangers_subset_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Subset_Text>;
};

/** on_conflict condition type for table "rangers.subset_text" */
export type Rangers_Subset_Text_On_Conflict = {
  constraint: Rangers_Subset_Text_Constraint;
  update_columns?: Array<Rangers_Subset_Text_Update_Column>;
  where?: InputMaybe<Rangers_Subset_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.subset_text". */
export type Rangers_Subset_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.subset_text */
export type Rangers_Subset_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.subset_text" */
export enum Rangers_Subset_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.subset_text" */
export type Rangers_Subset_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_subset_text" */
export type Rangers_Subset_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Subset_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Subset_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.subset_text" */
export enum Rangers_Subset_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Subset_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Subset_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Subset_Text_Bool_Exp;
};

/** update columns of table "rangers.subset" */
export enum Rangers_Subset_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  SetId = 'set_id',
  /** column name */
  Size = 'size',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Subset_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Subset_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Subset_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Subset_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Subset_Var_Pop_Fields = {
  __typename?: 'rangers_subset_var_pop_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Subset_Var_Samp_Fields = {
  __typename?: 'rangers_subset_var_samp_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Subset_Variance_Fields = {
  __typename?: 'rangers_subset_variance_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.taboo_set" */
export type Rangers_Taboo_Set = {
  __typename?: 'rangers_taboo_set';
  date?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['String']['output'];
  is_current: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.taboo_set" */
export type Rangers_Taboo_Set_Aggregate = {
  __typename?: 'rangers_taboo_set_aggregate';
  aggregate?: Maybe<Rangers_Taboo_Set_Aggregate_Fields>;
  nodes: Array<Rangers_Taboo_Set>;
};

/** aggregate fields of "rangers.taboo_set" */
export type Rangers_Taboo_Set_Aggregate_Fields = {
  __typename?: 'rangers_taboo_set_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Taboo_Set_Max_Fields>;
  min?: Maybe<Rangers_Taboo_Set_Min_Fields>;
};


/** aggregate fields of "rangers.taboo_set" */
export type Rangers_Taboo_Set_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Taboo_Set_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.taboo_set". All fields are combined with a logical 'AND'. */
export type Rangers_Taboo_Set_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Taboo_Set_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Taboo_Set_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Taboo_Set_Bool_Exp>>;
  date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  is_current?: InputMaybe<Boolean_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.taboo_set" */
export enum Rangers_Taboo_Set_Constraint {
  /** unique or primary key constraint on columns "id" */
  TabooSetPkey = 'taboo_set_pkey'
}

/** input type for inserting data into table "rangers.taboo_set" */
export type Rangers_Taboo_Set_Insert_Input = {
  date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  is_current?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.taboo_set_localized" */
export type Rangers_Taboo_Set_Localized = {
  __typename?: 'rangers_taboo_set_localized';
  date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  is_current?: Maybe<Scalars['Boolean']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.taboo_set_localized" */
export type Rangers_Taboo_Set_Localized_Aggregate = {
  __typename?: 'rangers_taboo_set_localized_aggregate';
  aggregate?: Maybe<Rangers_Taboo_Set_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Taboo_Set_Localized>;
};

/** aggregate fields of "rangers.taboo_set_localized" */
export type Rangers_Taboo_Set_Localized_Aggregate_Fields = {
  __typename?: 'rangers_taboo_set_localized_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Taboo_Set_Localized_Max_Fields>;
  min?: Maybe<Rangers_Taboo_Set_Localized_Min_Fields>;
};


/** aggregate fields of "rangers.taboo_set_localized" */
export type Rangers_Taboo_Set_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.taboo_set_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Taboo_Set_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Taboo_Set_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Bool_Exp>>;
  date?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  is_current?: InputMaybe<Boolean_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Taboo_Set_Localized_Max_Fields = {
  __typename?: 'rangers_taboo_set_localized_max_fields';
  date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Taboo_Set_Localized_Min_Fields = {
  __typename?: 'rangers_taboo_set_localized_min_fields';
  date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.taboo_set_localized". */
export type Rangers_Taboo_Set_Localized_Order_By = {
  date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  is_current?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.taboo_set_localized" */
export enum Rangers_Taboo_Set_Localized_Select_Column {
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  IsCurrent = 'is_current',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  RealName = 'real_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "rangers_taboo_set_localized" */
export type Rangers_Taboo_Set_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Taboo_Set_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Taboo_Set_Localized_Stream_Cursor_Value_Input = {
  date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  is_current?: InputMaybe<Scalars['Boolean']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Taboo_Set_Max_Fields = {
  __typename?: 'rangers_taboo_set_max_fields';
  date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Taboo_Set_Min_Fields = {
  __typename?: 'rangers_taboo_set_min_fields';
  date?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.taboo_set" */
export type Rangers_Taboo_Set_Mutation_Response = {
  __typename?: 'rangers_taboo_set_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Taboo_Set>;
};

/** on_conflict condition type for table "rangers.taboo_set" */
export type Rangers_Taboo_Set_On_Conflict = {
  constraint: Rangers_Taboo_Set_Constraint;
  update_columns?: Array<Rangers_Taboo_Set_Update_Column>;
  where?: InputMaybe<Rangers_Taboo_Set_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.taboo_set". */
export type Rangers_Taboo_Set_Order_By = {
  date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  is_current?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.taboo_set */
export type Rangers_Taboo_Set_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.taboo_set" */
export enum Rangers_Taboo_Set_Select_Column {
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  IsCurrent = 'is_current',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.taboo_set" */
export type Rangers_Taboo_Set_Set_Input = {
  date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  is_current?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_taboo_set" */
export type Rangers_Taboo_Set_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Taboo_Set_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Taboo_Set_Stream_Cursor_Value_Input = {
  date?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  is_current?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.taboo_set_text" */
export type Rangers_Taboo_Set_Text = {
  __typename?: 'rangers_taboo_set_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "rangers.taboo_set_text" */
export type Rangers_Taboo_Set_Text_Aggregate = {
  __typename?: 'rangers_taboo_set_text_aggregate';
  aggregate?: Maybe<Rangers_Taboo_Set_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Taboo_Set_Text>;
};

/** aggregate fields of "rangers.taboo_set_text" */
export type Rangers_Taboo_Set_Text_Aggregate_Fields = {
  __typename?: 'rangers_taboo_set_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Taboo_Set_Text_Max_Fields>;
  min?: Maybe<Rangers_Taboo_Set_Text_Min_Fields>;
};


/** aggregate fields of "rangers.taboo_set_text" */
export type Rangers_Taboo_Set_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Taboo_Set_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.taboo_set_text". All fields are combined with a logical 'AND'. */
export type Rangers_Taboo_Set_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Taboo_Set_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Taboo_Set_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Taboo_Set_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.taboo_set_text" */
export enum Rangers_Taboo_Set_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  TabooSetTextPkey = 'taboo_set_text_pkey'
}

/** input type for inserting data into table "rangers.taboo_set_text" */
export type Rangers_Taboo_Set_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Taboo_Set_Text_Max_Fields = {
  __typename?: 'rangers_taboo_set_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Taboo_Set_Text_Min_Fields = {
  __typename?: 'rangers_taboo_set_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.taboo_set_text" */
export type Rangers_Taboo_Set_Text_Mutation_Response = {
  __typename?: 'rangers_taboo_set_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Taboo_Set_Text>;
};

/** on_conflict condition type for table "rangers.taboo_set_text" */
export type Rangers_Taboo_Set_Text_On_Conflict = {
  constraint: Rangers_Taboo_Set_Text_Constraint;
  update_columns?: Array<Rangers_Taboo_Set_Text_Update_Column>;
  where?: InputMaybe<Rangers_Taboo_Set_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.taboo_set_text". */
export type Rangers_Taboo_Set_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.taboo_set_text */
export type Rangers_Taboo_Set_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.taboo_set_text" */
export enum Rangers_Taboo_Set_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.taboo_set_text" */
export type Rangers_Taboo_Set_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_taboo_set_text" */
export type Rangers_Taboo_Set_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Taboo_Set_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Taboo_Set_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.taboo_set_text" */
export enum Rangers_Taboo_Set_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Taboo_Set_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Taboo_Set_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Taboo_Set_Text_Bool_Exp;
};

/** update columns of table "rangers.taboo_set" */
export enum Rangers_Taboo_Set_Update_Column {
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  IsCurrent = 'is_current',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Taboo_Set_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Taboo_Set_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Taboo_Set_Bool_Exp;
};

/** columns and relationships of "rangers.token" */
export type Rangers_Token = {
  __typename?: 'rangers_token';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  plurals?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.token" */
export type Rangers_Token_Aggregate = {
  __typename?: 'rangers_token_aggregate';
  aggregate?: Maybe<Rangers_Token_Aggregate_Fields>;
  nodes: Array<Rangers_Token>;
};

/** aggregate fields of "rangers.token" */
export type Rangers_Token_Aggregate_Fields = {
  __typename?: 'rangers_token_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Token_Max_Fields>;
  min?: Maybe<Rangers_Token_Min_Fields>;
};


/** aggregate fields of "rangers.token" */
export type Rangers_Token_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Token_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.token". All fields are combined with a logical 'AND'. */
export type Rangers_Token_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Token_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Token_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Token_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  plurals?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.token" */
export enum Rangers_Token_Constraint {
  /** unique or primary key constraint on columns "id" */
  TokenPkey = 'token_pkey'
}

/** input type for inserting data into table "rangers.token" */
export type Rangers_Token_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Token_Max_Fields = {
  __typename?: 'rangers_token_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  plurals?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Token_Min_Fields = {
  __typename?: 'rangers_token_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  plurals?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.token" */
export type Rangers_Token_Mutation_Response = {
  __typename?: 'rangers_token_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Token>;
};

/** on_conflict condition type for table "rangers.token" */
export type Rangers_Token_On_Conflict = {
  constraint: Rangers_Token_Constraint;
  update_columns?: Array<Rangers_Token_Update_Column>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.token". */
export type Rangers_Token_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  plurals?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.token */
export type Rangers_Token_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.token" */
export enum Rangers_Token_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Plurals = 'plurals',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.token" */
export type Rangers_Token_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_token" */
export type Rangers_Token_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Token_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Token_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.token_text" */
export type Rangers_Token_Text = {
  __typename?: 'rangers_token_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  plurals: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.token_text" */
export type Rangers_Token_Text_Aggregate = {
  __typename?: 'rangers_token_text_aggregate';
  aggregate?: Maybe<Rangers_Token_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Token_Text>;
};

/** aggregate fields of "rangers.token_text" */
export type Rangers_Token_Text_Aggregate_Fields = {
  __typename?: 'rangers_token_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Token_Text_Max_Fields>;
  min?: Maybe<Rangers_Token_Text_Min_Fields>;
};


/** aggregate fields of "rangers.token_text" */
export type Rangers_Token_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Token_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.token_text". All fields are combined with a logical 'AND'. */
export type Rangers_Token_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Token_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Token_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  plurals?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.token_text" */
export enum Rangers_Token_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  TokenTextPkey = 'token_text_pkey'
}

/** input type for inserting data into table "rangers.token_text" */
export type Rangers_Token_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Token_Text_Max_Fields = {
  __typename?: 'rangers_token_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  plurals?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Token_Text_Min_Fields = {
  __typename?: 'rangers_token_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  plurals?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.token_text" */
export type Rangers_Token_Text_Mutation_Response = {
  __typename?: 'rangers_token_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Token_Text>;
};

/** on_conflict condition type for table "rangers.token_text" */
export type Rangers_Token_Text_On_Conflict = {
  constraint: Rangers_Token_Text_Constraint;
  update_columns?: Array<Rangers_Token_Text_Update_Column>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.token_text". */
export type Rangers_Token_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  plurals?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.token_text */
export type Rangers_Token_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.token_text" */
export enum Rangers_Token_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Plurals = 'plurals',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.token_text" */
export type Rangers_Token_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_token_text" */
export type Rangers_Token_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Token_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Token_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.token_text" */
export enum Rangers_Token_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Plurals = 'plurals',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Token_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Token_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Token_Text_Bool_Exp;
};

/** update columns of table "rangers.token" */
export enum Rangers_Token_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Plurals = 'plurals',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Token_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Token_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Token_Bool_Exp;
};

export type Rangers_Transfer_Campaign_Args = {
  current_location?: InputMaybe<Scalars['String']['input']>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  existing_campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** columns and relationships of "rangers.type" */
export type Rangers_Type = {
  __typename?: 'rangers_type';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.type" */
export type Rangers_Type_Aggregate = {
  __typename?: 'rangers_type_aggregate';
  aggregate?: Maybe<Rangers_Type_Aggregate_Fields>;
  nodes: Array<Rangers_Type>;
};

/** aggregate fields of "rangers.type" */
export type Rangers_Type_Aggregate_Fields = {
  __typename?: 'rangers_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Type_Max_Fields>;
  min?: Maybe<Rangers_Type_Min_Fields>;
};


/** aggregate fields of "rangers.type" */
export type Rangers_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.type". All fields are combined with a logical 'AND'. */
export type Rangers_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Type_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Type_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.type" */
export enum Rangers_Type_Constraint {
  /** unique or primary key constraint on columns "id" */
  TypePkey = 'type_pkey'
}

/** input type for inserting data into table "rangers.type" */
export type Rangers_Type_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.type_localized" */
export type Rangers_Type_Localized = {
  __typename?: 'rangers_type_localized';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.type_localized" */
export type Rangers_Type_Localized_Aggregate = {
  __typename?: 'rangers_type_localized_aggregate';
  aggregate?: Maybe<Rangers_Type_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Type_Localized>;
};

/** aggregate fields of "rangers.type_localized" */
export type Rangers_Type_Localized_Aggregate_Fields = {
  __typename?: 'rangers_type_localized_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Type_Localized_Max_Fields>;
  min?: Maybe<Rangers_Type_Localized_Min_Fields>;
};


/** aggregate fields of "rangers.type_localized" */
export type Rangers_Type_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Type_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.type_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Type_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Type_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Type_Localized_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Type_Localized_Max_Fields = {
  __typename?: 'rangers_type_localized_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Type_Localized_Min_Fields = {
  __typename?: 'rangers_type_localized_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.type_localized". */
export type Rangers_Type_Localized_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.type_localized" */
export enum Rangers_Type_Localized_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  RealName = 'real_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "rangers_type_localized" */
export type Rangers_Type_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Type_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Type_Localized_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Type_Max_Fields = {
  __typename?: 'rangers_type_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Type_Min_Fields = {
  __typename?: 'rangers_type_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.type" */
export type Rangers_Type_Mutation_Response = {
  __typename?: 'rangers_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Type>;
};

/** on_conflict condition type for table "rangers.type" */
export type Rangers_Type_On_Conflict = {
  constraint: Rangers_Type_Constraint;
  update_columns?: Array<Rangers_Type_Update_Column>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.type". */
export type Rangers_Type_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.type */
export type Rangers_Type_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.type" */
export enum Rangers_Type_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.type" */
export type Rangers_Type_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_type" */
export type Rangers_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Type_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.type_text" */
export type Rangers_Type_Text = {
  __typename?: 'rangers_type_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.type_text" */
export type Rangers_Type_Text_Aggregate = {
  __typename?: 'rangers_type_text_aggregate';
  aggregate?: Maybe<Rangers_Type_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Type_Text>;
};

/** aggregate fields of "rangers.type_text" */
export type Rangers_Type_Text_Aggregate_Fields = {
  __typename?: 'rangers_type_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Type_Text_Max_Fields>;
  min?: Maybe<Rangers_Type_Text_Min_Fields>;
};


/** aggregate fields of "rangers.type_text" */
export type Rangers_Type_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Type_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.type_text". All fields are combined with a logical 'AND'. */
export type Rangers_Type_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Type_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Type_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.type_text" */
export enum Rangers_Type_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  TypeTextPkey = 'type_text_pkey'
}

/** input type for inserting data into table "rangers.type_text" */
export type Rangers_Type_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Type_Text_Max_Fields = {
  __typename?: 'rangers_type_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Type_Text_Min_Fields = {
  __typename?: 'rangers_type_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.type_text" */
export type Rangers_Type_Text_Mutation_Response = {
  __typename?: 'rangers_type_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Type_Text>;
};

/** on_conflict condition type for table "rangers.type_text" */
export type Rangers_Type_Text_On_Conflict = {
  constraint: Rangers_Type_Text_Constraint;
  update_columns?: Array<Rangers_Type_Text_Update_Column>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.type_text". */
export type Rangers_Type_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.type_text */
export type Rangers_Type_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.type_text" */
export enum Rangers_Type_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.type_text" */
export type Rangers_Type_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_type_text" */
export type Rangers_Type_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Type_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Type_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.type_text" */
export enum Rangers_Type_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Type_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Type_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Type_Text_Bool_Exp;
};

/** update columns of table "rangers.type" */
export enum Rangers_Type_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Type_Bool_Exp;
};

export type Rangers_Update_Friend_Request_Args = {
  action?: InputMaybe<Scalars['String']['input']>;
  target_user_id?: InputMaybe<Scalars['String']['input']>;
};

export type Rangers_Upgrade_Deck_Args = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  upgrade_data?: InputMaybe<Scalars['json']['input']>;
};

/** columns and relationships of "rangers.user_campaign" */
export type Rangers_User_Campaign = {
  __typename?: 'rangers_user_campaign';
  /** An object relationship */
  campaign?: Maybe<Rangers_Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rangers.user_campaign" */
export type Rangers_User_Campaign_Aggregate = {
  __typename?: 'rangers_user_campaign_aggregate';
  aggregate?: Maybe<Rangers_User_Campaign_Aggregate_Fields>;
  nodes: Array<Rangers_User_Campaign>;
};

export type Rangers_User_Campaign_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_User_Campaign_Aggregate_Bool_Exp_Count>;
};

export type Rangers_User_Campaign_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.user_campaign" */
export type Rangers_User_Campaign_Aggregate_Fields = {
  __typename?: 'rangers_user_campaign_aggregate_fields';
  avg?: Maybe<Rangers_User_Campaign_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Campaign_Max_Fields>;
  min?: Maybe<Rangers_User_Campaign_Min_Fields>;
  stddev?: Maybe<Rangers_User_Campaign_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_User_Campaign_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_User_Campaign_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_User_Campaign_Sum_Fields>;
  var_pop?: Maybe<Rangers_User_Campaign_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_User_Campaign_Var_Samp_Fields>;
  variance?: Maybe<Rangers_User_Campaign_Variance_Fields>;
};


/** aggregate fields of "rangers.user_campaign" */
export type Rangers_User_Campaign_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Aggregate_Order_By = {
  avg?: InputMaybe<Rangers_User_Campaign_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_User_Campaign_Max_Order_By>;
  min?: InputMaybe<Rangers_User_Campaign_Min_Order_By>;
  stddev?: InputMaybe<Rangers_User_Campaign_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Rangers_User_Campaign_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Rangers_User_Campaign_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Rangers_User_Campaign_Sum_Order_By>;
  var_pop?: InputMaybe<Rangers_User_Campaign_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Rangers_User_Campaign_Var_Samp_Order_By>;
  variance?: InputMaybe<Rangers_User_Campaign_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.user_campaign" */
export type Rangers_User_Campaign_Arr_Rel_Insert_Input = {
  data: Array<Rangers_User_Campaign_Insert_Input>;
};

/** aggregate avg on columns */
export type Rangers_User_Campaign_Avg_Fields = {
  __typename?: 'rangers_user_campaign_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "rangers.user_campaign". All fields are combined with a logical 'AND'. */
export type Rangers_User_Campaign_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Campaign_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Campaign_Bool_Exp>>;
  campaign?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "rangers.user_campaign" */
export type Rangers_User_Campaign_Insert_Input = {
  campaign?: InputMaybe<Rangers_Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Campaign_Max_Fields = {
  __typename?: 'rangers_user_campaign_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_User_Campaign_Min_Fields = {
  __typename?: 'rangers_user_campaign_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Ordering options when selecting data from "rangers.user_campaign". */
export type Rangers_User_Campaign_Order_By = {
  campaign?: InputMaybe<Rangers_Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.user_campaign" */
export enum Rangers_User_Campaign_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** aggregate stddev on columns */
export type Rangers_User_Campaign_Stddev_Fields = {
  __typename?: 'rangers_user_campaign_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Rangers_User_Campaign_Stddev_Pop_Fields = {
  __typename?: 'rangers_user_campaign_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Rangers_User_Campaign_Stddev_Samp_Fields = {
  __typename?: 'rangers_user_campaign_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "rangers_user_campaign" */
export type Rangers_User_Campaign_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Campaign_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Campaign_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_User_Campaign_Sum_Fields = {
  __typename?: 'rangers_user_campaign_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate var_pop on columns */
export type Rangers_User_Campaign_Var_Pop_Fields = {
  __typename?: 'rangers_user_campaign_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Rangers_User_Campaign_Var_Samp_Fields = {
  __typename?: 'rangers_user_campaign_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Rangers_User_Campaign_Variance_Fields = {
  __typename?: 'rangers_user_campaign_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "rangers.user_friends" */
export type Rangers_User_Friends = {
  __typename?: 'rangers_user_friends';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rangers.user_friends" */
export type Rangers_User_Friends_Aggregate = {
  __typename?: 'rangers_user_friends_aggregate';
  aggregate?: Maybe<Rangers_User_Friends_Aggregate_Fields>;
  nodes: Array<Rangers_User_Friends>;
};

export type Rangers_User_Friends_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_User_Friends_Aggregate_Bool_Exp_Count>;
};

export type Rangers_User_Friends_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.user_friends" */
export type Rangers_User_Friends_Aggregate_Fields = {
  __typename?: 'rangers_user_friends_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Friends_Max_Fields>;
  min?: Maybe<Rangers_User_Friends_Min_Fields>;
};


/** aggregate fields of "rangers.user_friends" */
export type Rangers_User_Friends_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.user_friends" */
export type Rangers_User_Friends_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_User_Friends_Max_Order_By>;
  min?: InputMaybe<Rangers_User_Friends_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.user_friends" */
export type Rangers_User_Friends_Arr_Rel_Insert_Input = {
  data: Array<Rangers_User_Friends_Insert_Input>;
};

/** Boolean expression to filter rows from the table "rangers.user_friends". All fields are combined with a logical 'AND'. */
export type Rangers_User_Friends_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Friends_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Friends_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "rangers.user_friends" */
export type Rangers_User_Friends_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Friends_Max_Fields = {
  __typename?: 'rangers_user_friends_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.user_friends" */
export type Rangers_User_Friends_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_User_Friends_Min_Fields = {
  __typename?: 'rangers_user_friends_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.user_friends" */
export type Rangers_User_Friends_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.user_friends" */
export type Rangers_User_Friends_Mutation_Response = {
  __typename?: 'rangers_user_friends_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_User_Friends>;
};

/** Ordering options when selecting data from "rangers.user_friends". */
export type Rangers_User_Friends_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.user_friends" */
export enum Rangers_User_Friends_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "rangers.user_friends" */
export type Rangers_User_Friends_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_user_friends" */
export type Rangers_User_Friends_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Friends_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Friends_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type Rangers_User_Friends_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_User_Friends_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_User_Friends_Bool_Exp;
};

/** columns and relationships of "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests = {
  __typename?: 'rangers_user_received_friend_requests';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Aggregate = {
  __typename?: 'rangers_user_received_friend_requests_aggregate';
  aggregate?: Maybe<Rangers_User_Received_Friend_Requests_Aggregate_Fields>;
  nodes: Array<Rangers_User_Received_Friend_Requests>;
};

export type Rangers_User_Received_Friend_Requests_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_User_Received_Friend_Requests_Aggregate_Bool_Exp_Count>;
};

export type Rangers_User_Received_Friend_Requests_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Aggregate_Fields = {
  __typename?: 'rangers_user_received_friend_requests_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Received_Friend_Requests_Max_Fields>;
  min?: Maybe<Rangers_User_Received_Friend_Requests_Min_Fields>;
};


/** aggregate fields of "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_User_Received_Friend_Requests_Max_Order_By>;
  min?: InputMaybe<Rangers_User_Received_Friend_Requests_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Arr_Rel_Insert_Input = {
  data: Array<Rangers_User_Received_Friend_Requests_Insert_Input>;
};

/** Boolean expression to filter rows from the table "rangers.user_received_friend_requests". All fields are combined with a logical 'AND'. */
export type Rangers_User_Received_Friend_Requests_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Received_Friend_Requests_Max_Fields = {
  __typename?: 'rangers_user_received_friend_requests_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_User_Received_Friend_Requests_Min_Fields = {
  __typename?: 'rangers_user_received_friend_requests_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Mutation_Response = {
  __typename?: 'rangers_user_received_friend_requests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_User_Received_Friend_Requests>;
};

/** Ordering options when selecting data from "rangers.user_received_friend_requests". */
export type Rangers_User_Received_Friend_Requests_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.user_received_friend_requests" */
export enum Rangers_User_Received_Friend_Requests_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Received_Friend_Requests_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Received_Friend_Requests_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type Rangers_User_Received_Friend_Requests_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_User_Received_Friend_Requests_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_User_Received_Friend_Requests_Bool_Exp;
};

/** columns and relationships of "rangers.user_role" */
export type Rangers_User_Role = {
  __typename?: 'rangers_user_role';
  id: Scalars['String']['output'];
};

/** aggregated selection of "rangers.user_role" */
export type Rangers_User_Role_Aggregate = {
  __typename?: 'rangers_user_role_aggregate';
  aggregate?: Maybe<Rangers_User_Role_Aggregate_Fields>;
  nodes: Array<Rangers_User_Role>;
};

/** aggregate fields of "rangers.user_role" */
export type Rangers_User_Role_Aggregate_Fields = {
  __typename?: 'rangers_user_role_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Role_Max_Fields>;
  min?: Maybe<Rangers_User_Role_Min_Fields>;
};


/** aggregate fields of "rangers.user_role" */
export type Rangers_User_Role_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Role_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.user_role". All fields are combined with a logical 'AND'. */
export type Rangers_User_Role_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Role_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Role_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Role_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.user_role" */
export enum Rangers_User_Role_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserRolePkey = 'user_role_pkey'
}

export enum Rangers_User_Role_Enum {
  Admin = 'admin',
  Moderator = 'moderator'
}

/** Boolean expression to compare columns of type "rangers_user_role_enum". All fields are combined with logical 'AND'. */
export type Rangers_User_Role_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Rangers_User_Role_Enum>;
  _in?: InputMaybe<Array<Rangers_User_Role_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Rangers_User_Role_Enum>;
  _nin?: InputMaybe<Array<Rangers_User_Role_Enum>>;
};

/** input type for inserting data into table "rangers.user_role" */
export type Rangers_User_Role_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Role_Max_Fields = {
  __typename?: 'rangers_user_role_max_fields';
  id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_User_Role_Min_Fields = {
  __typename?: 'rangers_user_role_min_fields';
  id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.user_role" */
export type Rangers_User_Role_Mutation_Response = {
  __typename?: 'rangers_user_role_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_User_Role>;
};

/** on_conflict condition type for table "rangers.user_role" */
export type Rangers_User_Role_On_Conflict = {
  constraint: Rangers_User_Role_Constraint;
  update_columns?: Array<Rangers_User_Role_Update_Column>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.user_role". */
export type Rangers_User_Role_Order_By = {
  id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.user_role */
export type Rangers_User_Role_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.user_role" */
export enum Rangers_User_Role_Select_Column {
  /** column name */
  Id = 'id'
}

/** input type for updating data in table "rangers.user_role" */
export type Rangers_User_Role_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_user_role" */
export type Rangers_User_Role_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Role_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Role_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "rangers.user_role" */
export enum Rangers_User_Role_Update_Column {
  /** column name */
  Id = 'id'
}

export type Rangers_User_Role_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_User_Role_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_User_Role_Bool_Exp;
};

/** columns and relationships of "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests = {
  __typename?: 'rangers_user_sent_friend_requests';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Aggregate = {
  __typename?: 'rangers_user_sent_friend_requests_aggregate';
  aggregate?: Maybe<Rangers_User_Sent_Friend_Requests_Aggregate_Fields>;
  nodes: Array<Rangers_User_Sent_Friend_Requests>;
};

export type Rangers_User_Sent_Friend_Requests_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_User_Sent_Friend_Requests_Aggregate_Bool_Exp_Count>;
};

export type Rangers_User_Sent_Friend_Requests_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Aggregate_Fields = {
  __typename?: 'rangers_user_sent_friend_requests_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Sent_Friend_Requests_Max_Fields>;
  min?: Maybe<Rangers_User_Sent_Friend_Requests_Min_Fields>;
};


/** aggregate fields of "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_User_Sent_Friend_Requests_Max_Order_By>;
  min?: InputMaybe<Rangers_User_Sent_Friend_Requests_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Arr_Rel_Insert_Input = {
  data: Array<Rangers_User_Sent_Friend_Requests_Insert_Input>;
};

/** Boolean expression to filter rows from the table "rangers.user_sent_friend_requests". All fields are combined with a logical 'AND'. */
export type Rangers_User_Sent_Friend_Requests_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Sent_Friend_Requests_Max_Fields = {
  __typename?: 'rangers_user_sent_friend_requests_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_User_Sent_Friend_Requests_Min_Fields = {
  __typename?: 'rangers_user_sent_friend_requests_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Mutation_Response = {
  __typename?: 'rangers_user_sent_friend_requests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_User_Sent_Friend_Requests>;
};

/** Ordering options when selecting data from "rangers.user_sent_friend_requests". */
export type Rangers_User_Sent_Friend_Requests_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.user_sent_friend_requests" */
export enum Rangers_User_Sent_Friend_Requests_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Sent_Friend_Requests_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Sent_Friend_Requests_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type Rangers_User_Sent_Friend_Requests_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_User_Sent_Friend_Requests_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_User_Sent_Friend_Requests_Bool_Exp;
};

/** columns and relationships of "rangers.user_settings" */
export type Rangers_User_Settings = {
  __typename?: 'rangers_user_settings';
  adhere_taboos?: Maybe<Scalars['Boolean']['output']>;
  pack_collection?: Maybe<Scalars['jsonb']['output']>;
  private_decks: Scalars['Boolean']['output'];
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "rangers.user_settings" */
export type Rangers_User_SettingsPack_CollectionArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "rangers.user_settings" */
export type Rangers_User_Settings_Aggregate = {
  __typename?: 'rangers_user_settings_aggregate';
  aggregate?: Maybe<Rangers_User_Settings_Aggregate_Fields>;
  nodes: Array<Rangers_User_Settings>;
};

/** aggregate fields of "rangers.user_settings" */
export type Rangers_User_Settings_Aggregate_Fields = {
  __typename?: 'rangers_user_settings_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Settings_Max_Fields>;
  min?: Maybe<Rangers_User_Settings_Min_Fields>;
};


/** aggregate fields of "rangers.user_settings" */
export type Rangers_User_Settings_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Settings_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Rangers_User_Settings_Append_Input = {
  pack_collection?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.user_settings". All fields are combined with a logical 'AND'. */
export type Rangers_User_Settings_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Settings_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Settings_Bool_Exp>>;
  adhere_taboos?: InputMaybe<Boolean_Comparison_Exp>;
  pack_collection?: InputMaybe<Jsonb_Comparison_Exp>;
  private_decks?: InputMaybe<Boolean_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.user_settings" */
export enum Rangers_User_Settings_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  UserSettingsPkey = 'user_settings_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Rangers_User_Settings_Delete_At_Path_Input = {
  pack_collection?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Rangers_User_Settings_Delete_Elem_Input = {
  pack_collection?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Rangers_User_Settings_Delete_Key_Input = {
  pack_collection?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "rangers.user_settings" */
export type Rangers_User_Settings_Insert_Input = {
  adhere_taboos?: InputMaybe<Scalars['Boolean']['input']>;
  pack_collection?: InputMaybe<Scalars['jsonb']['input']>;
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Settings_Max_Fields = {
  __typename?: 'rangers_user_settings_max_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_User_Settings_Min_Fields = {
  __typename?: 'rangers_user_settings_min_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.user_settings" */
export type Rangers_User_Settings_Mutation_Response = {
  __typename?: 'rangers_user_settings_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_User_Settings>;
};

/** input type for inserting object relation for remote table "rangers.user_settings" */
export type Rangers_User_Settings_Obj_Rel_Insert_Input = {
  data: Rangers_User_Settings_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_User_Settings_On_Conflict>;
};

/** on_conflict condition type for table "rangers.user_settings" */
export type Rangers_User_Settings_On_Conflict = {
  constraint: Rangers_User_Settings_Constraint;
  update_columns?: Array<Rangers_User_Settings_Update_Column>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.user_settings". */
export type Rangers_User_Settings_Order_By = {
  adhere_taboos?: InputMaybe<Order_By>;
  pack_collection?: InputMaybe<Order_By>;
  private_decks?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.user_settings */
export type Rangers_User_Settings_Pk_Columns_Input = {
  user_id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Rangers_User_Settings_Prepend_Input = {
  pack_collection?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "rangers.user_settings" */
export enum Rangers_User_Settings_Select_Column {
  /** column name */
  AdhereTaboos = 'adhere_taboos',
  /** column name */
  PackCollection = 'pack_collection',
  /** column name */
  PrivateDecks = 'private_decks',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.user_settings" */
export type Rangers_User_Settings_Set_Input = {
  adhere_taboos?: InputMaybe<Scalars['Boolean']['input']>;
  pack_collection?: InputMaybe<Scalars['jsonb']['input']>;
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_user_settings" */
export type Rangers_User_Settings_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Settings_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Settings_Stream_Cursor_Value_Input = {
  adhere_taboos?: InputMaybe<Scalars['Boolean']['input']>;
  pack_collection?: InputMaybe<Scalars['jsonb']['input']>;
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "rangers.user_settings" */
export enum Rangers_User_Settings_Update_Column {
  /** column name */
  AdhereTaboos = 'adhere_taboos',
  /** column name */
  PackCollection = 'pack_collection',
  /** column name */
  PrivateDecks = 'private_decks',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_User_Settings_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Rangers_User_Settings_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Rangers_User_Settings_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Rangers_User_Settings_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Rangers_User_Settings_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Rangers_User_Settings_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_User_Settings_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_User_Settings_Bool_Exp;
};

/** columns and relationships of "rangers.users" */
export type Rangers_Users = {
  __typename?: 'rangers_users';
  /** An array relationship */
  campaigns: Array<Rangers_User_Campaign>;
  /** An aggregate relationship */
  campaigns_aggregate: Rangers_User_Campaign_Aggregate;
  created_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  friends: Array<Rangers_User_Friends>;
  /** An aggregate relationship */
  friends_aggregate: Rangers_User_Friends_Aggregate;
  handle?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  normalized_handle?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  received_requests: Array<Rangers_User_Received_Friend_Requests>;
  /** An aggregate relationship */
  received_requests_aggregate: Rangers_User_Received_Friend_Requests_Aggregate;
  role?: Maybe<Rangers_User_Role_Enum>;
  /** An array relationship */
  sent_requests: Array<Rangers_User_Sent_Friend_Requests>;
  /** An aggregate relationship */
  sent_requests_aggregate: Rangers_User_Sent_Friend_Requests_Aggregate;
  /** An object relationship */
  settings?: Maybe<Rangers_User_Settings>;
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersCampaignsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersCampaigns_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersFriendsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersFriends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersReceived_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersReceived_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersSent_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersSent_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};

/** aggregated selection of "rangers.users" */
export type Rangers_Users_Aggregate = {
  __typename?: 'rangers_users_aggregate';
  aggregate?: Maybe<Rangers_Users_Aggregate_Fields>;
  nodes: Array<Rangers_Users>;
};

/** aggregate fields of "rangers.users" */
export type Rangers_Users_Aggregate_Fields = {
  __typename?: 'rangers_users_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Users_Max_Fields>;
  min?: Maybe<Rangers_Users_Min_Fields>;
};


/** aggregate fields of "rangers.users" */
export type Rangers_Users_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.users". All fields are combined with a logical 'AND'. */
export type Rangers_Users_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Users_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Users_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Users_Bool_Exp>>;
  campaigns?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
  campaigns_aggregate?: InputMaybe<Rangers_User_Campaign_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  friends?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
  friends_aggregate?: InputMaybe<Rangers_User_Friends_Aggregate_Bool_Exp>;
  handle?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  normalized_handle?: InputMaybe<String_Comparison_Exp>;
  received_requests?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
  received_requests_aggregate?: InputMaybe<Rangers_User_Received_Friend_Requests_Aggregate_Bool_Exp>;
  role?: InputMaybe<Rangers_User_Role_Enum_Comparison_Exp>;
  sent_requests?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
  sent_requests_aggregate?: InputMaybe<Rangers_User_Sent_Friend_Requests_Aggregate_Bool_Exp>;
  settings?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.users" */
export enum Rangers_Users_Constraint {
  /** unique or primary key constraint on columns "normalized_handle" */
  UsersNormalizedHandleKey = 'users_normalized_handle_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey'
}

/** input type for inserting data into table "rangers.users" */
export type Rangers_Users_Insert_Input = {
  campaigns?: InputMaybe<Rangers_User_Campaign_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  friends?: InputMaybe<Rangers_User_Friends_Arr_Rel_Insert_Input>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  received_requests?: InputMaybe<Rangers_User_Received_Friend_Requests_Arr_Rel_Insert_Input>;
  role?: InputMaybe<Rangers_User_Role_Enum>;
  sent_requests?: InputMaybe<Rangers_User_Sent_Friend_Requests_Arr_Rel_Insert_Input>;
  settings?: InputMaybe<Rangers_User_Settings_Obj_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Users_Max_Fields = {
  __typename?: 'rangers_users_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Users_Min_Fields = {
  __typename?: 'rangers_users_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.users" */
export type Rangers_Users_Mutation_Response = {
  __typename?: 'rangers_users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Users>;
};

/** input type for inserting object relation for remote table "rangers.users" */
export type Rangers_Users_Obj_Rel_Insert_Input = {
  data: Rangers_Users_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Users_On_Conflict>;
};

/** on_conflict condition type for table "rangers.users" */
export type Rangers_Users_On_Conflict = {
  constraint: Rangers_Users_Constraint;
  update_columns?: Array<Rangers_Users_Update_Column>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.users". */
export type Rangers_Users_Order_By = {
  campaigns_aggregate?: InputMaybe<Rangers_User_Campaign_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  friends_aggregate?: InputMaybe<Rangers_User_Friends_Aggregate_Order_By>;
  handle?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  normalized_handle?: InputMaybe<Order_By>;
  received_requests_aggregate?: InputMaybe<Rangers_User_Received_Friend_Requests_Aggregate_Order_By>;
  role?: InputMaybe<Order_By>;
  sent_requests_aggregate?: InputMaybe<Rangers_User_Sent_Friend_Requests_Aggregate_Order_By>;
  settings?: InputMaybe<Rangers_User_Settings_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.users */
export type Rangers_Users_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.users" */
export enum Rangers_Users_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  Role = 'role',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.users" */
export type Rangers_Users_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Rangers_User_Role_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_users" */
export type Rangers_Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Users_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Rangers_User_Role_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.users" */
export enum Rangers_Users_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  Role = 'role',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Users_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Users_Bool_Exp;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "all_card" */
  all_card: Array<All_Card>;
  /** fetch aggregated fields from the table: "all_card" */
  all_card_aggregate: All_Card_Aggregate;
  /** fetch data from the table: "all_card" using primary key columns */
  all_card_by_pk?: Maybe<All_Card>;
  /** fetch data from the table in a streaming manner: "all_card" */
  all_card_stream: Array<All_Card>;
  /** fetch data from the table: "all_card_text" */
  all_card_text: Array<All_Card_Text>;
  /** fetch aggregated fields from the table: "all_card_text" */
  all_card_text_aggregate: All_Card_Text_Aggregate;
  /** fetch data from the table: "all_card_text" using primary key columns */
  all_card_text_by_pk?: Maybe<All_Card_Text>;
  /** fetch data from the table in a streaming manner: "all_card_text" */
  all_card_text_stream: Array<All_Card_Text>;
  /** fetch data from the table: "all_card_updated" */
  all_card_updated: Array<All_Card_Updated>;
  /** fetch aggregated fields from the table: "all_card_updated" */
  all_card_updated_aggregate: All_Card_Updated_Aggregate;
  /** fetch data from the table: "all_card_updated" using primary key columns */
  all_card_updated_by_pk?: Maybe<All_Card_Updated>;
  /** fetch data from the table: "all_card_updated_by_version" */
  all_card_updated_by_version: Array<All_Card_Updated_By_Version>;
  /** fetch aggregated fields from the table: "all_card_updated_by_version" */
  all_card_updated_by_version_aggregate: All_Card_Updated_By_Version_Aggregate;
  /** fetch data from the table: "all_card_updated_by_version" using primary key columns */
  all_card_updated_by_version_by_pk?: Maybe<All_Card_Updated_By_Version>;
  /** fetch data from the table in a streaming manner: "all_card_updated_by_version" */
  all_card_updated_by_version_stream: Array<All_Card_Updated_By_Version>;
  /** fetch data from the table in a streaming manner: "all_card_updated" */
  all_card_updated_stream: Array<All_Card_Updated>;
  /** fetch data from the table: "arkhamdb_auth" */
  arkhamdb_auth: Array<Arkhamdb_Auth>;
  /** fetch aggregated fields from the table: "arkhamdb_auth" */
  arkhamdb_auth_aggregate: Arkhamdb_Auth_Aggregate;
  /** fetch data from the table: "arkhamdb_auth" using primary key columns */
  arkhamdb_auth_by_pk?: Maybe<Arkhamdb_Auth>;
  /** fetch data from the table in a streaming manner: "arkhamdb_auth" */
  arkhamdb_auth_stream: Array<Arkhamdb_Auth>;
  /** fetch data from the table: "arkhamdb_deck" */
  arkhamdb_deck: Array<Arkhamdb_Deck>;
  /** fetch aggregated fields from the table: "arkhamdb_deck" */
  arkhamdb_deck_aggregate: Arkhamdb_Deck_Aggregate;
  /** fetch data from the table: "arkhamdb_deck" using primary key columns */
  arkhamdb_deck_by_pk?: Maybe<Arkhamdb_Deck>;
  /** fetch data from the table in a streaming manner: "arkhamdb_deck" */
  arkhamdb_deck_stream: Array<Arkhamdb_Deck>;
  /** An array relationship */
  base_decks: Array<Base_Decks>;
  /** An aggregate relationship */
  base_decks_aggregate: Base_Decks_Aggregate;
  /** fetch data from the table in a streaming manner: "base_decks" */
  base_decks_stream: Array<Base_Decks>;
  /** fetch data from the table: "campaign" */
  campaign: Array<Campaign>;
  /** fetch data from the table: "campaign_access" */
  campaign_access: Array<Campaign_Access>;
  /** fetch aggregated fields from the table: "campaign_access" */
  campaign_access_aggregate: Campaign_Access_Aggregate;
  /** fetch data from the table: "campaign_access" using primary key columns */
  campaign_access_by_pk?: Maybe<Campaign_Access>;
  /** fetch data from the table in a streaming manner: "campaign_access" */
  campaign_access_stream: Array<Campaign_Access>;
  /** fetch aggregated fields from the table: "campaign" */
  campaign_aggregate: Campaign_Aggregate;
  /** fetch data from the table: "campaign" using primary key columns */
  campaign_by_pk?: Maybe<Campaign>;
  /** fetch data from the table: "campaign_deck" */
  campaign_deck: Array<Campaign_Deck>;
  /** fetch aggregated fields from the table: "campaign_deck" */
  campaign_deck_aggregate: Campaign_Deck_Aggregate;
  /** fetch data from the table: "campaign_deck" using primary key columns */
  campaign_deck_by_pk?: Maybe<Campaign_Deck>;
  /** fetch data from the table in a streaming manner: "campaign_deck" */
  campaign_deck_stream: Array<Campaign_Deck>;
  /** fetch data from the table: "campaign_difficulty" */
  campaign_difficulty: Array<Campaign_Difficulty>;
  /** fetch aggregated fields from the table: "campaign_difficulty" */
  campaign_difficulty_aggregate: Campaign_Difficulty_Aggregate;
  /** fetch data from the table: "campaign_difficulty" using primary key columns */
  campaign_difficulty_by_pk?: Maybe<Campaign_Difficulty>;
  /** fetch data from the table in a streaming manner: "campaign_difficulty" */
  campaign_difficulty_stream: Array<Campaign_Difficulty>;
  /** fetch data from the table: "campaign_guide" */
  campaign_guide: Array<Campaign_Guide>;
  /** fetch aggregated fields from the table: "campaign_guide" */
  campaign_guide_aggregate: Campaign_Guide_Aggregate;
  /** fetch data from the table in a streaming manner: "campaign_guide" */
  campaign_guide_stream: Array<Campaign_Guide>;
  /** fetch data from the table: "campaign_investigator" */
  campaign_investigator: Array<Campaign_Investigator>;
  /** fetch aggregated fields from the table: "campaign_investigator" */
  campaign_investigator_aggregate: Campaign_Investigator_Aggregate;
  /** fetch data from the table: "campaign_investigator" using primary key columns */
  campaign_investigator_by_pk?: Maybe<Campaign_Investigator>;
  /** fetch data from the table in a streaming manner: "campaign_investigator" */
  campaign_investigator_stream: Array<Campaign_Investigator>;
  /** fetch data from the table in a streaming manner: "campaign" */
  campaign_stream: Array<Campaign>;
  /** fetch data from the table: "campaigns_by_cycle" */
  campaigns_by_cycle: Array<Campaigns_By_Cycle>;
  /** fetch aggregated fields from the table: "campaigns_by_cycle" */
  campaigns_by_cycle_aggregate: Campaigns_By_Cycle_Aggregate;
  /** fetch data from the table in a streaming manner: "campaigns_by_cycle" */
  campaigns_by_cycle_stream: Array<Campaigns_By_Cycle>;
  /** fetch data from the table: "card" */
  card: Array<Card>;
  /** fetch aggregated fields from the table: "card" */
  card_aggregate: Card_Aggregate;
  /** fetch data from the table: "card" using primary key columns */
  card_by_pk?: Maybe<Card>;
  /** fetch data from the table: "card_cycle" */
  card_cycle: Array<Card_Cycle>;
  /** fetch aggregated fields from the table: "card_cycle" */
  card_cycle_aggregate: Card_Cycle_Aggregate;
  /** fetch data from the table: "card_cycle" using primary key columns */
  card_cycle_by_pk?: Maybe<Card_Cycle>;
  /** fetch data from the table in a streaming manner: "card_cycle" */
  card_cycle_stream: Array<Card_Cycle>;
  /** fetch data from the table: "card_encounter_set" */
  card_encounter_set: Array<Card_Encounter_Set>;
  /** fetch aggregated fields from the table: "card_encounter_set" */
  card_encounter_set_aggregate: Card_Encounter_Set_Aggregate;
  /** fetch data from the table: "card_encounter_set" using primary key columns */
  card_encounter_set_by_pk?: Maybe<Card_Encounter_Set>;
  /** fetch data from the table in a streaming manner: "card_encounter_set" */
  card_encounter_set_stream: Array<Card_Encounter_Set>;
  /** fetch data from the table: "card_pack" */
  card_pack: Array<Card_Pack>;
  /** fetch aggregated fields from the table: "card_pack" */
  card_pack_aggregate: Card_Pack_Aggregate;
  /** fetch data from the table: "card_pack" using primary key columns */
  card_pack_by_pk?: Maybe<Card_Pack>;
  /** fetch data from the table in a streaming manner: "card_pack" */
  card_pack_stream: Array<Card_Pack>;
  /** fetch data from the table in a streaming manner: "card" */
  card_stream: Array<Card>;
  /** fetch data from the table: "card_subtype_name" */
  card_subtype_name: Array<Card_Subtype_Name>;
  /** fetch aggregated fields from the table: "card_subtype_name" */
  card_subtype_name_aggregate: Card_Subtype_Name_Aggregate;
  /** fetch data from the table: "card_subtype_name" using primary key columns */
  card_subtype_name_by_pk?: Maybe<Card_Subtype_Name>;
  /** fetch data from the table in a streaming manner: "card_subtype_name" */
  card_subtype_name_stream: Array<Card_Subtype_Name>;
  /** fetch data from the table: "card_text" */
  card_text: Array<Card_Text>;
  /** fetch aggregated fields from the table: "card_text" */
  card_text_aggregate: Card_Text_Aggregate;
  /** fetch data from the table: "card_text" using primary key columns */
  card_text_by_pk?: Maybe<Card_Text>;
  /** fetch data from the table in a streaming manner: "card_text" */
  card_text_stream: Array<Card_Text>;
  /** fetch data from the table: "card_type_code" */
  card_type_code: Array<Card_Type_Code>;
  /** fetch aggregated fields from the table: "card_type_code" */
  card_type_code_aggregate: Card_Type_Code_Aggregate;
  /** fetch data from the table: "card_type_code" using primary key columns */
  card_type_code_by_pk?: Maybe<Card_Type_Code>;
  /** fetch data from the table in a streaming manner: "card_type_code" */
  card_type_code_stream: Array<Card_Type_Code>;
  /** fetch data from the table: "card_type_name" */
  card_type_name: Array<Card_Type_Name>;
  /** fetch aggregated fields from the table: "card_type_name" */
  card_type_name_aggregate: Card_Type_Name_Aggregate;
  /** fetch data from the table: "card_type_name" using primary key columns */
  card_type_name_by_pk?: Maybe<Card_Type_Name>;
  /** fetch data from the table in a streaming manner: "card_type_name" */
  card_type_name_stream: Array<Card_Type_Name>;
  /** An array relationship */
  chaos_bag_result: Array<Chaos_Bag_Result>;
  /** An aggregate relationship */
  chaos_bag_result_aggregate: Chaos_Bag_Result_Aggregate;
  /** fetch data from the table: "chaos_bag_result" using primary key columns */
  chaos_bag_result_by_pk?: Maybe<Chaos_Bag_Result>;
  /** fetch data from the table in a streaming manner: "chaos_bag_result" */
  chaos_bag_result_stream: Array<Chaos_Bag_Result>;
  /** fetch data from the table: "chaos_bag_tarot_mode" */
  chaos_bag_tarot_mode: Array<Chaos_Bag_Tarot_Mode>;
  /** fetch aggregated fields from the table: "chaos_bag_tarot_mode" */
  chaos_bag_tarot_mode_aggregate: Chaos_Bag_Tarot_Mode_Aggregate;
  /** fetch data from the table: "chaos_bag_tarot_mode" using primary key columns */
  chaos_bag_tarot_mode_by_pk?: Maybe<Chaos_Bag_Tarot_Mode>;
  /** fetch data from the table in a streaming manner: "chaos_bag_tarot_mode" */
  chaos_bag_tarot_mode_stream: Array<Chaos_Bag_Tarot_Mode>;
  /** fetch data from the table: "conquest.card" */
  conquest_card: Array<Conquest_Card>;
  /** fetch aggregated fields from the table: "conquest.card" */
  conquest_card_aggregate: Conquest_Card_Aggregate;
  /** fetch data from the table: "conquest.card" using primary key columns */
  conquest_card_by_pk?: Maybe<Conquest_Card>;
  /** fetch data from the table: "conquest.card_localized" */
  conquest_card_localized: Array<Conquest_Card_Localized>;
  /** fetch aggregated fields from the table: "conquest.card_localized" */
  conquest_card_localized_aggregate: Conquest_Card_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "conquest.card_localized" */
  conquest_card_localized_stream: Array<Conquest_Card_Localized>;
  /** fetch data from the table in a streaming manner: "conquest.card" */
  conquest_card_stream: Array<Conquest_Card>;
  /** fetch data from the table: "conquest.card_text" */
  conquest_card_text: Array<Conquest_Card_Text>;
  /** fetch aggregated fields from the table: "conquest.card_text" */
  conquest_card_text_aggregate: Conquest_Card_Text_Aggregate;
  /** fetch data from the table: "conquest.card_text" using primary key columns */
  conquest_card_text_by_pk?: Maybe<Conquest_Card_Text>;
  /** fetch data from the table in a streaming manner: "conquest.card_text" */
  conquest_card_text_stream: Array<Conquest_Card_Text>;
  /** fetch data from the table: "conquest.card_updated" */
  conquest_card_updated: Array<Conquest_Card_Updated>;
  /** fetch aggregated fields from the table: "conquest.card_updated" */
  conquest_card_updated_aggregate: Conquest_Card_Updated_Aggregate;
  /** fetch data from the table in a streaming manner: "conquest.card_updated" */
  conquest_card_updated_stream: Array<Conquest_Card_Updated>;
  /** fetch data from the table: "conquest.comment" */
  conquest_comment: Array<Conquest_Comment>;
  /** fetch aggregated fields from the table: "conquest.comment" */
  conquest_comment_aggregate: Conquest_Comment_Aggregate;
  /** fetch data from the table: "conquest.comment" using primary key columns */
  conquest_comment_by_pk?: Maybe<Conquest_Comment>;
  /** fetch data from the table in a streaming manner: "conquest.comment" */
  conquest_comment_stream: Array<Conquest_Comment>;
  /** fetch data from the table: "conquest.cycle" */
  conquest_cycle: Array<Conquest_Cycle>;
  /** fetch aggregated fields from the table: "conquest.cycle" */
  conquest_cycle_aggregate: Conquest_Cycle_Aggregate;
  /** fetch data from the table: "conquest.cycle" using primary key columns */
  conquest_cycle_by_pk?: Maybe<Conquest_Cycle>;
  /** fetch data from the table in a streaming manner: "conquest.cycle" */
  conquest_cycle_stream: Array<Conquest_Cycle>;
  /** fetch data from the table: "conquest.cycle_text" */
  conquest_cycle_text: Array<Conquest_Cycle_Text>;
  /** fetch aggregated fields from the table: "conquest.cycle_text" */
  conquest_cycle_text_aggregate: Conquest_Cycle_Text_Aggregate;
  /** fetch data from the table: "conquest.cycle_text" using primary key columns */
  conquest_cycle_text_by_pk?: Maybe<Conquest_Cycle_Text>;
  /** fetch data from the table in a streaming manner: "conquest.cycle_text" */
  conquest_cycle_text_stream: Array<Conquest_Cycle_Text>;
  /** fetch data from the table: "conquest.deck" */
  conquest_deck: Array<Conquest_Deck>;
  /** fetch aggregated fields from the table: "conquest.deck" */
  conquest_deck_aggregate: Conquest_Deck_Aggregate;
  /** fetch data from the table: "conquest.deck" using primary key columns */
  conquest_deck_by_pk?: Maybe<Conquest_Deck>;
  /** fetch data from the table: "conquest.deck_copy" */
  conquest_deck_copy: Array<Conquest_Deck_Copy>;
  /** fetch aggregated fields from the table: "conquest.deck_copy" */
  conquest_deck_copy_aggregate: Conquest_Deck_Copy_Aggregate;
  /** fetch data from the table: "conquest.deck_copy" using primary key columns */
  conquest_deck_copy_by_pk?: Maybe<Conquest_Deck_Copy>;
  /** fetch data from the table in a streaming manner: "conquest.deck_copy" */
  conquest_deck_copy_stream: Array<Conquest_Deck_Copy>;
  /** fetch data from the table: "conquest.deck_like" */
  conquest_deck_like: Array<Conquest_Deck_Like>;
  /** fetch aggregated fields from the table: "conquest.deck_like" */
  conquest_deck_like_aggregate: Conquest_Deck_Like_Aggregate;
  /** fetch data from the table: "conquest.deck_like" using primary key columns */
  conquest_deck_like_by_pk?: Maybe<Conquest_Deck_Like>;
  /** fetch data from the table in a streaming manner: "conquest.deck_like" */
  conquest_deck_like_stream: Array<Conquest_Deck_Like>;
  /** fetch data from the table in a streaming manner: "conquest.deck" */
  conquest_deck_stream: Array<Conquest_Deck>;
  /** fetch data from the table: "conquest.faction" */
  conquest_faction: Array<Conquest_Faction>;
  /** fetch aggregated fields from the table: "conquest.faction" */
  conquest_faction_aggregate: Conquest_Faction_Aggregate;
  /** fetch data from the table: "conquest.faction" using primary key columns */
  conquest_faction_by_pk?: Maybe<Conquest_Faction>;
  /** fetch data from the table in a streaming manner: "conquest.faction" */
  conquest_faction_stream: Array<Conquest_Faction>;
  /** fetch data from the table: "conquest.faction_text" */
  conquest_faction_text: Array<Conquest_Faction_Text>;
  /** fetch aggregated fields from the table: "conquest.faction_text" */
  conquest_faction_text_aggregate: Conquest_Faction_Text_Aggregate;
  /** fetch data from the table: "conquest.faction_text" using primary key columns */
  conquest_faction_text_by_pk?: Maybe<Conquest_Faction_Text>;
  /** fetch data from the table in a streaming manner: "conquest.faction_text" */
  conquest_faction_text_stream: Array<Conquest_Faction_Text>;
  /** fetch data from the table: "conquest.loyalty" */
  conquest_loyalty: Array<Conquest_Loyalty>;
  /** fetch aggregated fields from the table: "conquest.loyalty" */
  conquest_loyalty_aggregate: Conquest_Loyalty_Aggregate;
  /** fetch data from the table: "conquest.loyalty" using primary key columns */
  conquest_loyalty_by_pk?: Maybe<Conquest_Loyalty>;
  /** fetch data from the table in a streaming manner: "conquest.loyalty" */
  conquest_loyalty_stream: Array<Conquest_Loyalty>;
  /** fetch data from the table: "conquest.loyalty_text" */
  conquest_loyalty_text: Array<Conquest_Loyalty_Text>;
  /** fetch aggregated fields from the table: "conquest.loyalty_text" */
  conquest_loyalty_text_aggregate: Conquest_Loyalty_Text_Aggregate;
  /** fetch data from the table: "conquest.loyalty_text" using primary key columns */
  conquest_loyalty_text_by_pk?: Maybe<Conquest_Loyalty_Text>;
  /** fetch data from the table in a streaming manner: "conquest.loyalty_text" */
  conquest_loyalty_text_stream: Array<Conquest_Loyalty_Text>;
  /** fetch data from the table: "conquest.pack" */
  conquest_pack: Array<Conquest_Pack>;
  /** fetch aggregated fields from the table: "conquest.pack" */
  conquest_pack_aggregate: Conquest_Pack_Aggregate;
  /** fetch data from the table: "conquest.pack" using primary key columns */
  conquest_pack_by_pk?: Maybe<Conquest_Pack>;
  /** fetch data from the table in a streaming manner: "conquest.pack" */
  conquest_pack_stream: Array<Conquest_Pack>;
  /** fetch data from the table: "conquest.pack_text" */
  conquest_pack_text: Array<Conquest_Pack_Text>;
  /** fetch aggregated fields from the table: "conquest.pack_text" */
  conquest_pack_text_aggregate: Conquest_Pack_Text_Aggregate;
  /** fetch data from the table: "conquest.pack_text" using primary key columns */
  conquest_pack_text_by_pk?: Maybe<Conquest_Pack_Text>;
  /** fetch data from the table in a streaming manner: "conquest.pack_text" */
  conquest_pack_text_stream: Array<Conquest_Pack_Text>;
  /** fetch data from the table: "conquest.type" */
  conquest_type: Array<Conquest_Type>;
  /** fetch aggregated fields from the table: "conquest.type" */
  conquest_type_aggregate: Conquest_Type_Aggregate;
  /** fetch data from the table: "conquest.type" using primary key columns */
  conquest_type_by_pk?: Maybe<Conquest_Type>;
  /** fetch data from the table in a streaming manner: "conquest.type" */
  conquest_type_stream: Array<Conquest_Type>;
  /** fetch data from the table: "conquest.type_text" */
  conquest_type_text: Array<Conquest_Type_Text>;
  /** fetch aggregated fields from the table: "conquest.type_text" */
  conquest_type_text_aggregate: Conquest_Type_Text_Aggregate;
  /** fetch data from the table: "conquest.type_text" using primary key columns */
  conquest_type_text_by_pk?: Maybe<Conquest_Type_Text>;
  /** fetch data from the table in a streaming manner: "conquest.type_text" */
  conquest_type_text_stream: Array<Conquest_Type_Text>;
  /** fetch data from the table: "conquest.user_role" */
  conquest_user_role: Array<Conquest_User_Role>;
  /** fetch aggregated fields from the table: "conquest.user_role" */
  conquest_user_role_aggregate: Conquest_User_Role_Aggregate;
  /** fetch data from the table: "conquest.user_role" using primary key columns */
  conquest_user_role_by_pk?: Maybe<Conquest_User_Role>;
  /** fetch data from the table in a streaming manner: "conquest.user_role" */
  conquest_user_role_stream: Array<Conquest_User_Role>;
  /** fetch data from the table: "conquest.user_settings" */
  conquest_user_settings: Array<Conquest_User_Settings>;
  /** fetch aggregated fields from the table: "conquest.user_settings" */
  conquest_user_settings_aggregate: Conquest_User_Settings_Aggregate;
  /** fetch data from the table: "conquest.user_settings" using primary key columns */
  conquest_user_settings_by_pk?: Maybe<Conquest_User_Settings>;
  /** fetch data from the table in a streaming manner: "conquest.user_settings" */
  conquest_user_settings_stream: Array<Conquest_User_Settings>;
  /** fetch data from the table: "conquest.users" */
  conquest_users: Array<Conquest_Users>;
  /** fetch aggregated fields from the table: "conquest.users" */
  conquest_users_aggregate: Conquest_Users_Aggregate;
  /** fetch data from the table: "conquest.users" using primary key columns */
  conquest_users_by_pk?: Maybe<Conquest_Users>;
  /** fetch data from the table in a streaming manner: "conquest.users" */
  conquest_users_stream: Array<Conquest_Users>;
  /** fetch data from the table: "cycle" */
  cycle: Array<Cycle>;
  /** fetch aggregated fields from the table: "cycle" */
  cycle_aggregate: Cycle_Aggregate;
  /** fetch data from the table: "cycle" using primary key columns */
  cycle_by_pk?: Maybe<Cycle>;
  /** fetch data from the table: "cycle_name" */
  cycle_name: Array<Cycle_Name>;
  /** fetch aggregated fields from the table: "cycle_name" */
  cycle_name_aggregate: Cycle_Name_Aggregate;
  /** fetch data from the table: "cycle_name" using primary key columns */
  cycle_name_by_pk?: Maybe<Cycle_Name>;
  /** fetch data from the table in a streaming manner: "cycle_name" */
  cycle_name_stream: Array<Cycle_Name>;
  /** fetch data from the table in a streaming manner: "cycle" */
  cycle_stream: Array<Cycle>;
  /** fetch data from the table: "faction_name" */
  faction_name: Array<Faction_Name>;
  /** fetch aggregated fields from the table: "faction_name" */
  faction_name_aggregate: Faction_Name_Aggregate;
  /** fetch data from the table: "faction_name" using primary key columns */
  faction_name_by_pk?: Maybe<Faction_Name>;
  /** fetch data from the table in a streaming manner: "faction_name" */
  faction_name_stream: Array<Faction_Name>;
  /** fetch data from the table: "faq" */
  faq: Array<Faq>;
  /** fetch aggregated fields from the table: "faq" */
  faq_aggregate: Faq_Aggregate;
  /** fetch data from the table: "faq" using primary key columns */
  faq_by_pk?: Maybe<Faq>;
  /** fetch data from the table in a streaming manner: "faq" */
  faq_stream: Array<Faq>;
  /** fetch data from the table: "faq_text" */
  faq_text: Array<Faq_Text>;
  /** fetch aggregated fields from the table: "faq_text" */
  faq_text_aggregate: Faq_Text_Aggregate;
  /** fetch data from the table: "faq_text" using primary key columns */
  faq_text_by_pk?: Maybe<Faq_Text>;
  /** fetch data from the table in a streaming manner: "faq_text" */
  faq_text_stream: Array<Faq_Text>;
  /** fetch data from the table: "friend_status" */
  friend_status: Array<Friend_Status>;
  /** fetch aggregated fields from the table: "friend_status" */
  friend_status_aggregate: Friend_Status_Aggregate;
  /** fetch data from the table: "friend_status" using primary key columns */
  friend_status_by_pk?: Maybe<Friend_Status>;
  /** fetch data from the table in a streaming manner: "friend_status" */
  friend_status_stream: Array<Friend_Status>;
  /** fetch data from the table: "friend_status_type" */
  friend_status_type: Array<Friend_Status_Type>;
  /** fetch aggregated fields from the table: "friend_status_type" */
  friend_status_type_aggregate: Friend_Status_Type_Aggregate;
  /** fetch data from the table: "friend_status_type" using primary key columns */
  friend_status_type_by_pk?: Maybe<Friend_Status_Type>;
  /** fetch data from the table in a streaming manner: "friend_status_type" */
  friend_status_type_stream: Array<Friend_Status_Type>;
  /** fetch data from the table: "full_card" */
  full_card: Array<Full_Card>;
  /** fetch aggregated fields from the table: "full_card" */
  full_card_aggregate: Full_Card_Aggregate;
  /** fetch data from the table: "full_card" using primary key columns */
  full_card_by_pk?: Maybe<Full_Card>;
  /** fetch data from the table in a streaming manner: "full_card" */
  full_card_stream: Array<Full_Card>;
  /** fetch data from the table: "full_card_text" */
  full_card_text: Array<Full_Card_Text>;
  /** fetch aggregated fields from the table: "full_card_text" */
  full_card_text_aggregate: Full_Card_Text_Aggregate;
  /** fetch data from the table: "full_card_text" using primary key columns */
  full_card_text_by_pk?: Maybe<Full_Card_Text>;
  /** fetch data from the table in a streaming manner: "full_card_text" */
  full_card_text_stream: Array<Full_Card_Text>;
  /** fetch data from the table: "gender" */
  gender: Array<Gender>;
  /** fetch aggregated fields from the table: "gender" */
  gender_aggregate: Gender_Aggregate;
  /** fetch data from the table: "gender" using primary key columns */
  gender_by_pk?: Maybe<Gender>;
  /** fetch data from the table in a streaming manner: "gender" */
  gender_stream: Array<Gender>;
  /** fetch data from the table: "guide_achievement" */
  guide_achievement: Array<Guide_Achievement>;
  /** fetch aggregated fields from the table: "guide_achievement" */
  guide_achievement_aggregate: Guide_Achievement_Aggregate;
  /** fetch data from the table: "guide_achievement" using primary key columns */
  guide_achievement_by_pk?: Maybe<Guide_Achievement>;
  /** fetch data from the table in a streaming manner: "guide_achievement" */
  guide_achievement_stream: Array<Guide_Achievement>;
  /** fetch data from the table: "guide_input" */
  guide_input: Array<Guide_Input>;
  /** fetch aggregated fields from the table: "guide_input" */
  guide_input_aggregate: Guide_Input_Aggregate;
  /** fetch data from the table: "guide_input" using primary key columns */
  guide_input_by_pk?: Maybe<Guide_Input>;
  /** fetch data from the table in a streaming manner: "guide_input" */
  guide_input_stream: Array<Guide_Input>;
  /** An array relationship */
  investigator_data: Array<Investigator_Data>;
  /** An aggregate relationship */
  investigator_data_aggregate: Investigator_Data_Aggregate;
  /** fetch data from the table: "investigator_data" using primary key columns */
  investigator_data_by_pk?: Maybe<Investigator_Data>;
  /** fetch data from the table in a streaming manner: "investigator_data" */
  investigator_data_stream: Array<Investigator_Data>;
  /** An array relationship */
  latest_decks: Array<Latest_Decks>;
  /** An aggregate relationship */
  latest_decks_aggregate: Latest_Decks_Aggregate;
  /** fetch data from the table in a streaming manner: "latest_decks" */
  latest_decks_stream: Array<Latest_Decks>;
  /** An array relationship */
  local_decks: Array<Local_Decks>;
  /** An aggregate relationship */
  local_decks_aggregate: Local_Decks_Aggregate;
  /** fetch data from the table in a streaming manner: "local_decks" */
  local_decks_stream: Array<Local_Decks>;
  /** fetch data from the table: "pack" */
  pack: Array<Pack>;
  /** fetch aggregated fields from the table: "pack" */
  pack_aggregate: Pack_Aggregate;
  /** fetch data from the table: "pack" using primary key columns */
  pack_by_pk?: Maybe<Pack>;
  /** fetch data from the table: "pack_name" */
  pack_name: Array<Pack_Name>;
  /** fetch aggregated fields from the table: "pack_name" */
  pack_name_aggregate: Pack_Name_Aggregate;
  /** fetch data from the table: "pack_name" using primary key columns */
  pack_name_by_pk?: Maybe<Pack_Name>;
  /** fetch data from the table in a streaming manner: "pack_name" */
  pack_name_stream: Array<Pack_Name>;
  /** fetch data from the table in a streaming manner: "pack" */
  pack_stream: Array<Pack>;
  /** fetch data from the table: "rangers.area" */
  rangers_area: Array<Rangers_Area>;
  /** fetch aggregated fields from the table: "rangers.area" */
  rangers_area_aggregate: Rangers_Area_Aggregate;
  /** fetch data from the table: "rangers.area" using primary key columns */
  rangers_area_by_pk?: Maybe<Rangers_Area>;
  /** fetch data from the table in a streaming manner: "rangers.area" */
  rangers_area_stream: Array<Rangers_Area>;
  /** fetch data from the table: "rangers.area_text" */
  rangers_area_text: Array<Rangers_Area_Text>;
  /** fetch aggregated fields from the table: "rangers.area_text" */
  rangers_area_text_aggregate: Rangers_Area_Text_Aggregate;
  /** fetch data from the table: "rangers.area_text" using primary key columns */
  rangers_area_text_by_pk?: Maybe<Rangers_Area_Text>;
  /** fetch data from the table in a streaming manner: "rangers.area_text" */
  rangers_area_text_stream: Array<Rangers_Area_Text>;
  /** fetch data from the table: "rangers.aspect" */
  rangers_aspect: Array<Rangers_Aspect>;
  /** fetch aggregated fields from the table: "rangers.aspect" */
  rangers_aspect_aggregate: Rangers_Aspect_Aggregate;
  /** fetch data from the table: "rangers.aspect" using primary key columns */
  rangers_aspect_by_pk?: Maybe<Rangers_Aspect>;
  /** fetch data from the table: "rangers.aspect_localized" */
  rangers_aspect_localized: Array<Rangers_Aspect_Localized>;
  /** fetch aggregated fields from the table: "rangers.aspect_localized" */
  rangers_aspect_localized_aggregate: Rangers_Aspect_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.aspect_localized" */
  rangers_aspect_localized_stream: Array<Rangers_Aspect_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.aspect" */
  rangers_aspect_stream: Array<Rangers_Aspect>;
  /** fetch data from the table: "rangers.aspect_text" */
  rangers_aspect_text: Array<Rangers_Aspect_Text>;
  /** fetch aggregated fields from the table: "rangers.aspect_text" */
  rangers_aspect_text_aggregate: Rangers_Aspect_Text_Aggregate;
  /** fetch data from the table: "rangers.aspect_text" using primary key columns */
  rangers_aspect_text_by_pk?: Maybe<Rangers_Aspect_Text>;
  /** fetch data from the table in a streaming manner: "rangers.aspect_text" */
  rangers_aspect_text_stream: Array<Rangers_Aspect_Text>;
  /** fetch data from the table: "rangers.campaign" */
  rangers_campaign: Array<Rangers_Campaign>;
  /** fetch data from the table: "rangers.campaign_access" */
  rangers_campaign_access: Array<Rangers_Campaign_Access>;
  /** fetch aggregated fields from the table: "rangers.campaign_access" */
  rangers_campaign_access_aggregate: Rangers_Campaign_Access_Aggregate;
  /** fetch data from the table: "rangers.campaign_access" using primary key columns */
  rangers_campaign_access_by_pk?: Maybe<Rangers_Campaign_Access>;
  /** fetch data from the table in a streaming manner: "rangers.campaign_access" */
  rangers_campaign_access_stream: Array<Rangers_Campaign_Access>;
  /** fetch aggregated fields from the table: "rangers.campaign" */
  rangers_campaign_aggregate: Rangers_Campaign_Aggregate;
  /** fetch data from the table: "rangers.campaign" using primary key columns */
  rangers_campaign_by_pk?: Maybe<Rangers_Campaign>;
  /** fetch data from the table in a streaming manner: "rangers.campaign" */
  rangers_campaign_stream: Array<Rangers_Campaign>;
  /** fetch data from the table: "rangers.card" */
  rangers_card: Array<Rangers_Card>;
  /** fetch aggregated fields from the table: "rangers.card" */
  rangers_card_aggregate: Rangers_Card_Aggregate;
  /** fetch data from the table: "rangers.card" using primary key columns */
  rangers_card_by_pk?: Maybe<Rangers_Card>;
  /** fetch data from the table: "rangers.card_localized" */
  rangers_card_localized: Array<Rangers_Card_Localized>;
  /** fetch aggregated fields from the table: "rangers.card_localized" */
  rangers_card_localized_aggregate: Rangers_Card_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.card_localized" */
  rangers_card_localized_stream: Array<Rangers_Card_Localized>;
  /** execute function "rangers.card_search" which returns "rangers.card_localized" */
  rangers_card_search: Array<Rangers_Card_Localized>;
  /** execute function "rangers.card_search" and query aggregates on result of table type "rangers.card_localized" */
  rangers_card_search_aggregate: Rangers_Card_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.card" */
  rangers_card_stream: Array<Rangers_Card>;
  /** fetch data from the table: "rangers.card_text" */
  rangers_card_text: Array<Rangers_Card_Text>;
  /** fetch aggregated fields from the table: "rangers.card_text" */
  rangers_card_text_aggregate: Rangers_Card_Text_Aggregate;
  /** fetch data from the table: "rangers.card_text" using primary key columns */
  rangers_card_text_by_pk?: Maybe<Rangers_Card_Text>;
  /** fetch data from the table in a streaming manner: "rangers.card_text" */
  rangers_card_text_stream: Array<Rangers_Card_Text>;
  /** fetch data from the table: "rangers.card_updated" */
  rangers_card_updated: Array<Rangers_Card_Updated>;
  /** fetch aggregated fields from the table: "rangers.card_updated" */
  rangers_card_updated_aggregate: Rangers_Card_Updated_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.card_updated" */
  rangers_card_updated_stream: Array<Rangers_Card_Updated>;
  /** fetch data from the table: "rangers.comment" */
  rangers_comment: Array<Rangers_Comment>;
  /** fetch aggregated fields from the table: "rangers.comment" */
  rangers_comment_aggregate: Rangers_Comment_Aggregate;
  /** fetch data from the table: "rangers.comment" using primary key columns */
  rangers_comment_by_pk?: Maybe<Rangers_Comment>;
  /** fetch data from the table in a streaming manner: "rangers.comment" */
  rangers_comment_stream: Array<Rangers_Comment>;
  /** fetch data from the table: "rangers.deck" */
  rangers_deck: Array<Rangers_Deck>;
  /** fetch aggregated fields from the table: "rangers.deck" */
  rangers_deck_aggregate: Rangers_Deck_Aggregate;
  /** fetch data from the table: "rangers.deck" using primary key columns */
  rangers_deck_by_pk?: Maybe<Rangers_Deck>;
  /** fetch data from the table: "rangers.deck_copy" */
  rangers_deck_copy: Array<Rangers_Deck_Copy>;
  /** fetch aggregated fields from the table: "rangers.deck_copy" */
  rangers_deck_copy_aggregate: Rangers_Deck_Copy_Aggregate;
  /** fetch data from the table: "rangers.deck_copy" using primary key columns */
  rangers_deck_copy_by_pk?: Maybe<Rangers_Deck_Copy>;
  /** fetch data from the table in a streaming manner: "rangers.deck_copy" */
  rangers_deck_copy_stream: Array<Rangers_Deck_Copy>;
  /** fetch data from the table: "rangers.deck_like" */
  rangers_deck_like: Array<Rangers_Deck_Like>;
  /** fetch aggregated fields from the table: "rangers.deck_like" */
  rangers_deck_like_aggregate: Rangers_Deck_Like_Aggregate;
  /** fetch data from the table: "rangers.deck_like" using primary key columns */
  rangers_deck_like_by_pk?: Maybe<Rangers_Deck_Like>;
  /** fetch data from the table: "rangers.deck_like_count" */
  rangers_deck_like_count: Array<Rangers_Deck_Like_Count>;
  /** fetch aggregated fields from the table: "rangers.deck_like_count" */
  rangers_deck_like_count_aggregate: Rangers_Deck_Like_Count_Aggregate;
  /** fetch data from the table: "rangers.deck_like_count" using primary key columns */
  rangers_deck_like_count_by_pk?: Maybe<Rangers_Deck_Like_Count>;
  /** fetch data from the table in a streaming manner: "rangers.deck_like_count" */
  rangers_deck_like_count_stream: Array<Rangers_Deck_Like_Count>;
  /** fetch data from the table in a streaming manner: "rangers.deck_like" */
  rangers_deck_like_stream: Array<Rangers_Deck_Like>;
  /** fetch data from the table: "rangers.deck_rank" */
  rangers_deck_rank: Array<Rangers_Deck_Rank>;
  /** fetch aggregated fields from the table: "rangers.deck_rank" */
  rangers_deck_rank_aggregate: Rangers_Deck_Rank_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.deck_rank" */
  rangers_deck_rank_stream: Array<Rangers_Deck_Rank>;
  /** execute function "rangers.deck_search" which returns "rangers.search_deck" */
  rangers_deck_search: Array<Rangers_Search_Deck>;
  /** execute function "rangers.deck_search" and query aggregates on result of table type "rangers.search_deck" */
  rangers_deck_search_aggregate: Rangers_Search_Deck_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.deck" */
  rangers_deck_stream: Array<Rangers_Deck>;
  /** fetch data from the table: "rangers.faq_entry" */
  rangers_faq_entry: Array<Rangers_Faq_Entry>;
  /** fetch aggregated fields from the table: "rangers.faq_entry" */
  rangers_faq_entry_aggregate: Rangers_Faq_Entry_Aggregate;
  /** fetch data from the table: "rangers.faq_entry" using primary key columns */
  rangers_faq_entry_by_pk?: Maybe<Rangers_Faq_Entry>;
  /** fetch data from the table in a streaming manner: "rangers.faq_entry" */
  rangers_faq_entry_stream: Array<Rangers_Faq_Entry>;
  /** fetch data from the table: "rangers.friend_status" */
  rangers_friend_status: Array<Rangers_Friend_Status>;
  /** fetch aggregated fields from the table: "rangers.friend_status" */
  rangers_friend_status_aggregate: Rangers_Friend_Status_Aggregate;
  /** fetch data from the table: "rangers.friend_status" using primary key columns */
  rangers_friend_status_by_pk?: Maybe<Rangers_Friend_Status>;
  /** fetch data from the table in a streaming manner: "rangers.friend_status" */
  rangers_friend_status_stream: Array<Rangers_Friend_Status>;
  /** fetch data from the table: "rangers.friend_status_type" */
  rangers_friend_status_type: Array<Rangers_Friend_Status_Type>;
  /** fetch aggregated fields from the table: "rangers.friend_status_type" */
  rangers_friend_status_type_aggregate: Rangers_Friend_Status_Type_Aggregate;
  /** fetch data from the table: "rangers.friend_status_type" using primary key columns */
  rangers_friend_status_type_by_pk?: Maybe<Rangers_Friend_Status_Type>;
  /** fetch data from the table in a streaming manner: "rangers.friend_status_type" */
  rangers_friend_status_type_stream: Array<Rangers_Friend_Status_Type>;
  /** fetch data from the table: "rangers.latest_deck" */
  rangers_latest_deck: Array<Rangers_Latest_Deck>;
  /** fetch aggregated fields from the table: "rangers.latest_deck" */
  rangers_latest_deck_aggregate: Rangers_Latest_Deck_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.latest_deck" */
  rangers_latest_deck_stream: Array<Rangers_Latest_Deck>;
  /** fetch data from the table: "rangers.locale" */
  rangers_locale: Array<Rangers_Locale>;
  /** fetch aggregated fields from the table: "rangers.locale" */
  rangers_locale_aggregate: Rangers_Locale_Aggregate;
  /** fetch data from the table: "rangers.locale" using primary key columns */
  rangers_locale_by_pk?: Maybe<Rangers_Locale>;
  /** fetch data from the table in a streaming manner: "rangers.locale" */
  rangers_locale_stream: Array<Rangers_Locale>;
  /** fetch data from the table: "rangers.pack" */
  rangers_pack: Array<Rangers_Pack>;
  /** fetch aggregated fields from the table: "rangers.pack" */
  rangers_pack_aggregate: Rangers_Pack_Aggregate;
  /** fetch data from the table: "rangers.pack" using primary key columns */
  rangers_pack_by_pk?: Maybe<Rangers_Pack>;
  /** fetch data from the table: "rangers.pack_localized" */
  rangers_pack_localized: Array<Rangers_Pack_Localized>;
  /** fetch aggregated fields from the table: "rangers.pack_localized" */
  rangers_pack_localized_aggregate: Rangers_Pack_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.pack_localized" */
  rangers_pack_localized_stream: Array<Rangers_Pack_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.pack" */
  rangers_pack_stream: Array<Rangers_Pack>;
  /** fetch data from the table: "rangers.pack_text" */
  rangers_pack_text: Array<Rangers_Pack_Text>;
  /** fetch aggregated fields from the table: "rangers.pack_text" */
  rangers_pack_text_aggregate: Rangers_Pack_Text_Aggregate;
  /** fetch data from the table: "rangers.pack_text" using primary key columns */
  rangers_pack_text_by_pk?: Maybe<Rangers_Pack_Text>;
  /** fetch data from the table in a streaming manner: "rangers.pack_text" */
  rangers_pack_text_stream: Array<Rangers_Pack_Text>;
  /** execute function "rangers.search_all_decks" which returns "rangers.search_deck" */
  rangers_search_all_decks: Array<Rangers_Search_Deck>;
  /** execute function "rangers.search_all_decks" and query aggregates on result of table type "rangers.search_deck" */
  rangers_search_all_decks_aggregate: Rangers_Search_Deck_Aggregate;
  /** fetch data from the table: "rangers.search_deck" */
  rangers_search_deck: Array<Rangers_Search_Deck>;
  /** fetch aggregated fields from the table: "rangers.search_deck" */
  rangers_search_deck_aggregate: Rangers_Search_Deck_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.search_deck" */
  rangers_search_deck_stream: Array<Rangers_Search_Deck>;
  /** fetch data from the table: "rangers.set" */
  rangers_set: Array<Rangers_Set>;
  /** fetch aggregated fields from the table: "rangers.set" */
  rangers_set_aggregate: Rangers_Set_Aggregate;
  /** fetch data from the table: "rangers.set" using primary key columns */
  rangers_set_by_pk?: Maybe<Rangers_Set>;
  /** fetch data from the table: "rangers.set_localized" */
  rangers_set_localized: Array<Rangers_Set_Localized>;
  /** fetch aggregated fields from the table: "rangers.set_localized" */
  rangers_set_localized_aggregate: Rangers_Set_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.set_localized" */
  rangers_set_localized_stream: Array<Rangers_Set_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.set" */
  rangers_set_stream: Array<Rangers_Set>;
  /** fetch data from the table: "rangers.set_text" */
  rangers_set_text: Array<Rangers_Set_Text>;
  /** fetch aggregated fields from the table: "rangers.set_text" */
  rangers_set_text_aggregate: Rangers_Set_Text_Aggregate;
  /** fetch data from the table: "rangers.set_text" using primary key columns */
  rangers_set_text_by_pk?: Maybe<Rangers_Set_Text>;
  /** fetch data from the table in a streaming manner: "rangers.set_text" */
  rangers_set_text_stream: Array<Rangers_Set_Text>;
  /** fetch data from the table: "rangers.set_type" */
  rangers_set_type: Array<Rangers_Set_Type>;
  /** fetch aggregated fields from the table: "rangers.set_type" */
  rangers_set_type_aggregate: Rangers_Set_Type_Aggregate;
  /** fetch data from the table: "rangers.set_type" using primary key columns */
  rangers_set_type_by_pk?: Maybe<Rangers_Set_Type>;
  /** fetch data from the table: "rangers.set_type_localized" */
  rangers_set_type_localized: Array<Rangers_Set_Type_Localized>;
  /** fetch aggregated fields from the table: "rangers.set_type_localized" */
  rangers_set_type_localized_aggregate: Rangers_Set_Type_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.set_type_localized" */
  rangers_set_type_localized_stream: Array<Rangers_Set_Type_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.set_type" */
  rangers_set_type_stream: Array<Rangers_Set_Type>;
  /** fetch data from the table: "rangers.set_type_text" */
  rangers_set_type_text: Array<Rangers_Set_Type_Text>;
  /** fetch aggregated fields from the table: "rangers.set_type_text" */
  rangers_set_type_text_aggregate: Rangers_Set_Type_Text_Aggregate;
  /** fetch data from the table: "rangers.set_type_text" using primary key columns */
  rangers_set_type_text_by_pk?: Maybe<Rangers_Set_Type_Text>;
  /** fetch data from the table in a streaming manner: "rangers.set_type_text" */
  rangers_set_type_text_stream: Array<Rangers_Set_Type_Text>;
  /** fetch data from the table: "rangers.subset" */
  rangers_subset: Array<Rangers_Subset>;
  /** fetch aggregated fields from the table: "rangers.subset" */
  rangers_subset_aggregate: Rangers_Subset_Aggregate;
  /** fetch data from the table: "rangers.subset" using primary key columns */
  rangers_subset_by_pk?: Maybe<Rangers_Subset>;
  /** fetch data from the table: "rangers.subset_localized" */
  rangers_subset_localized: Array<Rangers_Subset_Localized>;
  /** fetch aggregated fields from the table: "rangers.subset_localized" */
  rangers_subset_localized_aggregate: Rangers_Subset_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.subset_localized" */
  rangers_subset_localized_stream: Array<Rangers_Subset_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.subset" */
  rangers_subset_stream: Array<Rangers_Subset>;
  /** fetch data from the table: "rangers.subset_text" */
  rangers_subset_text: Array<Rangers_Subset_Text>;
  /** fetch aggregated fields from the table: "rangers.subset_text" */
  rangers_subset_text_aggregate: Rangers_Subset_Text_Aggregate;
  /** fetch data from the table: "rangers.subset_text" using primary key columns */
  rangers_subset_text_by_pk?: Maybe<Rangers_Subset_Text>;
  /** fetch data from the table in a streaming manner: "rangers.subset_text" */
  rangers_subset_text_stream: Array<Rangers_Subset_Text>;
  /** fetch data from the table: "rangers.taboo_set" */
  rangers_taboo_set: Array<Rangers_Taboo_Set>;
  /** fetch aggregated fields from the table: "rangers.taboo_set" */
  rangers_taboo_set_aggregate: Rangers_Taboo_Set_Aggregate;
  /** fetch data from the table: "rangers.taboo_set" using primary key columns */
  rangers_taboo_set_by_pk?: Maybe<Rangers_Taboo_Set>;
  /** fetch data from the table: "rangers.taboo_set_localized" */
  rangers_taboo_set_localized: Array<Rangers_Taboo_Set_Localized>;
  /** fetch aggregated fields from the table: "rangers.taboo_set_localized" */
  rangers_taboo_set_localized_aggregate: Rangers_Taboo_Set_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.taboo_set_localized" */
  rangers_taboo_set_localized_stream: Array<Rangers_Taboo_Set_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.taboo_set" */
  rangers_taboo_set_stream: Array<Rangers_Taboo_Set>;
  /** fetch data from the table: "rangers.taboo_set_text" */
  rangers_taboo_set_text: Array<Rangers_Taboo_Set_Text>;
  /** fetch aggregated fields from the table: "rangers.taboo_set_text" */
  rangers_taboo_set_text_aggregate: Rangers_Taboo_Set_Text_Aggregate;
  /** fetch data from the table: "rangers.taboo_set_text" using primary key columns */
  rangers_taboo_set_text_by_pk?: Maybe<Rangers_Taboo_Set_Text>;
  /** fetch data from the table in a streaming manner: "rangers.taboo_set_text" */
  rangers_taboo_set_text_stream: Array<Rangers_Taboo_Set_Text>;
  /** fetch data from the table: "rangers.token" */
  rangers_token: Array<Rangers_Token>;
  /** fetch aggregated fields from the table: "rangers.token" */
  rangers_token_aggregate: Rangers_Token_Aggregate;
  /** fetch data from the table: "rangers.token" using primary key columns */
  rangers_token_by_pk?: Maybe<Rangers_Token>;
  /** fetch data from the table in a streaming manner: "rangers.token" */
  rangers_token_stream: Array<Rangers_Token>;
  /** fetch data from the table: "rangers.token_text" */
  rangers_token_text: Array<Rangers_Token_Text>;
  /** fetch aggregated fields from the table: "rangers.token_text" */
  rangers_token_text_aggregate: Rangers_Token_Text_Aggregate;
  /** fetch data from the table: "rangers.token_text" using primary key columns */
  rangers_token_text_by_pk?: Maybe<Rangers_Token_Text>;
  /** fetch data from the table in a streaming manner: "rangers.token_text" */
  rangers_token_text_stream: Array<Rangers_Token_Text>;
  /** fetch data from the table: "rangers.type" */
  rangers_type: Array<Rangers_Type>;
  /** fetch aggregated fields from the table: "rangers.type" */
  rangers_type_aggregate: Rangers_Type_Aggregate;
  /** fetch data from the table: "rangers.type" using primary key columns */
  rangers_type_by_pk?: Maybe<Rangers_Type>;
  /** fetch data from the table: "rangers.type_localized" */
  rangers_type_localized: Array<Rangers_Type_Localized>;
  /** fetch aggregated fields from the table: "rangers.type_localized" */
  rangers_type_localized_aggregate: Rangers_Type_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.type_localized" */
  rangers_type_localized_stream: Array<Rangers_Type_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.type" */
  rangers_type_stream: Array<Rangers_Type>;
  /** fetch data from the table: "rangers.type_text" */
  rangers_type_text: Array<Rangers_Type_Text>;
  /** fetch aggregated fields from the table: "rangers.type_text" */
  rangers_type_text_aggregate: Rangers_Type_Text_Aggregate;
  /** fetch data from the table: "rangers.type_text" using primary key columns */
  rangers_type_text_by_pk?: Maybe<Rangers_Type_Text>;
  /** fetch data from the table in a streaming manner: "rangers.type_text" */
  rangers_type_text_stream: Array<Rangers_Type_Text>;
  /** fetch data from the table: "rangers.user_campaign" */
  rangers_user_campaign: Array<Rangers_User_Campaign>;
  /** fetch aggregated fields from the table: "rangers.user_campaign" */
  rangers_user_campaign_aggregate: Rangers_User_Campaign_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.user_campaign" */
  rangers_user_campaign_stream: Array<Rangers_User_Campaign>;
  /** fetch data from the table: "rangers.user_friends" */
  rangers_user_friends: Array<Rangers_User_Friends>;
  /** fetch aggregated fields from the table: "rangers.user_friends" */
  rangers_user_friends_aggregate: Rangers_User_Friends_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.user_friends" */
  rangers_user_friends_stream: Array<Rangers_User_Friends>;
  /** fetch data from the table: "rangers.user_received_friend_requests" */
  rangers_user_received_friend_requests: Array<Rangers_User_Received_Friend_Requests>;
  /** fetch aggregated fields from the table: "rangers.user_received_friend_requests" */
  rangers_user_received_friend_requests_aggregate: Rangers_User_Received_Friend_Requests_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.user_received_friend_requests" */
  rangers_user_received_friend_requests_stream: Array<Rangers_User_Received_Friend_Requests>;
  /** fetch data from the table: "rangers.user_role" */
  rangers_user_role: Array<Rangers_User_Role>;
  /** fetch aggregated fields from the table: "rangers.user_role" */
  rangers_user_role_aggregate: Rangers_User_Role_Aggregate;
  /** fetch data from the table: "rangers.user_role" using primary key columns */
  rangers_user_role_by_pk?: Maybe<Rangers_User_Role>;
  /** fetch data from the table in a streaming manner: "rangers.user_role" */
  rangers_user_role_stream: Array<Rangers_User_Role>;
  /** fetch data from the table: "rangers.user_sent_friend_requests" */
  rangers_user_sent_friend_requests: Array<Rangers_User_Sent_Friend_Requests>;
  /** fetch aggregated fields from the table: "rangers.user_sent_friend_requests" */
  rangers_user_sent_friend_requests_aggregate: Rangers_User_Sent_Friend_Requests_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.user_sent_friend_requests" */
  rangers_user_sent_friend_requests_stream: Array<Rangers_User_Sent_Friend_Requests>;
  /** fetch data from the table: "rangers.user_settings" */
  rangers_user_settings: Array<Rangers_User_Settings>;
  /** fetch aggregated fields from the table: "rangers.user_settings" */
  rangers_user_settings_aggregate: Rangers_User_Settings_Aggregate;
  /** fetch data from the table: "rangers.user_settings" using primary key columns */
  rangers_user_settings_by_pk?: Maybe<Rangers_User_Settings>;
  /** fetch data from the table in a streaming manner: "rangers.user_settings" */
  rangers_user_settings_stream: Array<Rangers_User_Settings>;
  /** fetch data from the table: "rangers.users" */
  rangers_users: Array<Rangers_Users>;
  /** fetch aggregated fields from the table: "rangers.users" */
  rangers_users_aggregate: Rangers_Users_Aggregate;
  /** fetch data from the table: "rangers.users" using primary key columns */
  rangers_users_by_pk?: Maybe<Rangers_Users>;
  /** fetch data from the table in a streaming manner: "rangers.users" */
  rangers_users_stream: Array<Rangers_Users>;
  /** fetch data from the table: "taboo_set" */
  taboo_set: Array<Taboo_Set>;
  /** fetch aggregated fields from the table: "taboo_set" */
  taboo_set_aggregate: Taboo_Set_Aggregate;
  /** fetch data from the table: "taboo_set" using primary key columns */
  taboo_set_by_pk?: Maybe<Taboo_Set>;
  /** fetch data from the table in a streaming manner: "taboo_set" */
  taboo_set_stream: Array<Taboo_Set>;
  /** fetch data from the table: "user_campaigns" */
  user_campaigns: Array<User_Campaigns>;
  /** fetch aggregated fields from the table: "user_campaigns" */
  user_campaigns_aggregate: User_Campaigns_Aggregate;
  /** fetch data from the table in a streaming manner: "user_campaigns" */
  user_campaigns_stream: Array<User_Campaigns>;
  /** fetch data from the table: "user_flag" */
  user_flag: Array<User_Flag>;
  /** fetch aggregated fields from the table: "user_flag" */
  user_flag_aggregate: User_Flag_Aggregate;
  /** fetch data from the table: "user_flag" using primary key columns */
  user_flag_by_pk?: Maybe<User_Flag>;
  /** fetch data from the table in a streaming manner: "user_flag" */
  user_flag_stream: Array<User_Flag>;
  /** fetch data from the table: "user_flag_type" */
  user_flag_type: Array<User_Flag_Type>;
  /** fetch aggregated fields from the table: "user_flag_type" */
  user_flag_type_aggregate: User_Flag_Type_Aggregate;
  /** fetch data from the table: "user_flag_type" using primary key columns */
  user_flag_type_by_pk?: Maybe<User_Flag_Type>;
  /** fetch data from the table in a streaming manner: "user_flag_type" */
  user_flag_type_stream: Array<User_Flag_Type>;
  /** fetch data from the table: "user_friends" */
  user_friends: Array<User_Friends>;
  /** fetch aggregated fields from the table: "user_friends" */
  user_friends_aggregate: User_Friends_Aggregate;
  /** fetch data from the table in a streaming manner: "user_friends" */
  user_friends_stream: Array<User_Friends>;
  /** fetch data from the table: "user_received_friend_requests" */
  user_received_friend_requests: Array<User_Received_Friend_Requests>;
  /** fetch aggregated fields from the table: "user_received_friend_requests" */
  user_received_friend_requests_aggregate: User_Received_Friend_Requests_Aggregate;
  /** fetch data from the table in a streaming manner: "user_received_friend_requests" */
  user_received_friend_requests_stream: Array<User_Received_Friend_Requests>;
  /** fetch data from the table: "user_sent_friend_requests" */
  user_sent_friend_requests: Array<User_Sent_Friend_Requests>;
  /** fetch aggregated fields from the table: "user_sent_friend_requests" */
  user_sent_friend_requests_aggregate: User_Sent_Friend_Requests_Aggregate;
  /** fetch data from the table in a streaming manner: "user_sent_friend_requests" */
  user_sent_friend_requests_stream: Array<User_Sent_Friend_Requests>;
  /** fetch data from the table: "user_settings" */
  user_settings: Array<User_Settings>;
  /** fetch aggregated fields from the table: "user_settings" */
  user_settings_aggregate: User_Settings_Aggregate;
  /** fetch data from the table: "user_settings" using primary key columns */
  user_settings_by_pk?: Maybe<User_Settings>;
  /** fetch data from the table in a streaming manner: "user_settings" */
  user_settings_stream: Array<User_Settings>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table in a streaming manner: "users" */
  users_stream: Array<Users>;
};


export type Subscription_RootAll_CardArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


export type Subscription_RootAll_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


export type Subscription_RootAll_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootAll_Card_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<All_Card_Stream_Cursor_Input>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


export type Subscription_RootAll_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


export type Subscription_RootAll_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


export type Subscription_RootAll_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootAll_Card_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<All_Card_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


export type Subscription_RootAll_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_Order_By>>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};


export type Subscription_RootAll_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_Order_By>>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};


export type Subscription_RootAll_Card_Updated_By_PkArgs = {
  locale: Scalars['String']['input'];
};


export type Subscription_RootAll_Card_Updated_By_VersionArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_By_Version_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_By_Version_Order_By>>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};


export type Subscription_RootAll_Card_Updated_By_Version_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_By_Version_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_By_Version_Order_By>>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};


export type Subscription_RootAll_Card_Updated_By_Version_By_PkArgs = {
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
};


export type Subscription_RootAll_Card_Updated_By_Version_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<All_Card_Updated_By_Version_Stream_Cursor_Input>>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};


export type Subscription_RootAll_Card_Updated_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<All_Card_Updated_Stream_Cursor_Input>>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};


export type Subscription_RootArkhamdb_AuthArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Auth_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Auth_Order_By>>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};


export type Subscription_RootArkhamdb_Auth_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Auth_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Auth_Order_By>>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};


export type Subscription_RootArkhamdb_Auth_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Subscription_RootArkhamdb_Auth_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Arkhamdb_Auth_Stream_Cursor_Input>>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};


export type Subscription_RootArkhamdb_DeckArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Deck_Order_By>>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};


export type Subscription_RootArkhamdb_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Deck_Order_By>>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};


export type Subscription_RootArkhamdb_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootArkhamdb_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Arkhamdb_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};


export type Subscription_RootBase_DecksArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


export type Subscription_RootBase_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


export type Subscription_RootBase_Decks_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Base_Decks_Stream_Cursor_Input>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


export type Subscription_RootCampaignArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Order_By>>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};


export type Subscription_RootCampaign_AccessArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


export type Subscription_RootCampaign_Access_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


export type Subscription_RootCampaign_Access_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootCampaign_Access_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Access_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


export type Subscription_RootCampaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Order_By>>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};


export type Subscription_RootCampaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootCampaign_DeckArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


export type Subscription_RootCampaign_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


export type Subscription_RootCampaign_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootCampaign_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


export type Subscription_RootCampaign_DifficultyArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Difficulty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Difficulty_Order_By>>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};


export type Subscription_RootCampaign_Difficulty_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Difficulty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Difficulty_Order_By>>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};


export type Subscription_RootCampaign_Difficulty_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootCampaign_Difficulty_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Difficulty_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};


export type Subscription_RootCampaign_GuideArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Guide_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Guide_Order_By>>;
  where?: InputMaybe<Campaign_Guide_Bool_Exp>;
};


export type Subscription_RootCampaign_Guide_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Guide_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Guide_Order_By>>;
  where?: InputMaybe<Campaign_Guide_Bool_Exp>;
};


export type Subscription_RootCampaign_Guide_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Guide_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Guide_Bool_Exp>;
};


export type Subscription_RootCampaign_InvestigatorArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


export type Subscription_RootCampaign_Investigator_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


export type Subscription_RootCampaign_Investigator_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


export type Subscription_RootCampaign_Investigator_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Investigator_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


export type Subscription_RootCampaign_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};


export type Subscription_RootCampaigns_By_CycleArgs = {
  distinct_on?: InputMaybe<Array<Campaigns_By_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaigns_By_Cycle_Order_By>>;
  where?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
};


export type Subscription_RootCampaigns_By_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaigns_By_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaigns_By_Cycle_Order_By>>;
  where?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
};


export type Subscription_RootCampaigns_By_Cycle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaigns_By_Cycle_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
};


export type Subscription_RootCardArgs = {
  distinct_on?: InputMaybe<Array<Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Order_By>>;
  where?: InputMaybe<Card_Bool_Exp>;
};


export type Subscription_RootCard_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Order_By>>;
  where?: InputMaybe<Card_Bool_Exp>;
};


export type Subscription_RootCard_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootCard_CycleArgs = {
  distinct_on?: InputMaybe<Array<Card_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Cycle_Order_By>>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};


export type Subscription_RootCard_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Cycle_Order_By>>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};


export type Subscription_RootCard_Cycle_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Cycle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Cycle_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};


export type Subscription_RootCard_Encounter_SetArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


export type Subscription_RootCard_Encounter_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


export type Subscription_RootCard_Encounter_Set_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Encounter_Set_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Encounter_Set_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


export type Subscription_RootCard_PackArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


export type Subscription_RootCard_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


export type Subscription_RootCard_Pack_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Pack_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Pack_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


export type Subscription_RootCard_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Bool_Exp>;
};


export type Subscription_RootCard_Subtype_NameArgs = {
  distinct_on?: InputMaybe<Array<Card_Subtype_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Subtype_Name_Order_By>>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};


export type Subscription_RootCard_Subtype_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Subtype_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Subtype_Name_Order_By>>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};


export type Subscription_RootCard_Subtype_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Subtype_Name_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Subtype_Name_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};


export type Subscription_RootCard_TextArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


export type Subscription_RootCard_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


export type Subscription_RootCard_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


export type Subscription_RootCard_Type_CodeArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Code_Order_By>>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};


export type Subscription_RootCard_Type_Code_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Code_Order_By>>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};


export type Subscription_RootCard_Type_Code_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootCard_Type_Code_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Type_Code_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};


export type Subscription_RootCard_Type_NameArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Name_Order_By>>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};


export type Subscription_RootCard_Type_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Name_Order_By>>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};


export type Subscription_RootCard_Type_Name_By_PkArgs = {
  code: Card_Type_Code_Enum;
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Type_Name_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Type_Name_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_ResultArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_Result_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_Result_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootChaos_Bag_Result_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Chaos_Bag_Result_Stream_Cursor_Input>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_Tarot_ModeArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_Tarot_Mode_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_Tarot_Mode_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootChaos_Bag_Tarot_Mode_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Chaos_Bag_Tarot_Mode_Stream_Cursor_Input>>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};


export type Subscription_RootConquest_CardArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Order_By>>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};


export type Subscription_RootConquest_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Order_By>>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};


export type Subscription_RootConquest_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Card_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Localized_Order_By>>;
  where?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Localized_Order_By>>;
  where?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Card_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
};


export type Subscription_RootConquest_Card_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Card_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};


export type Subscription_RootConquest_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Text_Order_By>>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Text_Order_By>>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Card_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Card_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Updated_Order_By>>;
  where?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Updated_Order_By>>;
  where?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Updated_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Card_Updated_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
};


export type Subscription_RootConquest_CommentArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


export type Subscription_RootConquest_Comment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


export type Subscription_RootConquest_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootConquest_Comment_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Comment_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


export type Subscription_RootConquest_CycleArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};


export type Subscription_RootConquest_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};


export type Subscription_RootConquest_Cycle_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Cycle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Cycle_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};


export type Subscription_RootConquest_Cycle_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Text_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Cycle_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Text_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Cycle_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Cycle_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Cycle_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};


export type Subscription_RootConquest_DeckArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootConquest_Deck_CopyArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Copy_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_Copy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Copy_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


export type Subscription_RootConquest_Deck_Copy_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Deck_Copy_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_LikeArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Like_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_Like_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Like_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Deck_Like_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Deck_Like_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


export type Subscription_RootConquest_FactionArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};


export type Subscription_RootConquest_Faction_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};


export type Subscription_RootConquest_Faction_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Faction_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Faction_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};


export type Subscription_RootConquest_Faction_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Text_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Faction_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Text_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Faction_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Faction_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Faction_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};


export type Subscription_RootConquest_LoyaltyArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};


export type Subscription_RootConquest_Loyalty_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};


export type Subscription_RootConquest_Loyalty_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Loyalty_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Loyalty_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};


export type Subscription_RootConquest_Loyalty_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Text_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Loyalty_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Text_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Loyalty_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Loyalty_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Loyalty_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};


export type Subscription_RootConquest_PackArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};


export type Subscription_RootConquest_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};


export type Subscription_RootConquest_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Pack_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Pack_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};


export type Subscription_RootConquest_Pack_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Text_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Pack_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Text_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Pack_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Pack_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};


export type Subscription_RootConquest_TypeArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Order_By>>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};


export type Subscription_RootConquest_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Order_By>>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};


export type Subscription_RootConquest_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};


export type Subscription_RootConquest_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Text_Order_By>>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Text_Order_By>>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Type_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Type_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};


export type Subscription_RootConquest_User_RoleArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Role_Order_By>>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};


export type Subscription_RootConquest_User_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Role_Order_By>>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};


export type Subscription_RootConquest_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_User_Role_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_User_Role_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};


export type Subscription_RootConquest_User_SettingsArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


export type Subscription_RootConquest_User_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


export type Subscription_RootConquest_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Subscription_RootConquest_User_Settings_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_User_Settings_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


export type Subscription_RootConquest_UsersArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Users_Order_By>>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};


export type Subscription_RootConquest_Users_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Users_Order_By>>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};


export type Subscription_RootConquest_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Users_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Users_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};


export type Subscription_RootCycleArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Order_By>>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};


export type Subscription_RootCycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Order_By>>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};


export type Subscription_RootCycle_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootCycle_NameArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


export type Subscription_RootCycle_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


export type Subscription_RootCycle_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCycle_Name_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Cycle_Name_Stream_Cursor_Input>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


export type Subscription_RootCycle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Cycle_Stream_Cursor_Input>>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};


export type Subscription_RootFaction_NameArgs = {
  distinct_on?: InputMaybe<Array<Faction_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faction_Name_Order_By>>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};


export type Subscription_RootFaction_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faction_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faction_Name_Order_By>>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};


export type Subscription_RootFaction_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootFaction_Name_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Faction_Name_Stream_Cursor_Input>>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};


export type Subscription_RootFaqArgs = {
  distinct_on?: InputMaybe<Array<Faq_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Order_By>>;
  where?: InputMaybe<Faq_Bool_Exp>;
};


export type Subscription_RootFaq_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faq_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Order_By>>;
  where?: InputMaybe<Faq_Bool_Exp>;
};


export type Subscription_RootFaq_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootFaq_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Faq_Stream_Cursor_Input>>;
  where?: InputMaybe<Faq_Bool_Exp>;
};


export type Subscription_RootFaq_TextArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


export type Subscription_RootFaq_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


export type Subscription_RootFaq_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootFaq_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Faq_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


export type Subscription_RootFriend_StatusArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Order_By>>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};


export type Subscription_RootFriend_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Order_By>>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};


export type Subscription_RootFriend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


export type Subscription_RootFriend_Status_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Friend_Status_Stream_Cursor_Input>>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};


export type Subscription_RootFriend_Status_TypeArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootFriend_Status_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootFriend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootFriend_Status_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Friend_Status_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootFull_CardArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Order_By>>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};


export type Subscription_RootFull_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Order_By>>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};


export type Subscription_RootFull_Card_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootFull_Card_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Full_Card_Stream_Cursor_Input>>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};


export type Subscription_RootFull_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


export type Subscription_RootFull_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


export type Subscription_RootFull_Card_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootFull_Card_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Full_Card_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


export type Subscription_RootGenderArgs = {
  distinct_on?: InputMaybe<Array<Gender_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Gender_Order_By>>;
  where?: InputMaybe<Gender_Bool_Exp>;
};


export type Subscription_RootGender_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Gender_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Gender_Order_By>>;
  where?: InputMaybe<Gender_Bool_Exp>;
};


export type Subscription_RootGender_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootGender_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Gender_Stream_Cursor_Input>>;
  where?: InputMaybe<Gender_Bool_Exp>;
};


export type Subscription_RootGuide_AchievementArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


export type Subscription_RootGuide_Achievement_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


export type Subscription_RootGuide_Achievement_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


export type Subscription_RootGuide_Achievement_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Guide_Achievement_Stream_Cursor_Input>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


export type Subscription_RootGuide_InputArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


export type Subscription_RootGuide_Input_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


export type Subscription_RootGuide_Input_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


export type Subscription_RootGuide_Input_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Guide_Input_Stream_Cursor_Input>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


export type Subscription_RootInvestigator_DataArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


export type Subscription_RootInvestigator_Data_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


export type Subscription_RootInvestigator_Data_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


export type Subscription_RootInvestigator_Data_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Investigator_Data_Stream_Cursor_Input>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


export type Subscription_RootLatest_DecksArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


export type Subscription_RootLatest_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


export type Subscription_RootLatest_Decks_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Latest_Decks_Stream_Cursor_Input>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


export type Subscription_RootLocal_DecksArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


export type Subscription_RootLocal_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


export type Subscription_RootLocal_Decks_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Local_Decks_Stream_Cursor_Input>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


export type Subscription_RootPackArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


export type Subscription_RootPack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


export type Subscription_RootPack_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootPack_NameArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


export type Subscription_RootPack_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


export type Subscription_RootPack_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootPack_Name_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Pack_Name_Stream_Cursor_Input>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


export type Subscription_RootPack_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Pack_Stream_Cursor_Input>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


export type Subscription_RootRangers_AreaArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Order_By>>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};


export type Subscription_RootRangers_Area_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Order_By>>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};


export type Subscription_RootRangers_Area_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Area_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Area_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};


export type Subscription_RootRangers_Area_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Text_Order_By>>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Area_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Text_Order_By>>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Area_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Area_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Area_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};


export type Subscription_RootRangers_AspectArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Aspect_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Aspect_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Aspect_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Text_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Text_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Aspect_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Aspect_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};


export type Subscription_RootRangers_CampaignArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_Campaign_AccessArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Access_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};


export type Subscription_RootRangers_Campaign_Access_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Access_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};


export type Subscription_RootRangers_Campaign_Access_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Campaign_Access_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Campaign_Access_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};


export type Subscription_RootRangers_Campaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_Campaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootRangers_Campaign_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Campaign_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_CardArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Order_By>>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};


export type Subscription_RootRangers_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Order_By>>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};


export type Subscription_RootRangers_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Card_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Card_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Card_SearchArgs = {
  args?: InputMaybe<Rangers_Card_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Search_AggregateArgs = {
  args?: InputMaybe<Rangers_Card_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Card_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Card_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};


export type Subscription_RootRangers_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Card_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Card_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Updated_Order_By>>;
  where?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Updated_Order_By>>;
  where?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Updated_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Card_Updated_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
};


export type Subscription_RootRangers_CommentArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


export type Subscription_RootRangers_Comment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


export type Subscription_RootRangers_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootRangers_Comment_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Comment_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


export type Subscription_RootRangers_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootRangers_Deck_CopyArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Copy_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Copy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Copy_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


export type Subscription_RootRangers_Deck_Copy_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Deck_Copy_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_LikeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Like_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Deck_Like_CountArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Count_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Count_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Like_Count_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Count_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Count_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Like_Count_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
};


export type Subscription_RootRangers_Deck_Like_Count_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Deck_Like_Count_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Like_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Deck_Like_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_RankArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Rank_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Rank_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Rank_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Rank_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Rank_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Rank_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Deck_Rank_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_SearchArgs = {
  args?: InputMaybe<Rangers_Deck_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Search_AggregateArgs = {
  args?: InputMaybe<Rangers_Deck_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Faq_EntryArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Faq_Entry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Faq_Entry_Order_By>>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};


export type Subscription_RootRangers_Faq_Entry_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Faq_Entry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Faq_Entry_Order_By>>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};


export type Subscription_RootRangers_Faq_Entry_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Faq_Entry_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Faq_Entry_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_StatusArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


export type Subscription_RootRangers_Friend_Status_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Friend_Status_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_Status_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_Status_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootRangers_Friend_Status_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Friend_Status_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Latest_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Latest_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Latest_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Latest_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_LocaleArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Locale_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Locale_Order_By>>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};


export type Subscription_RootRangers_Locale_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Locale_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Locale_Order_By>>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};


export type Subscription_RootRangers_Locale_By_PkArgs = {
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Locale_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Locale_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};


export type Subscription_RootRangers_PackArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Pack_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Pack_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Pack_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Pack_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Pack_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Pack_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Search_All_DecksArgs = {
  args?: InputMaybe<Rangers_Search_All_Decks_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Search_All_Decks_AggregateArgs = {
  args?: InputMaybe<Rangers_Search_All_Decks_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Search_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Search_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Search_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Search_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_SetArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Order_By>>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};


export type Subscription_RootRangers_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Order_By>>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};


export type Subscription_RootRangers_Set_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Set_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};


export type Subscription_RootRangers_Set_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Set_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Set_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Set_Type_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Type_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Set_Type_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Type_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_SubsetArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Bool_Exp>;
};


export type Subscription_RootRangers_Subset_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Bool_Exp>;
};


export type Subscription_RootRangers_Subset_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Subset_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Subset_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Subset_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Subset_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Subset_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Subset_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Subset_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Subset_Bool_Exp>;
};


export type Subscription_RootRangers_Subset_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Text_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Subset_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Subset_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Subset_Text_Order_By>>;
  where?: InputMaybe<Rangers_Subset_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Subset_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Subset_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Subset_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Subset_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Taboo_SetArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Bool_Exp>;
};


export type Subscription_RootRangers_Taboo_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Bool_Exp>;
};


export type Subscription_RootRangers_Taboo_Set_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Taboo_Set_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Taboo_Set_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Taboo_Set_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Taboo_Set_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Taboo_Set_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Taboo_Set_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Taboo_Set_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Taboo_Set_Bool_Exp>;
};


export type Subscription_RootRangers_Taboo_Set_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Taboo_Set_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Taboo_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Taboo_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Taboo_Set_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Taboo_Set_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Taboo_Set_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Taboo_Set_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Taboo_Set_Text_Bool_Exp>;
};


export type Subscription_RootRangers_TokenArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Order_By>>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};


export type Subscription_RootRangers_Token_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Order_By>>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};


export type Subscription_RootRangers_Token_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Token_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Token_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};


export type Subscription_RootRangers_Token_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Text_Order_By>>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Token_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Text_Order_By>>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Token_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Token_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Token_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};


export type Subscription_RootRangers_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Order_By>>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Order_By>>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Type_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Type_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Type_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Type_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Type_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Type_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_User_CampaignArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_User_Campaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_User_Campaign_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Campaign_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_User_FriendsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


export type Subscription_RootRangers_User_Friends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


export type Subscription_RootRangers_User_Friends_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Friends_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


export type Subscription_RootRangers_User_Received_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_Received_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_Received_Friend_Requests_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Received_Friend_Requests_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_RoleArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Role_Order_By>>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};


export type Subscription_RootRangers_User_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Role_Order_By>>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};


export type Subscription_RootRangers_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_User_Role_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Role_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};


export type Subscription_RootRangers_User_Sent_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_Sent_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_Sent_Friend_Requests_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Sent_Friend_Requests_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_SettingsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Settings_Order_By>>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};


export type Subscription_RootRangers_User_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Settings_Order_By>>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};


export type Subscription_RootRangers_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Subscription_RootRangers_User_Settings_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Settings_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};


export type Subscription_RootRangers_UsersArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Users_Order_By>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


export type Subscription_RootRangers_Users_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Users_Order_By>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


export type Subscription_RootRangers_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Users_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Users_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


export type Subscription_RootTaboo_SetArgs = {
  distinct_on?: InputMaybe<Array<Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Taboo_Set_Order_By>>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};


export type Subscription_RootTaboo_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Taboo_Set_Order_By>>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};


export type Subscription_RootTaboo_Set_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootTaboo_Set_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Taboo_Set_Stream_Cursor_Input>>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};


export type Subscription_RootUser_CampaignsArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


export type Subscription_RootUser_Campaigns_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


export type Subscription_RootUser_Campaigns_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Campaigns_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


export type Subscription_RootUser_FlagArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


export type Subscription_RootUser_Flag_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


export type Subscription_RootUser_Flag_By_PkArgs = {
  flag: User_Flag_Type_Enum;
  user_id: Scalars['String']['input'];
};


export type Subscription_RootUser_Flag_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Flag_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


export type Subscription_RootUser_Flag_TypeArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Type_Order_By>>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};


export type Subscription_RootUser_Flag_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Type_Order_By>>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};


export type Subscription_RootUser_Flag_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootUser_Flag_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Flag_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};


export type Subscription_RootUser_FriendsArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


export type Subscription_RootUser_Friends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


export type Subscription_RootUser_Friends_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Friends_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


export type Subscription_RootUser_Received_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_Received_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_Received_Friend_Requests_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Received_Friend_Requests_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_Sent_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_Sent_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_Sent_Friend_Requests_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Sent_Friend_Requests_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_SettingsArgs = {
  distinct_on?: InputMaybe<Array<User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Settings_Order_By>>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};


export type Subscription_RootUser_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Settings_Order_By>>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};


export type Subscription_RootUser_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Subscription_RootUser_Settings_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Settings_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};


export type Subscription_RootUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootUsers_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Users_Stream_Cursor_Input>>;
  where?: InputMaybe<Users_Bool_Exp>;
};

/** columns and relationships of "taboo_set" */
export type Taboo_Set = {
  __typename?: 'taboo_set';
  active: Scalars['Boolean']['output'];
  card_count: Scalars['Int']['output'];
  /** An array relationship */
  cards: Array<All_Card>;
  /** An aggregate relationship */
  cards_aggregate: All_Card_Aggregate;
  code: Scalars['String']['output'];
  current: Scalars['Boolean']['output'];
  date: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "taboo_set" */
export type Taboo_SetCardsArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


/** columns and relationships of "taboo_set" */
export type Taboo_SetCards_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};

/** aggregated selection of "taboo_set" */
export type Taboo_Set_Aggregate = {
  __typename?: 'taboo_set_aggregate';
  aggregate?: Maybe<Taboo_Set_Aggregate_Fields>;
  nodes: Array<Taboo_Set>;
};

/** aggregate fields of "taboo_set" */
export type Taboo_Set_Aggregate_Fields = {
  __typename?: 'taboo_set_aggregate_fields';
  avg?: Maybe<Taboo_Set_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Taboo_Set_Max_Fields>;
  min?: Maybe<Taboo_Set_Min_Fields>;
  stddev?: Maybe<Taboo_Set_Stddev_Fields>;
  stddev_pop?: Maybe<Taboo_Set_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Taboo_Set_Stddev_Samp_Fields>;
  sum?: Maybe<Taboo_Set_Sum_Fields>;
  var_pop?: Maybe<Taboo_Set_Var_Pop_Fields>;
  var_samp?: Maybe<Taboo_Set_Var_Samp_Fields>;
  variance?: Maybe<Taboo_Set_Variance_Fields>;
};


/** aggregate fields of "taboo_set" */
export type Taboo_Set_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Taboo_Set_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Taboo_Set_Avg_Fields = {
  __typename?: 'taboo_set_avg_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "taboo_set". All fields are combined with a logical 'AND'. */
export type Taboo_Set_Bool_Exp = {
  _and?: InputMaybe<Array<Taboo_Set_Bool_Exp>>;
  _not?: InputMaybe<Taboo_Set_Bool_Exp>;
  _or?: InputMaybe<Array<Taboo_Set_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  card_count?: InputMaybe<Int_Comparison_Exp>;
  cards?: InputMaybe<All_Card_Bool_Exp>;
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  current?: InputMaybe<Boolean_Comparison_Exp>;
  date?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "taboo_set" */
export enum Taboo_Set_Constraint {
  /** unique or primary key constraint on columns "id" */
  TabooSetPkey = 'taboo_set_pkey'
}

/** input type for incrementing numeric columns in table "taboo_set" */
export type Taboo_Set_Inc_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "taboo_set" */
export type Taboo_Set_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards?: InputMaybe<All_Card_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  current?: InputMaybe<Scalars['Boolean']['input']>;
  date?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Taboo_Set_Max_Fields = {
  __typename?: 'taboo_set_max_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  date?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Taboo_Set_Min_Fields = {
  __typename?: 'taboo_set_min_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  date?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "taboo_set" */
export type Taboo_Set_Mutation_Response = {
  __typename?: 'taboo_set_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Taboo_Set>;
};

/** input type for inserting object relation for remote table "taboo_set" */
export type Taboo_Set_Obj_Rel_Insert_Input = {
  data: Taboo_Set_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Taboo_Set_On_Conflict>;
};

/** on_conflict condition type for table "taboo_set" */
export type Taboo_Set_On_Conflict = {
  constraint: Taboo_Set_Constraint;
  update_columns?: Array<Taboo_Set_Update_Column>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};

/** Ordering options when selecting data from "taboo_set". */
export type Taboo_Set_Order_By = {
  active?: InputMaybe<Order_By>;
  card_count?: InputMaybe<Order_By>;
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  current?: InputMaybe<Order_By>;
  date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: taboo_set */
export type Taboo_Set_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "taboo_set" */
export enum Taboo_Set_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  CardCount = 'card_count',
  /** column name */
  Code = 'code',
  /** column name */
  Current = 'current',
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "taboo_set" */
export type Taboo_Set_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  card_count?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  current?: InputMaybe<Scalars['Boolean']['input']>;
  date?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Taboo_Set_Stddev_Fields = {
  __typename?: 'taboo_set_stddev_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Taboo_Set_Stddev_Pop_Fields = {
  __typename?: 'taboo_set_stddev_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Taboo_Set_Stddev_Samp_Fields = {
  __typename?: 'taboo_set_stddev_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "taboo_set" */
export type Taboo_Set_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Taboo_Set_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Taboo_Set_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  card_count?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  current?: InputMaybe<Scalars['Boolean']['input']>;
  date?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Taboo_Set_Sum_Fields = {
  __typename?: 'taboo_set_sum_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "taboo_set" */
export enum Taboo_Set_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  CardCount = 'card_count',
  /** column name */
  Code = 'code',
  /** column name */
  Current = 'current',
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

export type Taboo_Set_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Taboo_Set_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Taboo_Set_Set_Input>;
  /** filter the rows which have to be updated */
  where: Taboo_Set_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Taboo_Set_Var_Pop_Fields = {
  __typename?: 'taboo_set_var_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Taboo_Set_Var_Samp_Fields = {
  __typename?: 'taboo_set_var_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Taboo_Set_Variance_Fields = {
  __typename?: 'taboo_set_variance_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamp']['input']>;
  _gt?: InputMaybe<Scalars['timestamp']['input']>;
  _gte?: InputMaybe<Scalars['timestamp']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamp']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamp']['input']>;
  _lte?: InputMaybe<Scalars['timestamp']['input']>;
  _neq?: InputMaybe<Scalars['timestamp']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']['input']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamptz']['input']>;
  _gt?: InputMaybe<Scalars['timestamptz']['input']>;
  _gte?: InputMaybe<Scalars['timestamptz']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamptz']['input']>;
  _lte?: InputMaybe<Scalars['timestamptz']['input']>;
  _neq?: InputMaybe<Scalars['timestamptz']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
};

/** columns and relationships of "user_campaigns" */
export type User_Campaigns = {
  __typename?: 'user_campaigns';
  /** An object relationship */
  campaign?: Maybe<Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "user_campaigns" */
export type User_Campaigns_Aggregate = {
  __typename?: 'user_campaigns_aggregate';
  aggregate?: Maybe<User_Campaigns_Aggregate_Fields>;
  nodes: Array<User_Campaigns>;
};

export type User_Campaigns_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Campaigns_Aggregate_Bool_Exp_Count>;
};

export type User_Campaigns_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Campaigns_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_campaigns" */
export type User_Campaigns_Aggregate_Fields = {
  __typename?: 'user_campaigns_aggregate_fields';
  avg?: Maybe<User_Campaigns_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<User_Campaigns_Max_Fields>;
  min?: Maybe<User_Campaigns_Min_Fields>;
  stddev?: Maybe<User_Campaigns_Stddev_Fields>;
  stddev_pop?: Maybe<User_Campaigns_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<User_Campaigns_Stddev_Samp_Fields>;
  sum?: Maybe<User_Campaigns_Sum_Fields>;
  var_pop?: Maybe<User_Campaigns_Var_Pop_Fields>;
  var_samp?: Maybe<User_Campaigns_Var_Samp_Fields>;
  variance?: Maybe<User_Campaigns_Variance_Fields>;
};


/** aggregate fields of "user_campaigns" */
export type User_Campaigns_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_campaigns" */
export type User_Campaigns_Aggregate_Order_By = {
  avg?: InputMaybe<User_Campaigns_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Campaigns_Max_Order_By>;
  min?: InputMaybe<User_Campaigns_Min_Order_By>;
  stddev?: InputMaybe<User_Campaigns_Stddev_Order_By>;
  stddev_pop?: InputMaybe<User_Campaigns_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<User_Campaigns_Stddev_Samp_Order_By>;
  sum?: InputMaybe<User_Campaigns_Sum_Order_By>;
  var_pop?: InputMaybe<User_Campaigns_Var_Pop_Order_By>;
  var_samp?: InputMaybe<User_Campaigns_Var_Samp_Order_By>;
  variance?: InputMaybe<User_Campaigns_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_campaigns" */
export type User_Campaigns_Arr_Rel_Insert_Input = {
  data: Array<User_Campaigns_Insert_Input>;
};

/** aggregate avg on columns */
export type User_Campaigns_Avg_Fields = {
  __typename?: 'user_campaigns_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_campaigns" */
export type User_Campaigns_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_campaigns". All fields are combined with a logical 'AND'. */
export type User_Campaigns_Bool_Exp = {
  _and?: InputMaybe<Array<User_Campaigns_Bool_Exp>>;
  _not?: InputMaybe<User_Campaigns_Bool_Exp>;
  _or?: InputMaybe<Array<User_Campaigns_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "user_campaigns" */
export type User_Campaigns_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "user_campaigns" */
export type User_Campaigns_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Campaigns_Max_Fields = {
  __typename?: 'user_campaigns_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "user_campaigns" */
export type User_Campaigns_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Campaigns_Min_Fields = {
  __typename?: 'user_campaigns_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "user_campaigns" */
export type User_Campaigns_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_campaigns" */
export type User_Campaigns_Mutation_Response = {
  __typename?: 'user_campaigns_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Campaigns>;
};

/** Ordering options when selecting data from "user_campaigns". */
export type User_Campaigns_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** select columns of table "user_campaigns" */
export enum User_Campaigns_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Id = 'id',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "user_campaigns" */
export type User_Campaigns_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type User_Campaigns_Stddev_Fields = {
  __typename?: 'user_campaigns_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_campaigns" */
export type User_Campaigns_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Campaigns_Stddev_Pop_Fields = {
  __typename?: 'user_campaigns_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_campaigns" */
export type User_Campaigns_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Campaigns_Stddev_Samp_Fields = {
  __typename?: 'user_campaigns_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_campaigns" */
export type User_Campaigns_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "user_campaigns" */
export type User_Campaigns_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Campaigns_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Campaigns_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type User_Campaigns_Sum_Fields = {
  __typename?: 'user_campaigns_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "user_campaigns" */
export type User_Campaigns_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

export type User_Campaigns_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<User_Campaigns_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Campaigns_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Campaigns_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Campaigns_Var_Pop_Fields = {
  __typename?: 'user_campaigns_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_campaigns" */
export type User_Campaigns_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Campaigns_Var_Samp_Fields = {
  __typename?: 'user_campaigns_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_campaigns" */
export type User_Campaigns_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Campaigns_Variance_Fields = {
  __typename?: 'user_campaigns_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_campaigns" */
export type User_Campaigns_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** columns and relationships of "user_flag" */
export type User_Flag = {
  __typename?: 'user_flag';
  flag: User_Flag_Type_Enum;
  /** An object relationship */
  user: Users;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "user_flag" */
export type User_Flag_Aggregate = {
  __typename?: 'user_flag_aggregate';
  aggregate?: Maybe<User_Flag_Aggregate_Fields>;
  nodes: Array<User_Flag>;
};

export type User_Flag_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Flag_Aggregate_Bool_Exp_Count>;
};

export type User_Flag_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Flag_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Flag_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_flag" */
export type User_Flag_Aggregate_Fields = {
  __typename?: 'user_flag_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Flag_Max_Fields>;
  min?: Maybe<User_Flag_Min_Fields>;
};


/** aggregate fields of "user_flag" */
export type User_Flag_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Flag_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_flag" */
export type User_Flag_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Flag_Max_Order_By>;
  min?: InputMaybe<User_Flag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_flag" */
export type User_Flag_Arr_Rel_Insert_Input = {
  data: Array<User_Flag_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Flag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_flag". All fields are combined with a logical 'AND'. */
export type User_Flag_Bool_Exp = {
  _and?: InputMaybe<Array<User_Flag_Bool_Exp>>;
  _not?: InputMaybe<User_Flag_Bool_Exp>;
  _or?: InputMaybe<Array<User_Flag_Bool_Exp>>;
  flag?: InputMaybe<User_Flag_Type_Enum_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_flag" */
export enum User_Flag_Constraint {
  /** unique or primary key constraint on columns "user_id", "flag" */
  UserFlagPkey = 'user_flag_pkey'
}

/** input type for inserting data into table "user_flag" */
export type User_Flag_Insert_Input = {
  flag?: InputMaybe<User_Flag_Type_Enum>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Flag_Max_Fields = {
  __typename?: 'user_flag_max_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "user_flag" */
export type User_Flag_Max_Order_By = {
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Flag_Min_Fields = {
  __typename?: 'user_flag_min_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "user_flag" */
export type User_Flag_Min_Order_By = {
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_flag" */
export type User_Flag_Mutation_Response = {
  __typename?: 'user_flag_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Flag>;
};

/** on_conflict condition type for table "user_flag" */
export type User_Flag_On_Conflict = {
  constraint: User_Flag_Constraint;
  update_columns?: Array<User_Flag_Update_Column>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};

/** Ordering options when selecting data from "user_flag". */
export type User_Flag_Order_By = {
  flag?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_flag */
export type User_Flag_Pk_Columns_Input = {
  flag: User_Flag_Type_Enum;
  user_id: Scalars['String']['input'];
};

/** select columns of table "user_flag" */
export enum User_Flag_Select_Column {
  /** column name */
  Flag = 'flag',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "user_flag" */
export type User_Flag_Set_Input = {
  flag?: InputMaybe<User_Flag_Type_Enum>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_flag" */
export type User_Flag_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Flag_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Flag_Stream_Cursor_Value_Input = {
  flag?: InputMaybe<User_Flag_Type_Enum>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "user_flag_type" */
export type User_Flag_Type = {
  __typename?: 'user_flag_type';
  value: Scalars['String']['output'];
};

/** aggregated selection of "user_flag_type" */
export type User_Flag_Type_Aggregate = {
  __typename?: 'user_flag_type_aggregate';
  aggregate?: Maybe<User_Flag_Type_Aggregate_Fields>;
  nodes: Array<User_Flag_Type>;
};

/** aggregate fields of "user_flag_type" */
export type User_Flag_Type_Aggregate_Fields = {
  __typename?: 'user_flag_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Flag_Type_Max_Fields>;
  min?: Maybe<User_Flag_Type_Min_Fields>;
};


/** aggregate fields of "user_flag_type" */
export type User_Flag_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Flag_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "user_flag_type". All fields are combined with a logical 'AND'. */
export type User_Flag_Type_Bool_Exp = {
  _and?: InputMaybe<Array<User_Flag_Type_Bool_Exp>>;
  _not?: InputMaybe<User_Flag_Type_Bool_Exp>;
  _or?: InputMaybe<Array<User_Flag_Type_Bool_Exp>>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_flag_type" */
export enum User_Flag_Type_Constraint {
  /** unique or primary key constraint on columns "value" */
  UserFlagTypePkey = 'user_flag_type_pkey'
}

export enum User_Flag_Type_Enum {
  Admin = 'admin',
  EsDv = 'es_dv',
  EsDvAdmin = 'es_dv_admin'
}

/** Boolean expression to compare columns of type "user_flag_type_enum". All fields are combined with logical 'AND'. */
export type User_Flag_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<User_Flag_Type_Enum>;
  _in?: InputMaybe<Array<User_Flag_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<User_Flag_Type_Enum>;
  _nin?: InputMaybe<Array<User_Flag_Type_Enum>>;
};

/** input type for inserting data into table "user_flag_type" */
export type User_Flag_Type_Insert_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Flag_Type_Max_Fields = {
  __typename?: 'user_flag_type_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type User_Flag_Type_Min_Fields = {
  __typename?: 'user_flag_type_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "user_flag_type" */
export type User_Flag_Type_Mutation_Response = {
  __typename?: 'user_flag_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Flag_Type>;
};

/** on_conflict condition type for table "user_flag_type" */
export type User_Flag_Type_On_Conflict = {
  constraint: User_Flag_Type_Constraint;
  update_columns?: Array<User_Flag_Type_Update_Column>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "user_flag_type". */
export type User_Flag_Type_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_flag_type */
export type User_Flag_Type_Pk_Columns_Input = {
  value: Scalars['String']['input'];
};

/** select columns of table "user_flag_type" */
export enum User_Flag_Type_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "user_flag_type" */
export type User_Flag_Type_Set_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_flag_type" */
export type User_Flag_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Flag_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Flag_Type_Stream_Cursor_Value_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "user_flag_type" */
export enum User_Flag_Type_Update_Column {
  /** column name */
  Value = 'value'
}

export type User_Flag_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Flag_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Flag_Type_Bool_Exp;
};

/** update columns of table "user_flag" */
export enum User_Flag_Update_Column {
  /** column name */
  Flag = 'flag',
  /** column name */
  UserId = 'user_id'
}

export type User_Flag_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Flag_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Flag_Bool_Exp;
};

/** columns and relationships of "user_friends" */
export type User_Friends = {
  __typename?: 'user_friends';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "user_friends" */
export type User_Friends_Aggregate = {
  __typename?: 'user_friends_aggregate';
  aggregate?: Maybe<User_Friends_Aggregate_Fields>;
  nodes: Array<User_Friends>;
};

export type User_Friends_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Friends_Aggregate_Bool_Exp_Count>;
};

export type User_Friends_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Friends_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Friends_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_friends" */
export type User_Friends_Aggregate_Fields = {
  __typename?: 'user_friends_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Friends_Max_Fields>;
  min?: Maybe<User_Friends_Min_Fields>;
};


/** aggregate fields of "user_friends" */
export type User_Friends_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Friends_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_friends" */
export type User_Friends_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Friends_Max_Order_By>;
  min?: InputMaybe<User_Friends_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_friends" */
export type User_Friends_Arr_Rel_Insert_Input = {
  data: Array<User_Friends_Insert_Input>;
};

/** Boolean expression to filter rows from the table "user_friends". All fields are combined with a logical 'AND'. */
export type User_Friends_Bool_Exp = {
  _and?: InputMaybe<Array<User_Friends_Bool_Exp>>;
  _not?: InputMaybe<User_Friends_Bool_Exp>;
  _or?: InputMaybe<Array<User_Friends_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "user_friends" */
export type User_Friends_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Friends_Max_Fields = {
  __typename?: 'user_friends_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "user_friends" */
export type User_Friends_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Friends_Min_Fields = {
  __typename?: 'user_friends_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "user_friends" */
export type User_Friends_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_friends" */
export type User_Friends_Mutation_Response = {
  __typename?: 'user_friends_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Friends>;
};

/** Ordering options when selecting data from "user_friends". */
export type User_Friends_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "user_friends" */
export enum User_Friends_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "user_friends" */
export type User_Friends_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_friends" */
export type User_Friends_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Friends_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Friends_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type User_Friends_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Friends_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Friends_Bool_Exp;
};

/** columns and relationships of "user_received_friend_requests" */
export type User_Received_Friend_Requests = {
  __typename?: 'user_received_friend_requests';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "user_received_friend_requests" */
export type User_Received_Friend_Requests_Aggregate = {
  __typename?: 'user_received_friend_requests_aggregate';
  aggregate?: Maybe<User_Received_Friend_Requests_Aggregate_Fields>;
  nodes: Array<User_Received_Friend_Requests>;
};

export type User_Received_Friend_Requests_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Received_Friend_Requests_Aggregate_Bool_Exp_Count>;
};

export type User_Received_Friend_Requests_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_received_friend_requests" */
export type User_Received_Friend_Requests_Aggregate_Fields = {
  __typename?: 'user_received_friend_requests_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Received_Friend_Requests_Max_Fields>;
  min?: Maybe<User_Received_Friend_Requests_Min_Fields>;
};


/** aggregate fields of "user_received_friend_requests" */
export type User_Received_Friend_Requests_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Received_Friend_Requests_Max_Order_By>;
  min?: InputMaybe<User_Received_Friend_Requests_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Arr_Rel_Insert_Input = {
  data: Array<User_Received_Friend_Requests_Insert_Input>;
};

/** Boolean expression to filter rows from the table "user_received_friend_requests". All fields are combined with a logical 'AND'. */
export type User_Received_Friend_Requests_Bool_Exp = {
  _and?: InputMaybe<Array<User_Received_Friend_Requests_Bool_Exp>>;
  _not?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
  _or?: InputMaybe<Array<User_Received_Friend_Requests_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Received_Friend_Requests_Max_Fields = {
  __typename?: 'user_received_friend_requests_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Received_Friend_Requests_Min_Fields = {
  __typename?: 'user_received_friend_requests_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Mutation_Response = {
  __typename?: 'user_received_friend_requests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Received_Friend_Requests>;
};

/** Ordering options when selecting data from "user_received_friend_requests". */
export type User_Received_Friend_Requests_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "user_received_friend_requests" */
export enum User_Received_Friend_Requests_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Received_Friend_Requests_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Received_Friend_Requests_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type User_Received_Friend_Requests_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Received_Friend_Requests_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Received_Friend_Requests_Bool_Exp;
};

/** columns and relationships of "user_sent_friend_requests" */
export type User_Sent_Friend_Requests = {
  __typename?: 'user_sent_friend_requests';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Aggregate = {
  __typename?: 'user_sent_friend_requests_aggregate';
  aggregate?: Maybe<User_Sent_Friend_Requests_Aggregate_Fields>;
  nodes: Array<User_Sent_Friend_Requests>;
};

export type User_Sent_Friend_Requests_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Sent_Friend_Requests_Aggregate_Bool_Exp_Count>;
};

export type User_Sent_Friend_Requests_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Aggregate_Fields = {
  __typename?: 'user_sent_friend_requests_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Sent_Friend_Requests_Max_Fields>;
  min?: Maybe<User_Sent_Friend_Requests_Min_Fields>;
};


/** aggregate fields of "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Sent_Friend_Requests_Max_Order_By>;
  min?: InputMaybe<User_Sent_Friend_Requests_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Arr_Rel_Insert_Input = {
  data: Array<User_Sent_Friend_Requests_Insert_Input>;
};

/** Boolean expression to filter rows from the table "user_sent_friend_requests". All fields are combined with a logical 'AND'. */
export type User_Sent_Friend_Requests_Bool_Exp = {
  _and?: InputMaybe<Array<User_Sent_Friend_Requests_Bool_Exp>>;
  _not?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
  _or?: InputMaybe<Array<User_Sent_Friend_Requests_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Sent_Friend_Requests_Max_Fields = {
  __typename?: 'user_sent_friend_requests_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Sent_Friend_Requests_Min_Fields = {
  __typename?: 'user_sent_friend_requests_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Mutation_Response = {
  __typename?: 'user_sent_friend_requests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Sent_Friend_Requests>;
};

/** Ordering options when selecting data from "user_sent_friend_requests". */
export type User_Sent_Friend_Requests_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "user_sent_friend_requests" */
export enum User_Sent_Friend_Requests_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Sent_Friend_Requests_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Sent_Friend_Requests_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type User_Sent_Friend_Requests_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Sent_Friend_Requests_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Sent_Friend_Requests_Bool_Exp;
};

/** columns and relationships of "user_settings" */
export type User_Settings = {
  __typename?: 'user_settings';
  alphabetize?: Maybe<Scalars['Boolean']['output']>;
  campaign_show_deck_id?: Maybe<Scalars['Boolean']['output']>;
  colorblind?: Maybe<Scalars['Boolean']['output']>;
  custom_content?: Maybe<Scalars['Boolean']['output']>;
  ignore_collection?: Maybe<Scalars['Boolean']['output']>;
  in_collection?: Maybe<Scalars['jsonb']['output']>;
  onboarding?: Maybe<Scalars['jsonb']['output']>;
  show_spoilers?: Maybe<Scalars['jsonb']['output']>;
  single_card?: Maybe<Scalars['Boolean']['output']>;
  sort_quotes?: Maybe<Scalars['Boolean']['output']>;
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "user_settings" */
export type User_SettingsIn_CollectionArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "user_settings" */
export type User_SettingsOnboardingArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "user_settings" */
export type User_SettingsShow_SpoilersArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "user_settings" */
export type User_Settings_Aggregate = {
  __typename?: 'user_settings_aggregate';
  aggregate?: Maybe<User_Settings_Aggregate_Fields>;
  nodes: Array<User_Settings>;
};

/** aggregate fields of "user_settings" */
export type User_Settings_Aggregate_Fields = {
  __typename?: 'user_settings_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Settings_Max_Fields>;
  min?: Maybe<User_Settings_Min_Fields>;
};


/** aggregate fields of "user_settings" */
export type User_Settings_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Settings_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type User_Settings_Append_Input = {
  in_collection?: InputMaybe<Scalars['jsonb']['input']>;
  onboarding?: InputMaybe<Scalars['jsonb']['input']>;
  show_spoilers?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "user_settings". All fields are combined with a logical 'AND'. */
export type User_Settings_Bool_Exp = {
  _and?: InputMaybe<Array<User_Settings_Bool_Exp>>;
  _not?: InputMaybe<User_Settings_Bool_Exp>;
  _or?: InputMaybe<Array<User_Settings_Bool_Exp>>;
  alphabetize?: InputMaybe<Boolean_Comparison_Exp>;
  campaign_show_deck_id?: InputMaybe<Boolean_Comparison_Exp>;
  colorblind?: InputMaybe<Boolean_Comparison_Exp>;
  custom_content?: InputMaybe<Boolean_Comparison_Exp>;
  ignore_collection?: InputMaybe<Boolean_Comparison_Exp>;
  in_collection?: InputMaybe<Jsonb_Comparison_Exp>;
  onboarding?: InputMaybe<Jsonb_Comparison_Exp>;
  show_spoilers?: InputMaybe<Jsonb_Comparison_Exp>;
  single_card?: InputMaybe<Boolean_Comparison_Exp>;
  sort_quotes?: InputMaybe<Boolean_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_settings" */
export enum User_Settings_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  UserSettingsPkey = 'user_settings_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type User_Settings_Delete_At_Path_Input = {
  in_collection?: InputMaybe<Array<Scalars['String']['input']>>;
  onboarding?: InputMaybe<Array<Scalars['String']['input']>>;
  show_spoilers?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type User_Settings_Delete_Elem_Input = {
  in_collection?: InputMaybe<Scalars['Int']['input']>;
  onboarding?: InputMaybe<Scalars['Int']['input']>;
  show_spoilers?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type User_Settings_Delete_Key_Input = {
  in_collection?: InputMaybe<Scalars['String']['input']>;
  onboarding?: InputMaybe<Scalars['String']['input']>;
  show_spoilers?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "user_settings" */
export type User_Settings_Insert_Input = {
  alphabetize?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_show_deck_id?: InputMaybe<Scalars['Boolean']['input']>;
  colorblind?: InputMaybe<Scalars['Boolean']['input']>;
  custom_content?: InputMaybe<Scalars['Boolean']['input']>;
  ignore_collection?: InputMaybe<Scalars['Boolean']['input']>;
  in_collection?: InputMaybe<Scalars['jsonb']['input']>;
  onboarding?: InputMaybe<Scalars['jsonb']['input']>;
  show_spoilers?: InputMaybe<Scalars['jsonb']['input']>;
  single_card?: InputMaybe<Scalars['Boolean']['input']>;
  sort_quotes?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Settings_Max_Fields = {
  __typename?: 'user_settings_max_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type User_Settings_Min_Fields = {
  __typename?: 'user_settings_min_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "user_settings" */
export type User_Settings_Mutation_Response = {
  __typename?: 'user_settings_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Settings>;
};

/** on_conflict condition type for table "user_settings" */
export type User_Settings_On_Conflict = {
  constraint: User_Settings_Constraint;
  update_columns?: Array<User_Settings_Update_Column>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};

/** Ordering options when selecting data from "user_settings". */
export type User_Settings_Order_By = {
  alphabetize?: InputMaybe<Order_By>;
  campaign_show_deck_id?: InputMaybe<Order_By>;
  colorblind?: InputMaybe<Order_By>;
  custom_content?: InputMaybe<Order_By>;
  ignore_collection?: InputMaybe<Order_By>;
  in_collection?: InputMaybe<Order_By>;
  onboarding?: InputMaybe<Order_By>;
  show_spoilers?: InputMaybe<Order_By>;
  single_card?: InputMaybe<Order_By>;
  sort_quotes?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_settings */
export type User_Settings_Pk_Columns_Input = {
  user_id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type User_Settings_Prepend_Input = {
  in_collection?: InputMaybe<Scalars['jsonb']['input']>;
  onboarding?: InputMaybe<Scalars['jsonb']['input']>;
  show_spoilers?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "user_settings" */
export enum User_Settings_Select_Column {
  /** column name */
  Alphabetize = 'alphabetize',
  /** column name */
  CampaignShowDeckId = 'campaign_show_deck_id',
  /** column name */
  Colorblind = 'colorblind',
  /** column name */
  CustomContent = 'custom_content',
  /** column name */
  IgnoreCollection = 'ignore_collection',
  /** column name */
  InCollection = 'in_collection',
  /** column name */
  Onboarding = 'onboarding',
  /** column name */
  ShowSpoilers = 'show_spoilers',
  /** column name */
  SingleCard = 'single_card',
  /** column name */
  SortQuotes = 'sort_quotes',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "user_settings" */
export type User_Settings_Set_Input = {
  alphabetize?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_show_deck_id?: InputMaybe<Scalars['Boolean']['input']>;
  colorblind?: InputMaybe<Scalars['Boolean']['input']>;
  custom_content?: InputMaybe<Scalars['Boolean']['input']>;
  ignore_collection?: InputMaybe<Scalars['Boolean']['input']>;
  in_collection?: InputMaybe<Scalars['jsonb']['input']>;
  onboarding?: InputMaybe<Scalars['jsonb']['input']>;
  show_spoilers?: InputMaybe<Scalars['jsonb']['input']>;
  single_card?: InputMaybe<Scalars['Boolean']['input']>;
  sort_quotes?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_settings" */
export type User_Settings_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Settings_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Settings_Stream_Cursor_Value_Input = {
  alphabetize?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_show_deck_id?: InputMaybe<Scalars['Boolean']['input']>;
  colorblind?: InputMaybe<Scalars['Boolean']['input']>;
  custom_content?: InputMaybe<Scalars['Boolean']['input']>;
  ignore_collection?: InputMaybe<Scalars['Boolean']['input']>;
  in_collection?: InputMaybe<Scalars['jsonb']['input']>;
  onboarding?: InputMaybe<Scalars['jsonb']['input']>;
  show_spoilers?: InputMaybe<Scalars['jsonb']['input']>;
  single_card?: InputMaybe<Scalars['Boolean']['input']>;
  sort_quotes?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "user_settings" */
export enum User_Settings_Update_Column {
  /** column name */
  Alphabetize = 'alphabetize',
  /** column name */
  CampaignShowDeckId = 'campaign_show_deck_id',
  /** column name */
  Colorblind = 'colorblind',
  /** column name */
  CustomContent = 'custom_content',
  /** column name */
  IgnoreCollection = 'ignore_collection',
  /** column name */
  InCollection = 'in_collection',
  /** column name */
  Onboarding = 'onboarding',
  /** column name */
  ShowSpoilers = 'show_spoilers',
  /** column name */
  SingleCard = 'single_card',
  /** column name */
  SortQuotes = 'sort_quotes',
  /** column name */
  UserId = 'user_id'
}

export type User_Settings_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<User_Settings_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<User_Settings_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<User_Settings_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<User_Settings_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<User_Settings_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Settings_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Settings_Bool_Exp;
};

/** columns and relationships of "users" */
export type Users = {
  __typename?: 'users';
  /** An array relationship */
  all_decks: Array<Campaign_Deck>;
  /** An aggregate relationship */
  all_decks_aggregate: Campaign_Deck_Aggregate;
  /** An array relationship */
  campaigns: Array<User_Campaigns>;
  /** An aggregate relationship */
  campaigns_aggregate: User_Campaigns_Aggregate;
  created_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  decks: Array<Latest_Decks>;
  /** An aggregate relationship */
  decks_aggregate: Latest_Decks_Aggregate;
  /** An array relationship */
  flags: Array<User_Flag>;
  /** An aggregate relationship */
  flags_aggregate: User_Flag_Aggregate;
  /** An array relationship */
  friends: Array<User_Friends>;
  /** An aggregate relationship */
  friends_aggregate: User_Friends_Aggregate;
  handle?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  /** An array relationship */
  local_decks: Array<Local_Decks>;
  /** An aggregate relationship */
  local_decks_aggregate: Local_Decks_Aggregate;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  received_requests: Array<User_Received_Friend_Requests>;
  /** An aggregate relationship */
  received_requests_aggregate: User_Received_Friend_Requests_Aggregate;
  /** An array relationship */
  sent_requests: Array<User_Sent_Friend_Requests>;
  /** An aggregate relationship */
  sent_requests_aggregate: User_Sent_Friend_Requests_Aggregate;
  updated_at: Scalars['timestamp']['output'];
};


/** columns and relationships of "users" */
export type UsersAll_DecksArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersAll_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersCampaignsArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersCampaigns_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersDecksArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersDecks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersFlagsArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersFlags_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersFriendsArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersFriends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersLocal_DecksArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersLocal_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersReceived_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersReceived_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersSent_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersSent_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};

/** aggregated selection of "users" */
export type Users_Aggregate = {
  __typename?: 'users_aggregate';
  aggregate?: Maybe<Users_Aggregate_Fields>;
  nodes: Array<Users>;
};

/** aggregate fields of "users" */
export type Users_Aggregate_Fields = {
  __typename?: 'users_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Users_Max_Fields>;
  min?: Maybe<Users_Min_Fields>;
};


/** aggregate fields of "users" */
export type Users_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type Users_Bool_Exp = {
  _and?: InputMaybe<Array<Users_Bool_Exp>>;
  _not?: InputMaybe<Users_Bool_Exp>;
  _or?: InputMaybe<Array<Users_Bool_Exp>>;
  all_decks?: InputMaybe<Campaign_Deck_Bool_Exp>;
  all_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp>;
  campaigns?: InputMaybe<User_Campaigns_Bool_Exp>;
  campaigns_aggregate?: InputMaybe<User_Campaigns_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  decks?: InputMaybe<Latest_Decks_Bool_Exp>;
  decks_aggregate?: InputMaybe<Latest_Decks_Aggregate_Bool_Exp>;
  flags?: InputMaybe<User_Flag_Bool_Exp>;
  flags_aggregate?: InputMaybe<User_Flag_Aggregate_Bool_Exp>;
  friends?: InputMaybe<User_Friends_Bool_Exp>;
  friends_aggregate?: InputMaybe<User_Friends_Aggregate_Bool_Exp>;
  handle?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  local_decks?: InputMaybe<Local_Decks_Bool_Exp>;
  local_decks_aggregate?: InputMaybe<Local_Decks_Aggregate_Bool_Exp>;
  normalized_handle?: InputMaybe<String_Comparison_Exp>;
  received_requests?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
  received_requests_aggregate?: InputMaybe<User_Received_Friend_Requests_Aggregate_Bool_Exp>;
  sent_requests?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
  sent_requests_aggregate?: InputMaybe<User_Sent_Friend_Requests_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "users" */
export enum Users_Constraint {
  /** unique or primary key constraint on columns "normalized_handle" */
  UsersNormalizedHandleKey = 'users_normalized_handle_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey'
}

/** input type for inserting data into table "users" */
export type Users_Insert_Input = {
  all_decks?: InputMaybe<Campaign_Deck_Arr_Rel_Insert_Input>;
  campaigns?: InputMaybe<User_Campaigns_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  decks?: InputMaybe<Latest_Decks_Arr_Rel_Insert_Input>;
  flags?: InputMaybe<User_Flag_Arr_Rel_Insert_Input>;
  friends?: InputMaybe<User_Friends_Arr_Rel_Insert_Input>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  local_decks?: InputMaybe<Local_Decks_Arr_Rel_Insert_Input>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  received_requests?: InputMaybe<User_Received_Friend_Requests_Arr_Rel_Insert_Input>;
  sent_requests?: InputMaybe<User_Sent_Friend_Requests_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type Users_Max_Fields = {
  __typename?: 'users_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamp']['output']>;
};

/** aggregate min on columns */
export type Users_Min_Fields = {
  __typename?: 'users_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamp']['output']>;
};

/** response of any mutation on the table "users" */
export type Users_Mutation_Response = {
  __typename?: 'users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type Users_Obj_Rel_Insert_Input = {
  data: Users_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Users_On_Conflict>;
};

/** on_conflict condition type for table "users" */
export type Users_On_Conflict = {
  constraint: Users_Constraint;
  update_columns?: Array<Users_Update_Column>;
  where?: InputMaybe<Users_Bool_Exp>;
};

/** Ordering options when selecting data from "users". */
export type Users_Order_By = {
  all_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Order_By>;
  campaigns_aggregate?: InputMaybe<User_Campaigns_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  decks_aggregate?: InputMaybe<Latest_Decks_Aggregate_Order_By>;
  flags_aggregate?: InputMaybe<User_Flag_Aggregate_Order_By>;
  friends_aggregate?: InputMaybe<User_Friends_Aggregate_Order_By>;
  handle?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  local_decks_aggregate?: InputMaybe<Local_Decks_Aggregate_Order_By>;
  normalized_handle?: InputMaybe<Order_By>;
  received_requests_aggregate?: InputMaybe<User_Received_Friend_Requests_Aggregate_Order_By>;
  sent_requests_aggregate?: InputMaybe<User_Sent_Friend_Requests_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: users */
export type Users_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "users" */
export enum Users_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "users" */
export type Users_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** Streaming cursor of the table "users" */
export type Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** update columns of table "users" */
export enum Users_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Users_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Users_Bool_Exp;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['uuid']['input']>;
  _gt?: InputMaybe<Scalars['uuid']['input']>;
  _gte?: InputMaybe<Scalars['uuid']['input']>;
  _in?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['uuid']['input']>;
  _lte?: InputMaybe<Scalars['uuid']['input']>;
  _neq?: InputMaybe<Scalars['uuid']['input']>;
  _nin?: InputMaybe<Array<Scalars['uuid']['input']>>;
};

export type GetMyCampaignsQueryVariables = Exact<{
  userId: Scalars['String']['input'];
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetMyCampaignsQuery = { __typename?: 'query_root', campaigns: Array<{ __typename?: 'rangers_user_campaign', campaign?: { __typename?: 'rangers_campaign', id: number, user_id: string, name: string, notes: any, day: number, extended_calendar?: boolean | null, cycle_id: string, current_location?: string | null, current_path_terrain?: string | null, missions: any, events: any, rewards: any, removed: any, history: any, calendar: any, next_campaign_id?: number | null, latest_decks: Array<{ __typename?: 'rangers_latest_deck', deck?: { __typename?: 'rangers_deck', id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null } | null, user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, access: Array<{ __typename?: 'rangers_user_campaign', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, previous_campaign?: { __typename?: 'rangers_campaign', id: number } | null } | null }> };

export type GetMyTransferableCampaignsQueryVariables = Exact<{
  userId: Scalars['String']['input'];
  cycles: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type GetMyTransferableCampaignsQuery = { __typename?: 'query_root', campaigns: Array<{ __typename?: 'rangers_user_campaign', campaign?: { __typename?: 'rangers_campaign', id: number, user_id: string, name: string, notes: any, day: number, extended_calendar?: boolean | null, cycle_id: string, current_location?: string | null, current_path_terrain?: string | null, missions: any, events: any, rewards: any, removed: any, history: any, calendar: any, next_campaign_id?: number | null, latest_decks: Array<{ __typename?: 'rangers_latest_deck', deck?: { __typename?: 'rangers_deck', id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null } | null, user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, access: Array<{ __typename?: 'rangers_user_campaign', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, previous_campaign?: { __typename?: 'rangers_campaign', id: number } | null } | null }> };

export type GetMyCampaignsTotalQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type GetMyCampaignsTotalQuery = { __typename?: 'query_root', campaigns: { __typename?: 'rangers_user_campaign_aggregate', aggregate?: { __typename?: 'rangers_user_campaign_aggregate_fields', count: number } | null } };

export type GetCampaignQueryVariables = Exact<{
  campaignId: Scalars['Int']['input'];
}>;


export type GetCampaignQuery = { __typename?: 'query_root', campaign?: { __typename?: 'rangers_campaign', id: number, user_id: string, name: string, notes: any, day: number, extended_calendar?: boolean | null, cycle_id: string, current_location?: string | null, current_path_terrain?: string | null, missions: any, events: any, rewards: any, removed: any, history: any, calendar: any, next_campaign_id?: number | null, latest_decks: Array<{ __typename?: 'rangers_latest_deck', deck?: { __typename?: 'rangers_deck', id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null } | null, user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, access: Array<{ __typename?: 'rangers_user_campaign', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, previous_campaign?: { __typename?: 'rangers_campaign', id: number } | null } | null };

export type CreateCampaignMutationVariables = Exact<{
  name: Scalars['String']['input'];
  cycleId: Scalars['String']['input'];
  currentLocation: Scalars['String']['input'];
}>;


export type CreateCampaignMutation = { __typename?: 'mutation_root', campaign?: { __typename?: 'rangers_campaign', id: number, user_id: string, name: string, notes: any, day: number, extended_calendar?: boolean | null, cycle_id: string, current_location?: string | null, current_path_terrain?: string | null, missions: any, events: any, rewards: any, removed: any, history: any, calendar: any, next_campaign_id?: number | null, latest_decks: Array<{ __typename?: 'rangers_latest_deck', deck?: { __typename?: 'rangers_deck', id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null } | null, user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, access: Array<{ __typename?: 'rangers_user_campaign', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, previous_campaign?: { __typename?: 'rangers_campaign', id: number } | null } | null };

export type TransferCampaignMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  cycleId: Scalars['String']['input'];
  currentLocation: Scalars['String']['input'];
}>;


export type TransferCampaignMutation = { __typename?: 'mutation_root', campaign: Array<{ __typename?: 'rangers_campaign', id: number, user_id: string, name: string, notes: any, day: number, extended_calendar?: boolean | null, cycle_id: string, current_location?: string | null, current_path_terrain?: string | null, missions: any, events: any, rewards: any, removed: any, history: any, calendar: any, next_campaign_id?: number | null, latest_decks: Array<{ __typename?: 'rangers_latest_deck', deck?: { __typename?: 'rangers_deck', id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null } | null, user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, access: Array<{ __typename?: 'rangers_user_campaign', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, previous_campaign?: { __typename?: 'rangers_campaign', id: number } | null }> };

export type SetCampaignTitleMutationVariables = Exact<{
  name: Scalars['String']['input'];
  campaignId: Scalars['Int']['input'];
}>;


export type SetCampaignTitleMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, name: string } | null };

export type AddFriendToCampaignMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  userId: Scalars['String']['input'];
}>;


export type AddFriendToCampaignMutation = { __typename?: 'mutation_root', insert_rangers_campaign_access_one?: { __typename?: 'rangers_campaign_access', campaign: { __typename?: 'rangers_campaign', id: number, access: Array<{ __typename?: 'rangers_user_campaign', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }> } } | null };

export type RemoveFriendFromCampaignMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  userId: Scalars['String']['input'];
}>;


export type RemoveFriendFromCampaignMutation = { __typename?: 'mutation_root', delete_rangers_campaign_access_by_pk?: { __typename?: 'rangers_campaign_access', campaign: { __typename?: 'rangers_campaign', id: number, access: Array<{ __typename?: 'rangers_user_campaign', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }> } } | null };

export type UpdateCampaignRewardsMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  rewards: Scalars['jsonb']['input'];
}>;


export type UpdateCampaignRewardsMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, rewards: any } | null };

export type AddCampaignEventMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  event: Scalars['jsonb']['input'];
}>;


export type AddCampaignEventMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, events: any } | null };

export type AddCampaignNoteMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  note: Scalars['jsonb']['input'];
}>;


export type AddCampaignNoteMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, notes: any } | null };

export type UpdateCampaignRemovedMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  removed: Scalars['jsonb']['input'];
}>;


export type UpdateCampaignRemovedMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, removed: any } | null };

export type AddCampaignRemovedMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  removed: Scalars['jsonb']['input'];
}>;


export type AddCampaignRemovedMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, removed: any } | null };

export type UpdateCampaignNotesMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  notes: Scalars['jsonb']['input'];
}>;


export type UpdateCampaignNotesMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, notes: any } | null };

export type ExtendCampaignMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
}>;


export type ExtendCampaignMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, extended_calendar?: boolean | null } | null };

export type UpdateCampaignEventsMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  events: Scalars['jsonb']['input'];
}>;


export type UpdateCampaignEventsMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, events: any } | null };

export type SetCampaignLocationMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  location: Scalars['String']['input'];
}>;


export type SetCampaignLocationMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, current_location?: string | null } | null };

export type SetCampaignPathTerrainMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  terrain: Scalars['String']['input'];
}>;


export type SetCampaignPathTerrainMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, current_path_terrain?: string | null } | null };

export type AddCampaignMissionMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  mission: Scalars['jsonb']['input'];
}>;


export type AddCampaignMissionMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, missions: any } | null };

export type SetCampaignMissionsMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  missions: Scalars['jsonb']['input'];
}>;


export type SetCampaignMissionsMutation = { __typename?: 'mutation_root', update_rangers_campaign_by_pk?: { __typename?: 'rangers_campaign', id: number, missions: any } | null };

export type SetCampaignCalendarMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  calendar: Scalars['jsonb']['input'];
}>;


export type SetCampaignCalendarMutation = { __typename?: 'mutation_root', campaign?: { __typename?: 'rangers_campaign', id: number, calendar: any } | null };

export type SetCampaignDayMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  day: Scalars['Int']['input'];
}>;


export type SetCampaignDayMutation = { __typename?: 'mutation_root', campaign?: { __typename?: 'rangers_campaign', id: number, day: number } | null };

export type AddCampaignHistoryMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  history: Scalars['jsonb']['input'];
  day: Scalars['Int']['input'];
}>;


export type AddCampaignHistoryMutation = { __typename?: 'mutation_root', campaign?: { __typename?: 'rangers_campaign', id: number, history: any } | null };

export type CampaignUndoTravelMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  history: Scalars['jsonb']['input'];
  previousDay: Scalars['Int']['input'];
  previousLocation: Scalars['String']['input'];
  previousPathTerrain?: InputMaybe<Scalars['String']['input']>;
}>;


export type CampaignUndoTravelMutation = { __typename?: 'mutation_root', campaign?: { __typename?: 'rangers_campaign', id: number, day: number, history: any, current_location?: string | null, current_path_terrain?: string | null } | null };

export type CampaignTravelMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  day: Scalars['Int']['input'];
  currentLocation: Scalars['String']['input'];
  currentPathTerrain: Scalars['String']['input'];
  history: Scalars['jsonb']['input'];
}>;


export type CampaignTravelMutation = { __typename?: 'mutation_root', campaign?: { __typename?: 'rangers_campaign', id: number, day: number, history: any, current_location?: string | null, current_path_terrain?: string | null } | null };

export type LeaveCampaignMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  userId: Scalars['String']['input'];
}>;


export type LeaveCampaignMutation = { __typename?: 'mutation_root', delete_rangers_campaign_access_by_pk?: { __typename?: 'rangers_campaign_access', campaign_id: number, user_id: string } | null };

export type DeleteCampaignMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
}>;


export type DeleteCampaignMutation = { __typename?: 'mutation_root', rangers_remove_campaign: Array<{ __typename?: 'rangers_campaign', id: number }> };

export type AspectFragment = { __typename?: 'rangers_aspect_localized', id?: string | null, name?: string | null, short_name?: string | null };

export type GetAllPacksQueryVariables = Exact<{
  locale: Scalars['String']['input'];
}>;


export type GetAllPacksQuery = { __typename?: 'query_root', packs: Array<{ __typename?: 'rangers_pack_localized', id?: string | null, name?: string | null, updated_at?: any | null, locale?: string | null, position?: number | null }> };

export type GetAllCardsQueryVariables = Exact<{
  locale: Scalars['String']['input'];
}>;


export type GetAllCardsQuery = { __typename?: 'query_root', cards: Array<{ __typename?: 'rangers_card_localized', id?: string | null, code?: string | null, name?: string | null, real_traits?: string | null, traits?: string | null, equip?: number | null, presence?: number | null, token_id?: string | null, token_name?: string | null, token_plurals?: string | null, token_count?: number | null, harm?: number | null, approach_conflict?: number | null, approach_reason?: number | null, approach_exploration?: number | null, approach_connection?: number | null, text?: string | null, set_id?: string | null, set_name?: string | null, set_type_id?: string | null, set_size?: number | null, set_type_name?: string | null, set_position?: number | null, quantity?: number | null, level?: number | null, flavor?: string | null, type_id?: string | null, type_name?: string | null, cost?: number | null, aspect_id?: string | null, aspect_name?: string | null, aspect_short_name?: string | null, progress?: number | null, imagesrc?: string | null, position?: number | null, deck_limit?: number | null, spoiler?: boolean | null, sun_challenge?: string | null, mountain_challenge?: string | null, crest_challenge?: string | null, pack_id?: string | null, pack_name?: string | null, pack_short_name?: string | null, pack_position?: number | null, subset_id?: string | null, subset_name?: string | null, subset_position?: number | null, subset_size?: number | null, taboo_id?: string | null, taboo_name?: string | null, taboo_date?: any | null, taboo_is_current?: boolean | null }>, all_updated_at: Array<{ __typename?: 'rangers_card_updated', updated_at?: any | null }> };

export type GetRoleCardsQueryVariables = Exact<{
  locale: Scalars['String']['input'];
}>;


export type GetRoleCardsQuery = { __typename?: 'query_root', cards: Array<{ __typename?: 'rangers_card_localized', id?: string | null, code?: string | null, name?: string | null, real_traits?: string | null, traits?: string | null, equip?: number | null, presence?: number | null, token_id?: string | null, token_name?: string | null, token_plurals?: string | null, token_count?: number | null, harm?: number | null, approach_conflict?: number | null, approach_reason?: number | null, approach_exploration?: number | null, approach_connection?: number | null, text?: string | null, set_id?: string | null, set_name?: string | null, set_type_id?: string | null, set_size?: number | null, set_type_name?: string | null, set_position?: number | null, quantity?: number | null, level?: number | null, flavor?: string | null, type_id?: string | null, type_name?: string | null, cost?: number | null, aspect_id?: string | null, aspect_name?: string | null, aspect_short_name?: string | null, progress?: number | null, imagesrc?: string | null, position?: number | null, deck_limit?: number | null, spoiler?: boolean | null, sun_challenge?: string | null, mountain_challenge?: string | null, crest_challenge?: string | null, pack_id?: string | null, pack_name?: string | null, pack_short_name?: string | null, pack_position?: number | null, subset_id?: string | null, subset_name?: string | null, subset_position?: number | null, subset_size?: number | null, taboo_id?: string | null, taboo_name?: string | null, taboo_date?: any | null, taboo_is_current?: boolean | null }> };

export type GetCardQueryVariables = Exact<{
  locale: Scalars['String']['input'];
  cid: Scalars['String']['input'];
}>;


export type GetCardQuery = { __typename?: 'query_root', cards: Array<{ __typename?: 'rangers_card_localized', id?: string | null, code?: string | null, name?: string | null, real_traits?: string | null, traits?: string | null, equip?: number | null, presence?: number | null, token_id?: string | null, token_name?: string | null, token_plurals?: string | null, token_count?: number | null, harm?: number | null, approach_conflict?: number | null, approach_reason?: number | null, approach_exploration?: number | null, approach_connection?: number | null, text?: string | null, set_id?: string | null, set_name?: string | null, set_type_id?: string | null, set_size?: number | null, set_type_name?: string | null, set_position?: number | null, quantity?: number | null, level?: number | null, flavor?: string | null, type_id?: string | null, type_name?: string | null, cost?: number | null, aspect_id?: string | null, aspect_name?: string | null, aspect_short_name?: string | null, progress?: number | null, imagesrc?: string | null, position?: number | null, deck_limit?: number | null, spoiler?: boolean | null, sun_challenge?: string | null, mountain_challenge?: string | null, crest_challenge?: string | null, pack_id?: string | null, pack_name?: string | null, pack_short_name?: string | null, pack_position?: number | null, subset_id?: string | null, subset_name?: string | null, subset_position?: number | null, subset_size?: number | null, taboo_id?: string | null, taboo_name?: string | null, taboo_date?: any | null, taboo_is_current?: boolean | null }> };

export type GetCardsUpdatedAtQueryVariables = Exact<{
  locale: Scalars['String']['input'];
}>;


export type GetCardsUpdatedAtQuery = { __typename?: 'query_root', card_updated_at: Array<{ __typename?: 'rangers_card_updated', updated_at?: any | null }> };

export type SetTypeFragment = { __typename?: 'rangers_set_type_localized', id?: string | null, name?: string | null, sets: Array<{ __typename?: 'rangers_set_localized', id?: string | null, name?: string | null }> };

export type GetSetNamesQueryVariables = Exact<{
  locale: Scalars['String']['input'];
}>;


export type GetSetNamesQuery = { __typename?: 'query_root', sets: Array<{ __typename?: 'rangers_set_type_localized', id?: string | null, name?: string | null, sets: Array<{ __typename?: 'rangers_set_localized', id?: string | null, name?: string | null }> }> };

export type UpgradeDeckMutationVariables = Exact<{
  deckId: Scalars['Int']['input'];
}>;


export type UpgradeDeckMutation = { __typename?: 'mutation_root', deck?: { __typename?: 'rangers_deck', id: number, next_deck_id?: number | null } | null };

export type PublishDeckMutationVariables = Exact<{
  deckId: Scalars['Int']['input'];
}>;


export type PublishDeckMutation = { __typename?: 'mutation_root', deck?: { __typename?: 'rangers_deck', id: number } | null };

export type SetDeckCampaignMutationVariables = Exact<{
  deckId: Scalars['Int']['input'];
  campaignId: Scalars['Int']['input'];
}>;


export type SetDeckCampaignMutation = { __typename?: 'mutation_root', campaign: Array<{ __typename?: 'rangers_campaign', id: number }> };

export type RemoveDeckCampaignMutationVariables = Exact<{
  deckId: Scalars['Int']['input'];
  campaignId: Scalars['Int']['input'];
}>;


export type RemoveDeckCampaignMutation = { __typename?: 'mutation_root', campaign: Array<{ __typename?: 'rangers_campaign', id: number }> };

export type GetMyCampaignDecksQueryVariables = Exact<{
  userId: Scalars['String']['input'];
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetMyCampaignDecksQuery = { __typename?: 'query_root', decks: Array<{ __typename?: 'rangers_deck', id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null }> };

export type GetMyCampaignDecksTotalQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type GetMyCampaignDecksTotalQuery = { __typename?: 'query_root', total: { __typename?: 'rangers_deck_aggregate', aggregate?: { __typename?: 'rangers_deck_aggregate_fields', count: number } | null } };

export type SearchDecksQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['String']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  awa?: InputMaybe<Scalars['Int']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  background?: InputMaybe<Scalars['_text']['input']>;
  specialty?: InputMaybe<Scalars['_text']['input']>;
  role?: InputMaybe<Scalars['_text']['input']>;
  taboo_set_id?: InputMaybe<Scalars['_text']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
}>;


export type SearchDecksQuery = { __typename?: 'query_root', decks: Array<{ __typename?: 'rangers_search_deck', id?: number | null, user_id?: string | null, slots?: any | null, side_slots?: any | null, version?: number | null, name?: string | null, description?: string | null, awa?: number | null, spi?: number | null, fit?: number | null, foc?: number | null, created_at?: any | null, updated_at?: any | null, meta?: any | null, comment_count?: number | null, copy_count?: number | null, like_count?: number | null, liked_by_user?: boolean | null, taboo_set_id?: string | null, user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }> };

export type GetMyDecksQueryVariables = Exact<{
  userId: Scalars['String']['input'];
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetMyDecksQuery = { __typename?: 'query_root', decks: Array<{ __typename?: 'rangers_deck', comment_count: number, copy_count: number, like_count?: number | null, liked_by_user?: boolean | null, id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, campaign?: { __typename?: 'rangers_campaign', id: number, name: string } | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null }> };

export type GetMyDecksTotalQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type GetMyDecksTotalQuery = { __typename?: 'query_root', total: { __typename?: 'rangers_deck_aggregate', aggregate?: { __typename?: 'rangers_deck_aggregate_fields', count: number } | null } };

export type GetDeckQueryVariables = Exact<{
  deckId: Scalars['Int']['input'];
}>;


export type GetDeckQuery = { __typename?: 'query_root', deck?: { __typename?: 'rangers_deck', copy_count: number, comment_count: number, like_count?: number | null, liked_by_user?: boolean | null, id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, original_deck?: { __typename?: 'rangers_deck_copy', deck: { __typename?: 'rangers_deck', id: number, name: string, user: { __typename?: 'rangers_users', id: string, handle?: string | null } } } | null, campaign?: { __typename?: 'rangers_campaign', id: number, name: string, rewards: any, latest_decks: Array<{ __typename?: 'rangers_latest_deck', deck?: { __typename?: 'rangers_deck', id: number, slots: any } | null }> } | null, user: { __typename?: 'rangers_users', handle?: string | null, id: string }, comments: Array<{ __typename?: 'rangers_comment', id: any, text?: string | null, created_at: any, updated_at: any, response_count: number, comment_id?: any | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null } }>, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null } | null };

export type GetDeckCommentsQueryVariables = Exact<{
  deckId: Scalars['Int']['input'];
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetDeckCommentsQuery = { __typename?: 'query_root', rangers_comment: Array<{ __typename?: 'rangers_comment', deck_id?: number | null, id: any, text?: string | null, created_at: any, updated_at: any, response_count: number, comment_id?: any | null, responses: Array<{ __typename?: 'rangers_comment', id: any, text?: string | null, created_at: any, updated_at: any, response_count: number, comment_id?: any | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null } }>, user: { __typename?: 'rangers_users', id: string, handle?: string | null } }> };

export type GetResponseCommentsQueryVariables = Exact<{
  commentId: Scalars['uuid']['input'];
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetResponseCommentsQuery = { __typename?: 'query_root', rangers_comment: Array<{ __typename?: 'rangers_comment', deck_id?: number | null, id: any, text?: string | null, created_at: any, updated_at: any, response_count: number, comment_id?: any | null, responses: Array<{ __typename?: 'rangers_comment', id: any, text?: string | null, created_at: any, updated_at: any, response_count: number, comment_id?: any | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null } }>, user: { __typename?: 'rangers_users', id: string, handle?: string | null } }> };

export type PostCommentMutationVariables = Exact<{
  deckId: Scalars['Int']['input'];
  text: Scalars['String']['input'];
  commentId?: InputMaybe<Scalars['uuid']['input']>;
}>;


export type PostCommentMutation = { __typename?: 'mutation_root', insert_rangers_comment_one?: { __typename?: 'rangers_comment', comment_id?: any | null, deck_id?: number | null, id: any, text?: string | null, created_at: any, updated_at: any, response_count: number, user: { __typename?: 'rangers_users', id: string, handle?: string | null } } | null };

export type EditCommentMutationVariables = Exact<{
  id: Scalars['uuid']['input'];
  text: Scalars['String']['input'];
}>;


export type EditCommentMutation = { __typename?: 'mutation_root', update_rangers_comment_by_pk?: { __typename?: 'rangers_comment', id: any, text?: string | null, updated_at: any } | null };

export type CreateDeckMutationVariables = Exact<{
  name: Scalars['String']['input'];
  foc: Scalars['Int']['input'];
  fit: Scalars['Int']['input'];
  awa: Scalars['Int']['input'];
  spi: Scalars['Int']['input'];
  meta: Scalars['jsonb']['input'];
  slots: Scalars['jsonb']['input'];
  extraSlots: Scalars['jsonb']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  tabooSetId?: InputMaybe<Scalars['String']['input']>;
}>;


export type CreateDeckMutation = { __typename?: 'mutation_root', deck?: { __typename?: 'rangers_deck', id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null } | null };

export type CloneDeckMutationVariables = Exact<{
  originalDeckId: Scalars['Int']['input'];
  newDeckId: Scalars['Int']['input'];
}>;


export type CloneDeckMutation = { __typename?: 'mutation_root', deck?: { __typename?: 'rangers_deck_copy', user_id: string, deck_id: number, copy_deck_id: number } | null };

export type DeleteDeckMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteDeckMutation = { __typename?: 'mutation_root', delete_rangers_deck_by_pk?: { __typename?: 'rangers_deck', id: number } | null };

export type SaveDeckMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  foc: Scalars['Int']['input'];
  fit: Scalars['Int']['input'];
  awa: Scalars['Int']['input'];
  spi: Scalars['Int']['input'];
  meta: Scalars['jsonb']['input'];
  slots: Scalars['jsonb']['input'];
  sideSlots: Scalars['jsonb']['input'];
  extraSlots: Scalars['jsonb']['input'];
  tabooSetId?: InputMaybe<Scalars['String']['input']>;
}>;


export type SaveDeckMutation = { __typename?: 'mutation_root', update_rangers_deck_by_pk?: { __typename?: 'rangers_deck', id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null } | null };

export type SaveDeckTabooSetMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  tabooSetId?: InputMaybe<Scalars['String']['input']>;
}>;


export type SaveDeckTabooSetMutation = { __typename?: 'mutation_root', update_rangers_deck_by_pk?: { __typename?: 'rangers_deck', id: number, taboo_set_id?: string | null } | null };

export type SaveDeckDescriptionMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  description: Scalars['String']['input'];
}>;


export type SaveDeckDescriptionMutation = { __typename?: 'mutation_root', update_rangers_deck_by_pk?: { __typename?: 'rangers_deck', id: number, description?: string | null } | null };

export type LikeDeckMutationVariables = Exact<{
  deckId: Scalars['Int']['input'];
}>;


export type LikeDeckMutation = { __typename?: 'mutation_root', insert_rangers_deck_like_one?: { __typename?: 'rangers_deck_like', user_id: string, deck_id: number, liked: boolean } | null };

export type UnlikeDeckMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  deckId: Scalars['Int']['input'];
}>;


export type UnlikeDeckMutation = { __typename?: 'mutation_root', update_rangers_deck_like_by_pk?: { __typename?: 'rangers_deck_like', user_id: string, deck_id: number, liked: boolean } | null };

export type UserInfoFragment = { __typename?: 'rangers_users', id: string, handle?: string | null };

export type CampaignFragment = { __typename?: 'rangers_campaign', id: number, user_id: string, name: string, notes: any, day: number, extended_calendar?: boolean | null, cycle_id: string, current_location?: string | null, current_path_terrain?: string | null, missions: any, events: any, rewards: any, removed: any, history: any, calendar: any, next_campaign_id?: number | null, latest_decks: Array<{ __typename?: 'rangers_latest_deck', deck?: { __typename?: 'rangers_deck', id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null } | null, user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, access: Array<{ __typename?: 'rangers_user_campaign', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, previous_campaign?: { __typename?: 'rangers_campaign', id: number } | null };

export type SearchDeckFragment = { __typename?: 'rangers_search_deck', id?: number | null, user_id?: string | null, slots?: any | null, side_slots?: any | null, version?: number | null, name?: string | null, description?: string | null, awa?: number | null, spi?: number | null, fit?: number | null, foc?: number | null, created_at?: any | null, updated_at?: any | null, meta?: any | null, comment_count?: number | null, copy_count?: number | null, like_count?: number | null, liked_by_user?: boolean | null, taboo_set_id?: string | null, user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null };

export type DeckFragment = { __typename?: 'rangers_deck', id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null };

export type DeckWithCampaignFragment = { __typename?: 'rangers_deck', comment_count: number, copy_count: number, like_count?: number | null, liked_by_user?: boolean | null, id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, campaign?: { __typename?: 'rangers_campaign', id: number, name: string } | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null }, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null };

export type BasicDeckCommentFragment = { __typename?: 'rangers_comment', id: any, text?: string | null, created_at: any, updated_at: any, response_count: number, comment_id?: any | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null } };

export type DeckDetailFragment = { __typename?: 'rangers_deck', copy_count: number, comment_count: number, like_count?: number | null, liked_by_user?: boolean | null, id: number, user_id: string, slots: any, side_slots: any, extra_slots: any, version: number, name: string, description?: string | null, awa: number, spi: number, fit: number, foc: number, created_at?: any | null, updated_at?: any | null, meta: any, taboo_set_id?: string | null, published?: boolean | null, original_deck?: { __typename?: 'rangers_deck_copy', deck: { __typename?: 'rangers_deck', id: number, name: string, user: { __typename?: 'rangers_users', id: string, handle?: string | null } } } | null, campaign?: { __typename?: 'rangers_campaign', id: number, name: string, rewards: any, latest_decks: Array<{ __typename?: 'rangers_latest_deck', deck?: { __typename?: 'rangers_deck', id: number, slots: any } | null }> } | null, user: { __typename?: 'rangers_users', handle?: string | null, id: string }, comments: Array<{ __typename?: 'rangers_comment', id: any, text?: string | null, created_at: any, updated_at: any, response_count: number, comment_id?: any | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null } }>, previous_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null, next_deck?: { __typename?: 'rangers_deck', id: number, meta: any, slots: any, side_slots: any, version: number } | null };

export type DeckCommentFragment = { __typename?: 'rangers_comment', deck_id?: number | null, id: any, text?: string | null, created_at: any, updated_at: any, response_count: number, comment_id?: any | null, responses: Array<{ __typename?: 'rangers_comment', id: any, text?: string | null, created_at: any, updated_at: any, response_count: number, comment_id?: any | null, user: { __typename?: 'rangers_users', id: string, handle?: string | null } }>, user: { __typename?: 'rangers_users', id: string, handle?: string | null } };

export type PackFragment = { __typename?: 'rangers_pack_localized', id?: string | null, name?: string | null, updated_at?: any | null, locale?: string | null, position?: number | null };

export type CardFragment = { __typename?: 'rangers_card_localized', id?: string | null, code?: string | null, name?: string | null, real_traits?: string | null, traits?: string | null, equip?: number | null, presence?: number | null, token_id?: string | null, token_name?: string | null, token_plurals?: string | null, token_count?: number | null, harm?: number | null, approach_conflict?: number | null, approach_reason?: number | null, approach_exploration?: number | null, approach_connection?: number | null, text?: string | null, set_id?: string | null, set_name?: string | null, set_type_id?: string | null, set_size?: number | null, set_type_name?: string | null, set_position?: number | null, quantity?: number | null, level?: number | null, flavor?: string | null, type_id?: string | null, type_name?: string | null, cost?: number | null, aspect_id?: string | null, aspect_name?: string | null, aspect_short_name?: string | null, progress?: number | null, imagesrc?: string | null, position?: number | null, deck_limit?: number | null, spoiler?: boolean | null, sun_challenge?: string | null, mountain_challenge?: string | null, crest_challenge?: string | null, pack_id?: string | null, pack_name?: string | null, pack_short_name?: string | null, pack_position?: number | null, subset_id?: string | null, subset_name?: string | null, subset_position?: number | null, subset_size?: number | null, taboo_id?: string | null, taboo_name?: string | null, taboo_date?: any | null, taboo_is_current?: boolean | null };

export type UserProfileFragment = { __typename?: 'rangers_users', id: string, handle?: string | null, created_at: any, friends: Array<{ __typename?: 'rangers_user_friends', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, sent_requests: Array<{ __typename?: 'rangers_user_sent_friend_requests', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, received_requests: Array<{ __typename?: 'rangers_user_received_friend_requests', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }> };

export type NavProfileFragment = { __typename?: 'rangers_users', id: string, handle?: string | null, received_requests_aggregate: { __typename?: 'rangers_user_received_friend_requests_aggregate', aggregate?: { __typename?: 'rangers_user_received_friend_requests_aggregate_fields', count: number } | null } };

export type GetNavProfileQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type GetNavProfileQuery = { __typename?: 'query_root', profile?: { __typename?: 'rangers_users', id: string, handle?: string | null, received_requests_aggregate: { __typename?: 'rangers_user_received_friend_requests_aggregate', aggregate?: { __typename?: 'rangers_user_received_friend_requests_aggregate_fields', count: number } | null } } | null };

export type GetProfileQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type GetProfileQuery = { __typename?: 'query_root', profile?: { __typename?: 'rangers_users', id: string, handle?: string | null, created_at: any, friends: Array<{ __typename?: 'rangers_user_friends', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, sent_requests: Array<{ __typename?: 'rangers_user_sent_friend_requests', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, received_requests: Array<{ __typename?: 'rangers_user_received_friend_requests', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }> } | null, settings?: { __typename?: 'rangers_user_settings', user_id: string, private_decks: boolean, pack_collection?: any | null, adhere_taboos?: boolean | null } | null };

export type GetProfileByHandleQueryVariables = Exact<{
  handle: Scalars['String']['input'];
}>;


export type GetProfileByHandleQuery = { __typename?: 'query_root', profile: Array<{ __typename?: 'rangers_users', id: string, handle?: string | null, created_at: any, friends: Array<{ __typename?: 'rangers_user_friends', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, sent_requests: Array<{ __typename?: 'rangers_user_sent_friend_requests', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }>, received_requests: Array<{ __typename?: 'rangers_user_received_friend_requests', user?: { __typename?: 'rangers_users', id: string, handle?: string | null } | null }> }> };

export type UpdateFriendRequestMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  action: Scalars['String']['input'];
}>;


export type UpdateFriendRequestMutation = { __typename?: 'mutation_root', rangers_update_friend_request: Array<{ __typename?: 'rangers_users', id: string }> };

export type SetHandleMutationVariables = Exact<{
  handle: Scalars['String']['input'];
}>;


export type SetHandleMutation = { __typename?: 'mutation_root', rangers_set_handle: Array<{ __typename?: 'rangers_users', id: string, handle?: string | null }> };

export type SearchHandlesQueryVariables = Exact<{
  normalizedHandle: Scalars['String']['input'];
  normalizedHandleStart: Scalars['String']['input'];
  offset?: InputMaybe<Scalars['Int']['input']>;
}>;


export type SearchHandlesQuery = { __typename?: 'query_root', startMatch: Array<{ __typename?: 'rangers_users', id: string, handle?: string | null }>, looseMatch: Array<{ __typename?: 'rangers_users', id: string, handle?: string | null }> };

export type GetPackCollectionQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type GetPackCollectionQuery = { __typename?: 'query_root', settings?: { __typename?: 'rangers_user_settings', pack_collection?: any | null, adhere_taboos?: boolean | null } | null };

export type SetPrivateDecksMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  privateDecks: Scalars['Boolean']['input'];
}>;


export type SetPrivateDecksMutation = { __typename?: 'mutation_root', update_rangers_user_settings_by_pk?: { __typename?: 'rangers_user_settings', user_id: string, private_decks: boolean } | null };

export type SetPackCollectionMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  pack_collection: Scalars['jsonb']['input'];
}>;


export type SetPackCollectionMutation = { __typename?: 'mutation_root', update_rangers_user_settings_by_pk?: { __typename?: 'rangers_user_settings', user_id: string, pack_collection?: any | null } | null };

export type SetAdhereTaboosMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  adhereTaboos: Scalars['Boolean']['input'];
}>;


export type SetAdhereTaboosMutation = { __typename?: 'mutation_root', update_rangers_user_settings_by_pk?: { __typename?: 'rangers_user_settings', user_id: string, adhere_taboos?: boolean | null } | null };

export const AspectFragmentDoc = gql`
    fragment Aspect on rangers_aspect_localized {
  id
  name
  short_name
}
    `;
export const SetTypeFragmentDoc = gql`
    fragment SetType on rangers_set_type_localized {
  id
  name
  sets {
    id
    name
  }
}
    `;
export const UserInfoFragmentDoc = gql`
    fragment UserInfo on rangers_users {
  id
  handle
}
    `;
export const DeckFragmentDoc = gql`
    fragment Deck on rangers_deck {
  id
  user_id
  slots
  side_slots
  extra_slots
  version
  name
  description
  awa
  spi
  fit
  foc
  created_at
  updated_at
  meta
  user {
    ...UserInfo
  }
  taboo_set_id
  published
  previous_deck {
    id
    meta
    slots
    side_slots
    version
  }
  next_deck {
    id
    meta
    slots
    side_slots
    version
  }
}
    ${UserInfoFragmentDoc}`;
export const CampaignFragmentDoc = gql`
    fragment Campaign on rangers_campaign {
  id
  user_id
  name
  notes
  day
  extended_calendar
  cycle_id
  current_location
  current_path_terrain
  missions
  events
  rewards
  removed
  history
  calendar
  latest_decks {
    deck {
      ...Deck
    }
    user {
      ...UserInfo
    }
  }
  access {
    user {
      ...UserInfo
    }
  }
  next_campaign_id
  previous_campaign {
    id
  }
}
    ${DeckFragmentDoc}
${UserInfoFragmentDoc}`;
export const SearchDeckFragmentDoc = gql`
    fragment SearchDeck on rangers_search_deck {
  id
  user_id
  slots
  side_slots
  version
  name
  description
  awa
  spi
  fit
  foc
  created_at
  updated_at
  meta
  user {
    ...UserInfo
  }
  comment_count
  copy_count
  like_count
  liked_by_user
  taboo_set_id
}
    ${UserInfoFragmentDoc}`;
export const DeckWithCampaignFragmentDoc = gql`
    fragment DeckWithCampaign on rangers_deck {
  ...Deck
  comment_count
  copy_count
  like_count
  liked_by_user
  campaign {
    id
    name
  }
}
    ${DeckFragmentDoc}`;
export const BasicDeckCommentFragmentDoc = gql`
    fragment BasicDeckComment on rangers_comment {
  id
  user {
    ...UserInfo
  }
  text
  created_at
  updated_at
  response_count
  comment_id
}
    ${UserInfoFragmentDoc}`;
export const DeckDetailFragmentDoc = gql`
    fragment DeckDetail on rangers_deck {
  ...Deck
  copy_count
  comment_count
  like_count
  liked_by_user
  original_deck {
    deck {
      id
      name
      user {
        id
        handle
      }
    }
  }
  campaign {
    id
    name
    rewards
    latest_decks {
      deck {
        id
        slots
      }
    }
  }
  user {
    handle
  }
  comments(order_by: {created_at: asc}, limit: 5) {
    ...BasicDeckComment
  }
}
    ${DeckFragmentDoc}
${BasicDeckCommentFragmentDoc}`;
export const DeckCommentFragmentDoc = gql`
    fragment DeckComment on rangers_comment {
  ...BasicDeckComment
  deck_id
  responses {
    ...BasicDeckComment
  }
}
    ${BasicDeckCommentFragmentDoc}`;
export const PackFragmentDoc = gql`
    fragment Pack on rangers_pack_localized {
  id
  name
  updated_at
  locale
  position
}
    `;
export const CardFragmentDoc = gql`
    fragment Card on rangers_card_localized {
  id
  code
  name
  real_traits
  traits
  equip
  presence
  token_id
  token_name
  token_plurals
  token_count
  harm
  approach_conflict
  approach_reason
  approach_exploration
  approach_connection
  text
  set_id
  set_name
  set_type_id
  set_size
  set_type_name
  set_position
  quantity
  level
  flavor
  type_id
  type_name
  cost
  aspect_id
  aspect_name
  aspect_short_name
  progress
  imagesrc
  position
  deck_limit
  spoiler
  sun_challenge
  mountain_challenge
  crest_challenge
  pack_id
  pack_name
  pack_short_name
  pack_position
  subset_id
  subset_name
  subset_position
  subset_size
  taboo_id
  taboo_name
  taboo_date
  taboo_is_current
}
    `;
export const UserProfileFragmentDoc = gql`
    fragment UserProfile on rangers_users {
  id
  handle
  created_at
  friends {
    user {
      ...UserInfo
    }
  }
  sent_requests {
    user {
      ...UserInfo
    }
  }
  received_requests {
    user {
      ...UserInfo
    }
  }
}
    ${UserInfoFragmentDoc}`;
export const NavProfileFragmentDoc = gql`
    fragment NavProfile on rangers_users {
  id
  handle
  received_requests_aggregate {
    aggregate {
      count
    }
  }
}
    `;
export const GetMyCampaignsDocument = gql`
    query getMyCampaigns($userId: String!, $limit: Int!, $offset: Int!) {
  campaigns: rangers_user_campaign(
    where: {user_id: {_eq: $userId}, campaign: {next_campaign_id: {_is_null: true}}}
    order_by: {updated_at: desc}
    limit: $limit
    offset: $offset
  ) {
    campaign {
      ...Campaign
    }
  }
}
    ${CampaignFragmentDoc}`;

/**
 * __useGetMyCampaignsQuery__
 *
 * To run a query within a React component, call `useGetMyCampaignsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMyCampaignsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMyCampaignsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetMyCampaignsQuery(baseOptions: Apollo.QueryHookOptions<GetMyCampaignsQuery, GetMyCampaignsQueryVariables> & ({ variables: GetMyCampaignsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>(GetMyCampaignsDocument, options);
      }
export function useGetMyCampaignsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>(GetMyCampaignsDocument, options);
        }
export function useGetMyCampaignsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>(GetMyCampaignsDocument, options);
        }
export type GetMyCampaignsQueryHookResult = ReturnType<typeof useGetMyCampaignsQuery>;
export type GetMyCampaignsLazyQueryHookResult = ReturnType<typeof useGetMyCampaignsLazyQuery>;
export type GetMyCampaignsSuspenseQueryHookResult = ReturnType<typeof useGetMyCampaignsSuspenseQuery>;
export type GetMyCampaignsQueryResult = Apollo.QueryResult<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>;
export const GetMyTransferableCampaignsDocument = gql`
    query getMyTransferableCampaigns($userId: String!, $cycles: [String!]!) {
  campaigns: rangers_user_campaign(
    where: {user_id: {_eq: $userId}, campaign: {cycle_id: {_in: $cycles}, next_campaign_id: {_is_null: true}}}
    order_by: {updated_at: desc}
  ) {
    campaign {
      ...Campaign
    }
  }
}
    ${CampaignFragmentDoc}`;

/**
 * __useGetMyTransferableCampaignsQuery__
 *
 * To run a query within a React component, call `useGetMyTransferableCampaignsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMyTransferableCampaignsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMyTransferableCampaignsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      cycles: // value for 'cycles'
 *   },
 * });
 */
export function useGetMyTransferableCampaignsQuery(baseOptions: Apollo.QueryHookOptions<GetMyTransferableCampaignsQuery, GetMyTransferableCampaignsQueryVariables> & ({ variables: GetMyTransferableCampaignsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMyTransferableCampaignsQuery, GetMyTransferableCampaignsQueryVariables>(GetMyTransferableCampaignsDocument, options);
      }
export function useGetMyTransferableCampaignsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMyTransferableCampaignsQuery, GetMyTransferableCampaignsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMyTransferableCampaignsQuery, GetMyTransferableCampaignsQueryVariables>(GetMyTransferableCampaignsDocument, options);
        }
export function useGetMyTransferableCampaignsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMyTransferableCampaignsQuery, GetMyTransferableCampaignsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMyTransferableCampaignsQuery, GetMyTransferableCampaignsQueryVariables>(GetMyTransferableCampaignsDocument, options);
        }
export type GetMyTransferableCampaignsQueryHookResult = ReturnType<typeof useGetMyTransferableCampaignsQuery>;
export type GetMyTransferableCampaignsLazyQueryHookResult = ReturnType<typeof useGetMyTransferableCampaignsLazyQuery>;
export type GetMyTransferableCampaignsSuspenseQueryHookResult = ReturnType<typeof useGetMyTransferableCampaignsSuspenseQuery>;
export type GetMyTransferableCampaignsQueryResult = Apollo.QueryResult<GetMyTransferableCampaignsQuery, GetMyTransferableCampaignsQueryVariables>;
export const GetMyCampaignsTotalDocument = gql`
    query getMyCampaignsTotal($userId: String!) {
  campaigns: rangers_user_campaign_aggregate(where: {user_id: {_eq: $userId}}) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetMyCampaignsTotalQuery__
 *
 * To run a query within a React component, call `useGetMyCampaignsTotalQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMyCampaignsTotalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMyCampaignsTotalQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetMyCampaignsTotalQuery(baseOptions: Apollo.QueryHookOptions<GetMyCampaignsTotalQuery, GetMyCampaignsTotalQueryVariables> & ({ variables: GetMyCampaignsTotalQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMyCampaignsTotalQuery, GetMyCampaignsTotalQueryVariables>(GetMyCampaignsTotalDocument, options);
      }
export function useGetMyCampaignsTotalLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMyCampaignsTotalQuery, GetMyCampaignsTotalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMyCampaignsTotalQuery, GetMyCampaignsTotalQueryVariables>(GetMyCampaignsTotalDocument, options);
        }
export function useGetMyCampaignsTotalSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMyCampaignsTotalQuery, GetMyCampaignsTotalQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMyCampaignsTotalQuery, GetMyCampaignsTotalQueryVariables>(GetMyCampaignsTotalDocument, options);
        }
export type GetMyCampaignsTotalQueryHookResult = ReturnType<typeof useGetMyCampaignsTotalQuery>;
export type GetMyCampaignsTotalLazyQueryHookResult = ReturnType<typeof useGetMyCampaignsTotalLazyQuery>;
export type GetMyCampaignsTotalSuspenseQueryHookResult = ReturnType<typeof useGetMyCampaignsTotalSuspenseQuery>;
export type GetMyCampaignsTotalQueryResult = Apollo.QueryResult<GetMyCampaignsTotalQuery, GetMyCampaignsTotalQueryVariables>;
export const GetCampaignDocument = gql`
    query getCampaign($campaignId: Int!) {
  campaign: rangers_campaign_by_pk(id: $campaignId) {
    ...Campaign
  }
}
    ${CampaignFragmentDoc}`;

/**
 * __useGetCampaignQuery__
 *
 * To run a query within a React component, call `useGetCampaignQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCampaignQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCampaignQuery({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *   },
 * });
 */
export function useGetCampaignQuery(baseOptions: Apollo.QueryHookOptions<GetCampaignQuery, GetCampaignQueryVariables> & ({ variables: GetCampaignQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCampaignQuery, GetCampaignQueryVariables>(GetCampaignDocument, options);
      }
export function useGetCampaignLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCampaignQuery, GetCampaignQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCampaignQuery, GetCampaignQueryVariables>(GetCampaignDocument, options);
        }
export function useGetCampaignSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCampaignQuery, GetCampaignQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCampaignQuery, GetCampaignQueryVariables>(GetCampaignDocument, options);
        }
export type GetCampaignQueryHookResult = ReturnType<typeof useGetCampaignQuery>;
export type GetCampaignLazyQueryHookResult = ReturnType<typeof useGetCampaignLazyQuery>;
export type GetCampaignSuspenseQueryHookResult = ReturnType<typeof useGetCampaignSuspenseQuery>;
export type GetCampaignQueryResult = Apollo.QueryResult<GetCampaignQuery, GetCampaignQueryVariables>;
export const CreateCampaignDocument = gql`
    mutation createCampaign($name: String!, $cycleId: String!, $currentLocation: String!) {
  campaign: insert_rangers_campaign_one(
    object: {name: $name, cycle_id: $cycleId, current_location: $currentLocation}
  ) {
    ...Campaign
  }
}
    ${CampaignFragmentDoc}`;
export type CreateCampaignMutationFn = Apollo.MutationFunction<CreateCampaignMutation, CreateCampaignMutationVariables>;

/**
 * __useCreateCampaignMutation__
 *
 * To run a mutation, you first call `useCreateCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCampaignMutation, { data, loading, error }] = useCreateCampaignMutation({
 *   variables: {
 *      name: // value for 'name'
 *      cycleId: // value for 'cycleId'
 *      currentLocation: // value for 'currentLocation'
 *   },
 * });
 */
export function useCreateCampaignMutation(baseOptions?: Apollo.MutationHookOptions<CreateCampaignMutation, CreateCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCampaignMutation, CreateCampaignMutationVariables>(CreateCampaignDocument, options);
      }
export type CreateCampaignMutationHookResult = ReturnType<typeof useCreateCampaignMutation>;
export type CreateCampaignMutationResult = Apollo.MutationResult<CreateCampaignMutation>;
export type CreateCampaignMutationOptions = Apollo.BaseMutationOptions<CreateCampaignMutation, CreateCampaignMutationVariables>;
export const TransferCampaignDocument = gql`
    mutation transferCampaign($campaignId: Int!, $cycleId: String!, $currentLocation: String!) {
  campaign: rangers_transfer_campaign(
    args: {existing_campaign_id: $campaignId, cycle_code: $cycleId, current_location: $currentLocation}
  ) {
    ...Campaign
  }
}
    ${CampaignFragmentDoc}`;
export type TransferCampaignMutationFn = Apollo.MutationFunction<TransferCampaignMutation, TransferCampaignMutationVariables>;

/**
 * __useTransferCampaignMutation__
 *
 * To run a mutation, you first call `useTransferCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTransferCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [transferCampaignMutation, { data, loading, error }] = useTransferCampaignMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      cycleId: // value for 'cycleId'
 *      currentLocation: // value for 'currentLocation'
 *   },
 * });
 */
export function useTransferCampaignMutation(baseOptions?: Apollo.MutationHookOptions<TransferCampaignMutation, TransferCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TransferCampaignMutation, TransferCampaignMutationVariables>(TransferCampaignDocument, options);
      }
export type TransferCampaignMutationHookResult = ReturnType<typeof useTransferCampaignMutation>;
export type TransferCampaignMutationResult = Apollo.MutationResult<TransferCampaignMutation>;
export type TransferCampaignMutationOptions = Apollo.BaseMutationOptions<TransferCampaignMutation, TransferCampaignMutationVariables>;
export const SetCampaignTitleDocument = gql`
    mutation setCampaignTitle($name: String!, $campaignId: Int!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {name: $name}
  ) {
    id
    name
  }
}
    `;
export type SetCampaignTitleMutationFn = Apollo.MutationFunction<SetCampaignTitleMutation, SetCampaignTitleMutationVariables>;

/**
 * __useSetCampaignTitleMutation__
 *
 * To run a mutation, you first call `useSetCampaignTitleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetCampaignTitleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setCampaignTitleMutation, { data, loading, error }] = useSetCampaignTitleMutation({
 *   variables: {
 *      name: // value for 'name'
 *      campaignId: // value for 'campaignId'
 *   },
 * });
 */
export function useSetCampaignTitleMutation(baseOptions?: Apollo.MutationHookOptions<SetCampaignTitleMutation, SetCampaignTitleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetCampaignTitleMutation, SetCampaignTitleMutationVariables>(SetCampaignTitleDocument, options);
      }
export type SetCampaignTitleMutationHookResult = ReturnType<typeof useSetCampaignTitleMutation>;
export type SetCampaignTitleMutationResult = Apollo.MutationResult<SetCampaignTitleMutation>;
export type SetCampaignTitleMutationOptions = Apollo.BaseMutationOptions<SetCampaignTitleMutation, SetCampaignTitleMutationVariables>;
export const AddFriendToCampaignDocument = gql`
    mutation addFriendToCampaign($campaignId: Int!, $userId: String!) {
  insert_rangers_campaign_access_one(
    object: {campaign_id: $campaignId, user_id: $userId}
    on_conflict: {constraint: campaign_access_pkey}
  ) {
    campaign {
      id
      access {
        user {
          ...UserInfo
        }
      }
    }
  }
}
    ${UserInfoFragmentDoc}`;
export type AddFriendToCampaignMutationFn = Apollo.MutationFunction<AddFriendToCampaignMutation, AddFriendToCampaignMutationVariables>;

/**
 * __useAddFriendToCampaignMutation__
 *
 * To run a mutation, you first call `useAddFriendToCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddFriendToCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addFriendToCampaignMutation, { data, loading, error }] = useAddFriendToCampaignMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useAddFriendToCampaignMutation(baseOptions?: Apollo.MutationHookOptions<AddFriendToCampaignMutation, AddFriendToCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddFriendToCampaignMutation, AddFriendToCampaignMutationVariables>(AddFriendToCampaignDocument, options);
      }
export type AddFriendToCampaignMutationHookResult = ReturnType<typeof useAddFriendToCampaignMutation>;
export type AddFriendToCampaignMutationResult = Apollo.MutationResult<AddFriendToCampaignMutation>;
export type AddFriendToCampaignMutationOptions = Apollo.BaseMutationOptions<AddFriendToCampaignMutation, AddFriendToCampaignMutationVariables>;
export const RemoveFriendFromCampaignDocument = gql`
    mutation removeFriendFromCampaign($campaignId: Int!, $userId: String!) {
  delete_rangers_campaign_access_by_pk(campaign_id: $campaignId, user_id: $userId) {
    campaign {
      id
      access {
        user {
          ...UserInfo
        }
      }
    }
  }
}
    ${UserInfoFragmentDoc}`;
export type RemoveFriendFromCampaignMutationFn = Apollo.MutationFunction<RemoveFriendFromCampaignMutation, RemoveFriendFromCampaignMutationVariables>;

/**
 * __useRemoveFriendFromCampaignMutation__
 *
 * To run a mutation, you first call `useRemoveFriendFromCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveFriendFromCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeFriendFromCampaignMutation, { data, loading, error }] = useRemoveFriendFromCampaignMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useRemoveFriendFromCampaignMutation(baseOptions?: Apollo.MutationHookOptions<RemoveFriendFromCampaignMutation, RemoveFriendFromCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveFriendFromCampaignMutation, RemoveFriendFromCampaignMutationVariables>(RemoveFriendFromCampaignDocument, options);
      }
export type RemoveFriendFromCampaignMutationHookResult = ReturnType<typeof useRemoveFriendFromCampaignMutation>;
export type RemoveFriendFromCampaignMutationResult = Apollo.MutationResult<RemoveFriendFromCampaignMutation>;
export type RemoveFriendFromCampaignMutationOptions = Apollo.BaseMutationOptions<RemoveFriendFromCampaignMutation, RemoveFriendFromCampaignMutationVariables>;
export const UpdateCampaignRewardsDocument = gql`
    mutation updateCampaignRewards($campaignId: Int!, $rewards: jsonb!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {rewards: $rewards}
  ) {
    id
    rewards
  }
}
    `;
export type UpdateCampaignRewardsMutationFn = Apollo.MutationFunction<UpdateCampaignRewardsMutation, UpdateCampaignRewardsMutationVariables>;

/**
 * __useUpdateCampaignRewardsMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignRewardsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignRewardsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignRewardsMutation, { data, loading, error }] = useUpdateCampaignRewardsMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      rewards: // value for 'rewards'
 *   },
 * });
 */
export function useUpdateCampaignRewardsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignRewardsMutation, UpdateCampaignRewardsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignRewardsMutation, UpdateCampaignRewardsMutationVariables>(UpdateCampaignRewardsDocument, options);
      }
export type UpdateCampaignRewardsMutationHookResult = ReturnType<typeof useUpdateCampaignRewardsMutation>;
export type UpdateCampaignRewardsMutationResult = Apollo.MutationResult<UpdateCampaignRewardsMutation>;
export type UpdateCampaignRewardsMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignRewardsMutation, UpdateCampaignRewardsMutationVariables>;
export const AddCampaignEventDocument = gql`
    mutation addCampaignEvent($campaignId: Int!, $event: jsonb!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _append: {events: $event}
  ) {
    id
    events
  }
}
    `;
export type AddCampaignEventMutationFn = Apollo.MutationFunction<AddCampaignEventMutation, AddCampaignEventMutationVariables>;

/**
 * __useAddCampaignEventMutation__
 *
 * To run a mutation, you first call `useAddCampaignEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCampaignEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCampaignEventMutation, { data, loading, error }] = useAddCampaignEventMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      event: // value for 'event'
 *   },
 * });
 */
export function useAddCampaignEventMutation(baseOptions?: Apollo.MutationHookOptions<AddCampaignEventMutation, AddCampaignEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCampaignEventMutation, AddCampaignEventMutationVariables>(AddCampaignEventDocument, options);
      }
export type AddCampaignEventMutationHookResult = ReturnType<typeof useAddCampaignEventMutation>;
export type AddCampaignEventMutationResult = Apollo.MutationResult<AddCampaignEventMutation>;
export type AddCampaignEventMutationOptions = Apollo.BaseMutationOptions<AddCampaignEventMutation, AddCampaignEventMutationVariables>;
export const AddCampaignNoteDocument = gql`
    mutation addCampaignNote($campaignId: Int!, $note: jsonb!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _append: {notes: $note}
  ) {
    id
    notes
  }
}
    `;
export type AddCampaignNoteMutationFn = Apollo.MutationFunction<AddCampaignNoteMutation, AddCampaignNoteMutationVariables>;

/**
 * __useAddCampaignNoteMutation__
 *
 * To run a mutation, you first call `useAddCampaignNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCampaignNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCampaignNoteMutation, { data, loading, error }] = useAddCampaignNoteMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      note: // value for 'note'
 *   },
 * });
 */
export function useAddCampaignNoteMutation(baseOptions?: Apollo.MutationHookOptions<AddCampaignNoteMutation, AddCampaignNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCampaignNoteMutation, AddCampaignNoteMutationVariables>(AddCampaignNoteDocument, options);
      }
export type AddCampaignNoteMutationHookResult = ReturnType<typeof useAddCampaignNoteMutation>;
export type AddCampaignNoteMutationResult = Apollo.MutationResult<AddCampaignNoteMutation>;
export type AddCampaignNoteMutationOptions = Apollo.BaseMutationOptions<AddCampaignNoteMutation, AddCampaignNoteMutationVariables>;
export const UpdateCampaignRemovedDocument = gql`
    mutation updateCampaignRemoved($campaignId: Int!, $removed: jsonb!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {removed: $removed}
  ) {
    id
    removed
  }
}
    `;
export type UpdateCampaignRemovedMutationFn = Apollo.MutationFunction<UpdateCampaignRemovedMutation, UpdateCampaignRemovedMutationVariables>;

/**
 * __useUpdateCampaignRemovedMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignRemovedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignRemovedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignRemovedMutation, { data, loading, error }] = useUpdateCampaignRemovedMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      removed: // value for 'removed'
 *   },
 * });
 */
export function useUpdateCampaignRemovedMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignRemovedMutation, UpdateCampaignRemovedMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignRemovedMutation, UpdateCampaignRemovedMutationVariables>(UpdateCampaignRemovedDocument, options);
      }
export type UpdateCampaignRemovedMutationHookResult = ReturnType<typeof useUpdateCampaignRemovedMutation>;
export type UpdateCampaignRemovedMutationResult = Apollo.MutationResult<UpdateCampaignRemovedMutation>;
export type UpdateCampaignRemovedMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignRemovedMutation, UpdateCampaignRemovedMutationVariables>;
export const AddCampaignRemovedDocument = gql`
    mutation addCampaignRemoved($campaignId: Int!, $removed: jsonb!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _append: {removed: $removed}
  ) {
    id
    removed
  }
}
    `;
export type AddCampaignRemovedMutationFn = Apollo.MutationFunction<AddCampaignRemovedMutation, AddCampaignRemovedMutationVariables>;

/**
 * __useAddCampaignRemovedMutation__
 *
 * To run a mutation, you first call `useAddCampaignRemovedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCampaignRemovedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCampaignRemovedMutation, { data, loading, error }] = useAddCampaignRemovedMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      removed: // value for 'removed'
 *   },
 * });
 */
export function useAddCampaignRemovedMutation(baseOptions?: Apollo.MutationHookOptions<AddCampaignRemovedMutation, AddCampaignRemovedMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCampaignRemovedMutation, AddCampaignRemovedMutationVariables>(AddCampaignRemovedDocument, options);
      }
export type AddCampaignRemovedMutationHookResult = ReturnType<typeof useAddCampaignRemovedMutation>;
export type AddCampaignRemovedMutationResult = Apollo.MutationResult<AddCampaignRemovedMutation>;
export type AddCampaignRemovedMutationOptions = Apollo.BaseMutationOptions<AddCampaignRemovedMutation, AddCampaignRemovedMutationVariables>;
export const UpdateCampaignNotesDocument = gql`
    mutation updateCampaignNotes($campaignId: Int!, $notes: jsonb!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {notes: $notes}
  ) {
    id
    notes
  }
}
    `;
export type UpdateCampaignNotesMutationFn = Apollo.MutationFunction<UpdateCampaignNotesMutation, UpdateCampaignNotesMutationVariables>;

/**
 * __useUpdateCampaignNotesMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignNotesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignNotesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignNotesMutation, { data, loading, error }] = useUpdateCampaignNotesMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      notes: // value for 'notes'
 *   },
 * });
 */
export function useUpdateCampaignNotesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignNotesMutation, UpdateCampaignNotesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignNotesMutation, UpdateCampaignNotesMutationVariables>(UpdateCampaignNotesDocument, options);
      }
export type UpdateCampaignNotesMutationHookResult = ReturnType<typeof useUpdateCampaignNotesMutation>;
export type UpdateCampaignNotesMutationResult = Apollo.MutationResult<UpdateCampaignNotesMutation>;
export type UpdateCampaignNotesMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignNotesMutation, UpdateCampaignNotesMutationVariables>;
export const ExtendCampaignDocument = gql`
    mutation extendCampaign($campaignId: Int!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {extended_calendar: true}
  ) {
    id
    extended_calendar
  }
}
    `;
export type ExtendCampaignMutationFn = Apollo.MutationFunction<ExtendCampaignMutation, ExtendCampaignMutationVariables>;

/**
 * __useExtendCampaignMutation__
 *
 * To run a mutation, you first call `useExtendCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useExtendCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [extendCampaignMutation, { data, loading, error }] = useExtendCampaignMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *   },
 * });
 */
export function useExtendCampaignMutation(baseOptions?: Apollo.MutationHookOptions<ExtendCampaignMutation, ExtendCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ExtendCampaignMutation, ExtendCampaignMutationVariables>(ExtendCampaignDocument, options);
      }
export type ExtendCampaignMutationHookResult = ReturnType<typeof useExtendCampaignMutation>;
export type ExtendCampaignMutationResult = Apollo.MutationResult<ExtendCampaignMutation>;
export type ExtendCampaignMutationOptions = Apollo.BaseMutationOptions<ExtendCampaignMutation, ExtendCampaignMutationVariables>;
export const UpdateCampaignEventsDocument = gql`
    mutation updateCampaignEvents($campaignId: Int!, $events: jsonb!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {events: $events}
  ) {
    id
    events
  }
}
    `;
export type UpdateCampaignEventsMutationFn = Apollo.MutationFunction<UpdateCampaignEventsMutation, UpdateCampaignEventsMutationVariables>;

/**
 * __useUpdateCampaignEventsMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignEventsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignEventsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignEventsMutation, { data, loading, error }] = useUpdateCampaignEventsMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      events: // value for 'events'
 *   },
 * });
 */
export function useUpdateCampaignEventsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignEventsMutation, UpdateCampaignEventsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignEventsMutation, UpdateCampaignEventsMutationVariables>(UpdateCampaignEventsDocument, options);
      }
export type UpdateCampaignEventsMutationHookResult = ReturnType<typeof useUpdateCampaignEventsMutation>;
export type UpdateCampaignEventsMutationResult = Apollo.MutationResult<UpdateCampaignEventsMutation>;
export type UpdateCampaignEventsMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignEventsMutation, UpdateCampaignEventsMutationVariables>;
export const SetCampaignLocationDocument = gql`
    mutation setCampaignLocation($campaignId: Int!, $location: String!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {current_location: $location}
  ) {
    id
    current_location
  }
}
    `;
export type SetCampaignLocationMutationFn = Apollo.MutationFunction<SetCampaignLocationMutation, SetCampaignLocationMutationVariables>;

/**
 * __useSetCampaignLocationMutation__
 *
 * To run a mutation, you first call `useSetCampaignLocationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetCampaignLocationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setCampaignLocationMutation, { data, loading, error }] = useSetCampaignLocationMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      location: // value for 'location'
 *   },
 * });
 */
export function useSetCampaignLocationMutation(baseOptions?: Apollo.MutationHookOptions<SetCampaignLocationMutation, SetCampaignLocationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetCampaignLocationMutation, SetCampaignLocationMutationVariables>(SetCampaignLocationDocument, options);
      }
export type SetCampaignLocationMutationHookResult = ReturnType<typeof useSetCampaignLocationMutation>;
export type SetCampaignLocationMutationResult = Apollo.MutationResult<SetCampaignLocationMutation>;
export type SetCampaignLocationMutationOptions = Apollo.BaseMutationOptions<SetCampaignLocationMutation, SetCampaignLocationMutationVariables>;
export const SetCampaignPathTerrainDocument = gql`
    mutation setCampaignPathTerrain($campaignId: Int!, $terrain: String!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {current_path_terrain: $terrain}
  ) {
    id
    current_path_terrain
  }
}
    `;
export type SetCampaignPathTerrainMutationFn = Apollo.MutationFunction<SetCampaignPathTerrainMutation, SetCampaignPathTerrainMutationVariables>;

/**
 * __useSetCampaignPathTerrainMutation__
 *
 * To run a mutation, you first call `useSetCampaignPathTerrainMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetCampaignPathTerrainMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setCampaignPathTerrainMutation, { data, loading, error }] = useSetCampaignPathTerrainMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      terrain: // value for 'terrain'
 *   },
 * });
 */
export function useSetCampaignPathTerrainMutation(baseOptions?: Apollo.MutationHookOptions<SetCampaignPathTerrainMutation, SetCampaignPathTerrainMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetCampaignPathTerrainMutation, SetCampaignPathTerrainMutationVariables>(SetCampaignPathTerrainDocument, options);
      }
export type SetCampaignPathTerrainMutationHookResult = ReturnType<typeof useSetCampaignPathTerrainMutation>;
export type SetCampaignPathTerrainMutationResult = Apollo.MutationResult<SetCampaignPathTerrainMutation>;
export type SetCampaignPathTerrainMutationOptions = Apollo.BaseMutationOptions<SetCampaignPathTerrainMutation, SetCampaignPathTerrainMutationVariables>;
export const AddCampaignMissionDocument = gql`
    mutation addCampaignMission($campaignId: Int!, $mission: jsonb!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _append: {missions: $mission}
  ) {
    id
    missions
  }
}
    `;
export type AddCampaignMissionMutationFn = Apollo.MutationFunction<AddCampaignMissionMutation, AddCampaignMissionMutationVariables>;

/**
 * __useAddCampaignMissionMutation__
 *
 * To run a mutation, you first call `useAddCampaignMissionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCampaignMissionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCampaignMissionMutation, { data, loading, error }] = useAddCampaignMissionMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      mission: // value for 'mission'
 *   },
 * });
 */
export function useAddCampaignMissionMutation(baseOptions?: Apollo.MutationHookOptions<AddCampaignMissionMutation, AddCampaignMissionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCampaignMissionMutation, AddCampaignMissionMutationVariables>(AddCampaignMissionDocument, options);
      }
export type AddCampaignMissionMutationHookResult = ReturnType<typeof useAddCampaignMissionMutation>;
export type AddCampaignMissionMutationResult = Apollo.MutationResult<AddCampaignMissionMutation>;
export type AddCampaignMissionMutationOptions = Apollo.BaseMutationOptions<AddCampaignMissionMutation, AddCampaignMissionMutationVariables>;
export const SetCampaignMissionsDocument = gql`
    mutation setCampaignMissions($campaignId: Int!, $missions: jsonb!) {
  update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {missions: $missions}
  ) {
    id
    missions
  }
}
    `;
export type SetCampaignMissionsMutationFn = Apollo.MutationFunction<SetCampaignMissionsMutation, SetCampaignMissionsMutationVariables>;

/**
 * __useSetCampaignMissionsMutation__
 *
 * To run a mutation, you first call `useSetCampaignMissionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetCampaignMissionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setCampaignMissionsMutation, { data, loading, error }] = useSetCampaignMissionsMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      missions: // value for 'missions'
 *   },
 * });
 */
export function useSetCampaignMissionsMutation(baseOptions?: Apollo.MutationHookOptions<SetCampaignMissionsMutation, SetCampaignMissionsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetCampaignMissionsMutation, SetCampaignMissionsMutationVariables>(SetCampaignMissionsDocument, options);
      }
export type SetCampaignMissionsMutationHookResult = ReturnType<typeof useSetCampaignMissionsMutation>;
export type SetCampaignMissionsMutationResult = Apollo.MutationResult<SetCampaignMissionsMutation>;
export type SetCampaignMissionsMutationOptions = Apollo.BaseMutationOptions<SetCampaignMissionsMutation, SetCampaignMissionsMutationVariables>;
export const SetCampaignCalendarDocument = gql`
    mutation setCampaignCalendar($campaignId: Int!, $calendar: jsonb!) {
  campaign: update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {calendar: $calendar}
  ) {
    id
    calendar
  }
}
    `;
export type SetCampaignCalendarMutationFn = Apollo.MutationFunction<SetCampaignCalendarMutation, SetCampaignCalendarMutationVariables>;

/**
 * __useSetCampaignCalendarMutation__
 *
 * To run a mutation, you first call `useSetCampaignCalendarMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetCampaignCalendarMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setCampaignCalendarMutation, { data, loading, error }] = useSetCampaignCalendarMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      calendar: // value for 'calendar'
 *   },
 * });
 */
export function useSetCampaignCalendarMutation(baseOptions?: Apollo.MutationHookOptions<SetCampaignCalendarMutation, SetCampaignCalendarMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetCampaignCalendarMutation, SetCampaignCalendarMutationVariables>(SetCampaignCalendarDocument, options);
      }
export type SetCampaignCalendarMutationHookResult = ReturnType<typeof useSetCampaignCalendarMutation>;
export type SetCampaignCalendarMutationResult = Apollo.MutationResult<SetCampaignCalendarMutation>;
export type SetCampaignCalendarMutationOptions = Apollo.BaseMutationOptions<SetCampaignCalendarMutation, SetCampaignCalendarMutationVariables>;
export const SetCampaignDayDocument = gql`
    mutation setCampaignDay($campaignId: Int!, $day: Int!) {
  campaign: update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {day: $day}
  ) {
    id
    day
  }
}
    `;
export type SetCampaignDayMutationFn = Apollo.MutationFunction<SetCampaignDayMutation, SetCampaignDayMutationVariables>;

/**
 * __useSetCampaignDayMutation__
 *
 * To run a mutation, you first call `useSetCampaignDayMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetCampaignDayMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setCampaignDayMutation, { data, loading, error }] = useSetCampaignDayMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      day: // value for 'day'
 *   },
 * });
 */
export function useSetCampaignDayMutation(baseOptions?: Apollo.MutationHookOptions<SetCampaignDayMutation, SetCampaignDayMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetCampaignDayMutation, SetCampaignDayMutationVariables>(SetCampaignDayDocument, options);
      }
export type SetCampaignDayMutationHookResult = ReturnType<typeof useSetCampaignDayMutation>;
export type SetCampaignDayMutationResult = Apollo.MutationResult<SetCampaignDayMutation>;
export type SetCampaignDayMutationOptions = Apollo.BaseMutationOptions<SetCampaignDayMutation, SetCampaignDayMutationVariables>;
export const AddCampaignHistoryDocument = gql`
    mutation addCampaignHistory($campaignId: Int!, $history: jsonb!, $day: Int!) {
  campaign: update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {day: $day}
    _append: {history: $history}
  ) {
    id
    history
  }
}
    `;
export type AddCampaignHistoryMutationFn = Apollo.MutationFunction<AddCampaignHistoryMutation, AddCampaignHistoryMutationVariables>;

/**
 * __useAddCampaignHistoryMutation__
 *
 * To run a mutation, you first call `useAddCampaignHistoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCampaignHistoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCampaignHistoryMutation, { data, loading, error }] = useAddCampaignHistoryMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      history: // value for 'history'
 *      day: // value for 'day'
 *   },
 * });
 */
export function useAddCampaignHistoryMutation(baseOptions?: Apollo.MutationHookOptions<AddCampaignHistoryMutation, AddCampaignHistoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCampaignHistoryMutation, AddCampaignHistoryMutationVariables>(AddCampaignHistoryDocument, options);
      }
export type AddCampaignHistoryMutationHookResult = ReturnType<typeof useAddCampaignHistoryMutation>;
export type AddCampaignHistoryMutationResult = Apollo.MutationResult<AddCampaignHistoryMutation>;
export type AddCampaignHistoryMutationOptions = Apollo.BaseMutationOptions<AddCampaignHistoryMutation, AddCampaignHistoryMutationVariables>;
export const CampaignUndoTravelDocument = gql`
    mutation campaignUndoTravel($campaignId: Int!, $history: jsonb!, $previousDay: Int!, $previousLocation: String!, $previousPathTerrain: String) {
  campaign: update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {day: $previousDay, current_location: $previousLocation, current_path_terrain: $previousPathTerrain, history: $history}
  ) {
    id
    day
    history
    current_location
    current_path_terrain
  }
}
    `;
export type CampaignUndoTravelMutationFn = Apollo.MutationFunction<CampaignUndoTravelMutation, CampaignUndoTravelMutationVariables>;

/**
 * __useCampaignUndoTravelMutation__
 *
 * To run a mutation, you first call `useCampaignUndoTravelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCampaignUndoTravelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [campaignUndoTravelMutation, { data, loading, error }] = useCampaignUndoTravelMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      history: // value for 'history'
 *      previousDay: // value for 'previousDay'
 *      previousLocation: // value for 'previousLocation'
 *      previousPathTerrain: // value for 'previousPathTerrain'
 *   },
 * });
 */
export function useCampaignUndoTravelMutation(baseOptions?: Apollo.MutationHookOptions<CampaignUndoTravelMutation, CampaignUndoTravelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CampaignUndoTravelMutation, CampaignUndoTravelMutationVariables>(CampaignUndoTravelDocument, options);
      }
export type CampaignUndoTravelMutationHookResult = ReturnType<typeof useCampaignUndoTravelMutation>;
export type CampaignUndoTravelMutationResult = Apollo.MutationResult<CampaignUndoTravelMutation>;
export type CampaignUndoTravelMutationOptions = Apollo.BaseMutationOptions<CampaignUndoTravelMutation, CampaignUndoTravelMutationVariables>;
export const CampaignTravelDocument = gql`
    mutation campaignTravel($campaignId: Int!, $day: Int!, $currentLocation: String!, $currentPathTerrain: String!, $history: jsonb!) {
  campaign: update_rangers_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {day: $day, current_location: $currentLocation, current_path_terrain: $currentPathTerrain}
    _append: {history: $history}
  ) {
    id
    day
    history
    current_location
    current_path_terrain
  }
}
    `;
export type CampaignTravelMutationFn = Apollo.MutationFunction<CampaignTravelMutation, CampaignTravelMutationVariables>;

/**
 * __useCampaignTravelMutation__
 *
 * To run a mutation, you first call `useCampaignTravelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCampaignTravelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [campaignTravelMutation, { data, loading, error }] = useCampaignTravelMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      day: // value for 'day'
 *      currentLocation: // value for 'currentLocation'
 *      currentPathTerrain: // value for 'currentPathTerrain'
 *      history: // value for 'history'
 *   },
 * });
 */
export function useCampaignTravelMutation(baseOptions?: Apollo.MutationHookOptions<CampaignTravelMutation, CampaignTravelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CampaignTravelMutation, CampaignTravelMutationVariables>(CampaignTravelDocument, options);
      }
export type CampaignTravelMutationHookResult = ReturnType<typeof useCampaignTravelMutation>;
export type CampaignTravelMutationResult = Apollo.MutationResult<CampaignTravelMutation>;
export type CampaignTravelMutationOptions = Apollo.BaseMutationOptions<CampaignTravelMutation, CampaignTravelMutationVariables>;
export const LeaveCampaignDocument = gql`
    mutation leaveCampaign($campaignId: Int!, $userId: String!) {
  delete_rangers_campaign_access_by_pk(campaign_id: $campaignId, user_id: $userId) {
    campaign_id
    user_id
  }
}
    `;
export type LeaveCampaignMutationFn = Apollo.MutationFunction<LeaveCampaignMutation, LeaveCampaignMutationVariables>;

/**
 * __useLeaveCampaignMutation__
 *
 * To run a mutation, you first call `useLeaveCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLeaveCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [leaveCampaignMutation, { data, loading, error }] = useLeaveCampaignMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useLeaveCampaignMutation(baseOptions?: Apollo.MutationHookOptions<LeaveCampaignMutation, LeaveCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LeaveCampaignMutation, LeaveCampaignMutationVariables>(LeaveCampaignDocument, options);
      }
export type LeaveCampaignMutationHookResult = ReturnType<typeof useLeaveCampaignMutation>;
export type LeaveCampaignMutationResult = Apollo.MutationResult<LeaveCampaignMutation>;
export type LeaveCampaignMutationOptions = Apollo.BaseMutationOptions<LeaveCampaignMutation, LeaveCampaignMutationVariables>;
export const DeleteCampaignDocument = gql`
    mutation deleteCampaign($campaignId: Int!) {
  rangers_remove_campaign(args: {campaign_id: $campaignId}) {
    id
  }
}
    `;
export type DeleteCampaignMutationFn = Apollo.MutationFunction<DeleteCampaignMutation, DeleteCampaignMutationVariables>;

/**
 * __useDeleteCampaignMutation__
 *
 * To run a mutation, you first call `useDeleteCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCampaignMutation, { data, loading, error }] = useDeleteCampaignMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *   },
 * });
 */
export function useDeleteCampaignMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCampaignMutation, DeleteCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCampaignMutation, DeleteCampaignMutationVariables>(DeleteCampaignDocument, options);
      }
export type DeleteCampaignMutationHookResult = ReturnType<typeof useDeleteCampaignMutation>;
export type DeleteCampaignMutationResult = Apollo.MutationResult<DeleteCampaignMutation>;
export type DeleteCampaignMutationOptions = Apollo.BaseMutationOptions<DeleteCampaignMutation, DeleteCampaignMutationVariables>;
export const GetAllPacksDocument = gql`
    query getAllPacks($locale: String!) {
  packs: rangers_pack_localized(
    where: {locale: {_eq: $locale}}
    order_by: {position: asc}
  ) {
    ...Pack
  }
}
    ${PackFragmentDoc}`;

/**
 * __useGetAllPacksQuery__
 *
 * To run a query within a React component, call `useGetAllPacksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllPacksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllPacksQuery({
 *   variables: {
 *      locale: // value for 'locale'
 *   },
 * });
 */
export function useGetAllPacksQuery(baseOptions: Apollo.QueryHookOptions<GetAllPacksQuery, GetAllPacksQueryVariables> & ({ variables: GetAllPacksQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllPacksQuery, GetAllPacksQueryVariables>(GetAllPacksDocument, options);
      }
export function useGetAllPacksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllPacksQuery, GetAllPacksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllPacksQuery, GetAllPacksQueryVariables>(GetAllPacksDocument, options);
        }
export function useGetAllPacksSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAllPacksQuery, GetAllPacksQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAllPacksQuery, GetAllPacksQueryVariables>(GetAllPacksDocument, options);
        }
export type GetAllPacksQueryHookResult = ReturnType<typeof useGetAllPacksQuery>;
export type GetAllPacksLazyQueryHookResult = ReturnType<typeof useGetAllPacksLazyQuery>;
export type GetAllPacksSuspenseQueryHookResult = ReturnType<typeof useGetAllPacksSuspenseQuery>;
export type GetAllPacksQueryResult = Apollo.QueryResult<GetAllPacksQuery, GetAllPacksQueryVariables>;
export const GetAllCardsDocument = gql`
    query getAllCards($locale: String!) {
  cards: rangers_card_localized(where: {locale: {_eq: $locale}}) {
    ...Card
  }
  all_updated_at: rangers_card_updated(where: {locale: {_eq: $locale}}) {
    updated_at
  }
}
    ${CardFragmentDoc}`;

/**
 * __useGetAllCardsQuery__
 *
 * To run a query within a React component, call `useGetAllCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllCardsQuery({
 *   variables: {
 *      locale: // value for 'locale'
 *   },
 * });
 */
export function useGetAllCardsQuery(baseOptions: Apollo.QueryHookOptions<GetAllCardsQuery, GetAllCardsQueryVariables> & ({ variables: GetAllCardsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllCardsQuery, GetAllCardsQueryVariables>(GetAllCardsDocument, options);
      }
export function useGetAllCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllCardsQuery, GetAllCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllCardsQuery, GetAllCardsQueryVariables>(GetAllCardsDocument, options);
        }
export function useGetAllCardsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetAllCardsQuery, GetAllCardsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetAllCardsQuery, GetAllCardsQueryVariables>(GetAllCardsDocument, options);
        }
export type GetAllCardsQueryHookResult = ReturnType<typeof useGetAllCardsQuery>;
export type GetAllCardsLazyQueryHookResult = ReturnType<typeof useGetAllCardsLazyQuery>;
export type GetAllCardsSuspenseQueryHookResult = ReturnType<typeof useGetAllCardsSuspenseQuery>;
export type GetAllCardsQueryResult = Apollo.QueryResult<GetAllCardsQuery, GetAllCardsQueryVariables>;
export const GetRoleCardsDocument = gql`
    query getRoleCards($locale: String!) {
  cards: rangers_card_localized(
    where: {locale: {_eq: $locale}, type_id: {_eq: "role"}}
  ) {
    ...Card
  }
}
    ${CardFragmentDoc}`;

/**
 * __useGetRoleCardsQuery__
 *
 * To run a query within a React component, call `useGetRoleCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoleCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoleCardsQuery({
 *   variables: {
 *      locale: // value for 'locale'
 *   },
 * });
 */
export function useGetRoleCardsQuery(baseOptions: Apollo.QueryHookOptions<GetRoleCardsQuery, GetRoleCardsQueryVariables> & ({ variables: GetRoleCardsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoleCardsQuery, GetRoleCardsQueryVariables>(GetRoleCardsDocument, options);
      }
export function useGetRoleCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoleCardsQuery, GetRoleCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoleCardsQuery, GetRoleCardsQueryVariables>(GetRoleCardsDocument, options);
        }
export function useGetRoleCardsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRoleCardsQuery, GetRoleCardsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRoleCardsQuery, GetRoleCardsQueryVariables>(GetRoleCardsDocument, options);
        }
export type GetRoleCardsQueryHookResult = ReturnType<typeof useGetRoleCardsQuery>;
export type GetRoleCardsLazyQueryHookResult = ReturnType<typeof useGetRoleCardsLazyQuery>;
export type GetRoleCardsSuspenseQueryHookResult = ReturnType<typeof useGetRoleCardsSuspenseQuery>;
export type GetRoleCardsQueryResult = Apollo.QueryResult<GetRoleCardsQuery, GetRoleCardsQueryVariables>;
export const GetCardDocument = gql`
    query getCard($locale: String!, $cid: String!) {
  cards: rangers_card_localized(where: {locale: {_eq: $locale}, id: {_eq: $cid}}) {
    ...Card
  }
}
    ${CardFragmentDoc}`;

/**
 * __useGetCardQuery__
 *
 * To run a query within a React component, call `useGetCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCardQuery({
 *   variables: {
 *      locale: // value for 'locale'
 *      cid: // value for 'cid'
 *   },
 * });
 */
export function useGetCardQuery(baseOptions: Apollo.QueryHookOptions<GetCardQuery, GetCardQueryVariables> & ({ variables: GetCardQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCardQuery, GetCardQueryVariables>(GetCardDocument, options);
      }
export function useGetCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCardQuery, GetCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCardQuery, GetCardQueryVariables>(GetCardDocument, options);
        }
export function useGetCardSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCardQuery, GetCardQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCardQuery, GetCardQueryVariables>(GetCardDocument, options);
        }
export type GetCardQueryHookResult = ReturnType<typeof useGetCardQuery>;
export type GetCardLazyQueryHookResult = ReturnType<typeof useGetCardLazyQuery>;
export type GetCardSuspenseQueryHookResult = ReturnType<typeof useGetCardSuspenseQuery>;
export type GetCardQueryResult = Apollo.QueryResult<GetCardQuery, GetCardQueryVariables>;
export const GetCardsUpdatedAtDocument = gql`
    query getCardsUpdatedAt($locale: String!) {
  card_updated_at: rangers_card_updated(where: {locale: {_eq: $locale}}) {
    updated_at
  }
}
    `;

/**
 * __useGetCardsUpdatedAtQuery__
 *
 * To run a query within a React component, call `useGetCardsUpdatedAtQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCardsUpdatedAtQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCardsUpdatedAtQuery({
 *   variables: {
 *      locale: // value for 'locale'
 *   },
 * });
 */
export function useGetCardsUpdatedAtQuery(baseOptions: Apollo.QueryHookOptions<GetCardsUpdatedAtQuery, GetCardsUpdatedAtQueryVariables> & ({ variables: GetCardsUpdatedAtQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCardsUpdatedAtQuery, GetCardsUpdatedAtQueryVariables>(GetCardsUpdatedAtDocument, options);
      }
export function useGetCardsUpdatedAtLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCardsUpdatedAtQuery, GetCardsUpdatedAtQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCardsUpdatedAtQuery, GetCardsUpdatedAtQueryVariables>(GetCardsUpdatedAtDocument, options);
        }
export function useGetCardsUpdatedAtSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCardsUpdatedAtQuery, GetCardsUpdatedAtQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCardsUpdatedAtQuery, GetCardsUpdatedAtQueryVariables>(GetCardsUpdatedAtDocument, options);
        }
export type GetCardsUpdatedAtQueryHookResult = ReturnType<typeof useGetCardsUpdatedAtQuery>;
export type GetCardsUpdatedAtLazyQueryHookResult = ReturnType<typeof useGetCardsUpdatedAtLazyQuery>;
export type GetCardsUpdatedAtSuspenseQueryHookResult = ReturnType<typeof useGetCardsUpdatedAtSuspenseQuery>;
export type GetCardsUpdatedAtQueryResult = Apollo.QueryResult<GetCardsUpdatedAtQuery, GetCardsUpdatedAtQueryVariables>;
export const GetSetNamesDocument = gql`
    query getSetNames($locale: String!) {
  sets: rangers_set_type_localized(
    where: {locale: {_eq: $locale}}
    order_by: {id: desc}
  ) {
    ...SetType
  }
}
    ${SetTypeFragmentDoc}`;

/**
 * __useGetSetNamesQuery__
 *
 * To run a query within a React component, call `useGetSetNamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSetNamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSetNamesQuery({
 *   variables: {
 *      locale: // value for 'locale'
 *   },
 * });
 */
export function useGetSetNamesQuery(baseOptions: Apollo.QueryHookOptions<GetSetNamesQuery, GetSetNamesQueryVariables> & ({ variables: GetSetNamesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSetNamesQuery, GetSetNamesQueryVariables>(GetSetNamesDocument, options);
      }
export function useGetSetNamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSetNamesQuery, GetSetNamesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSetNamesQuery, GetSetNamesQueryVariables>(GetSetNamesDocument, options);
        }
export function useGetSetNamesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSetNamesQuery, GetSetNamesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSetNamesQuery, GetSetNamesQueryVariables>(GetSetNamesDocument, options);
        }
export type GetSetNamesQueryHookResult = ReturnType<typeof useGetSetNamesQuery>;
export type GetSetNamesLazyQueryHookResult = ReturnType<typeof useGetSetNamesLazyQuery>;
export type GetSetNamesSuspenseQueryHookResult = ReturnType<typeof useGetSetNamesSuspenseQuery>;
export type GetSetNamesQueryResult = Apollo.QueryResult<GetSetNamesQuery, GetSetNamesQueryVariables>;
export const UpgradeDeckDocument = gql`
    mutation upgradeDeck($deckId: Int!) {
  deck: rangers_upgrade_deck(args: {deck_id: $deckId, upgrade_data: {}}) {
    id
    next_deck_id
  }
}
    `;
export type UpgradeDeckMutationFn = Apollo.MutationFunction<UpgradeDeckMutation, UpgradeDeckMutationVariables>;

/**
 * __useUpgradeDeckMutation__
 *
 * To run a mutation, you first call `useUpgradeDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpgradeDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upgradeDeckMutation, { data, loading, error }] = useUpgradeDeckMutation({
 *   variables: {
 *      deckId: // value for 'deckId'
 *   },
 * });
 */
export function useUpgradeDeckMutation(baseOptions?: Apollo.MutationHookOptions<UpgradeDeckMutation, UpgradeDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpgradeDeckMutation, UpgradeDeckMutationVariables>(UpgradeDeckDocument, options);
      }
export type UpgradeDeckMutationHookResult = ReturnType<typeof useUpgradeDeckMutation>;
export type UpgradeDeckMutationResult = Apollo.MutationResult<UpgradeDeckMutation>;
export type UpgradeDeckMutationOptions = Apollo.BaseMutationOptions<UpgradeDeckMutation, UpgradeDeckMutationVariables>;
export const PublishDeckDocument = gql`
    mutation publishDeck($deckId: Int!) {
  deck: rangers_publish_deck(args: {deck_id: $deckId}) {
    id
  }
}
    `;
export type PublishDeckMutationFn = Apollo.MutationFunction<PublishDeckMutation, PublishDeckMutationVariables>;

/**
 * __usePublishDeckMutation__
 *
 * To run a mutation, you first call `usePublishDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePublishDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [publishDeckMutation, { data, loading, error }] = usePublishDeckMutation({
 *   variables: {
 *      deckId: // value for 'deckId'
 *   },
 * });
 */
export function usePublishDeckMutation(baseOptions?: Apollo.MutationHookOptions<PublishDeckMutation, PublishDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PublishDeckMutation, PublishDeckMutationVariables>(PublishDeckDocument, options);
      }
export type PublishDeckMutationHookResult = ReturnType<typeof usePublishDeckMutation>;
export type PublishDeckMutationResult = Apollo.MutationResult<PublishDeckMutation>;
export type PublishDeckMutationOptions = Apollo.BaseMutationOptions<PublishDeckMutation, PublishDeckMutationVariables>;
export const SetDeckCampaignDocument = gql`
    mutation setDeckCampaign($deckId: Int!, $campaignId: Int!) {
  campaign: rangers_set_campaign_deck(
    args: {deck_id: $deckId, new_campaign_id: $campaignId}
  ) {
    id
  }
}
    `;
export type SetDeckCampaignMutationFn = Apollo.MutationFunction<SetDeckCampaignMutation, SetDeckCampaignMutationVariables>;

/**
 * __useSetDeckCampaignMutation__
 *
 * To run a mutation, you first call `useSetDeckCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetDeckCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setDeckCampaignMutation, { data, loading, error }] = useSetDeckCampaignMutation({
 *   variables: {
 *      deckId: // value for 'deckId'
 *      campaignId: // value for 'campaignId'
 *   },
 * });
 */
export function useSetDeckCampaignMutation(baseOptions?: Apollo.MutationHookOptions<SetDeckCampaignMutation, SetDeckCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetDeckCampaignMutation, SetDeckCampaignMutationVariables>(SetDeckCampaignDocument, options);
      }
export type SetDeckCampaignMutationHookResult = ReturnType<typeof useSetDeckCampaignMutation>;
export type SetDeckCampaignMutationResult = Apollo.MutationResult<SetDeckCampaignMutation>;
export type SetDeckCampaignMutationOptions = Apollo.BaseMutationOptions<SetDeckCampaignMutation, SetDeckCampaignMutationVariables>;
export const RemoveDeckCampaignDocument = gql`
    mutation removeDeckCampaign($deckId: Int!, $campaignId: Int!) {
  campaign: rangers_remove_campaign_deck(
    args: {deck_id: $deckId, old_campaign_id: $campaignId}
  ) {
    id
  }
}
    `;
export type RemoveDeckCampaignMutationFn = Apollo.MutationFunction<RemoveDeckCampaignMutation, RemoveDeckCampaignMutationVariables>;

/**
 * __useRemoveDeckCampaignMutation__
 *
 * To run a mutation, you first call `useRemoveDeckCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveDeckCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeDeckCampaignMutation, { data, loading, error }] = useRemoveDeckCampaignMutation({
 *   variables: {
 *      deckId: // value for 'deckId'
 *      campaignId: // value for 'campaignId'
 *   },
 * });
 */
export function useRemoveDeckCampaignMutation(baseOptions?: Apollo.MutationHookOptions<RemoveDeckCampaignMutation, RemoveDeckCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveDeckCampaignMutation, RemoveDeckCampaignMutationVariables>(RemoveDeckCampaignDocument, options);
      }
export type RemoveDeckCampaignMutationHookResult = ReturnType<typeof useRemoveDeckCampaignMutation>;
export type RemoveDeckCampaignMutationResult = Apollo.MutationResult<RemoveDeckCampaignMutation>;
export type RemoveDeckCampaignMutationOptions = Apollo.BaseMutationOptions<RemoveDeckCampaignMutation, RemoveDeckCampaignMutationVariables>;
export const GetMyCampaignDecksDocument = gql`
    query getMyCampaignDecks($userId: String!, $limit: Int!, $offset: Int!) {
  decks: rangers_deck(
    where: {user_id: {_eq: $userId}, next_deck_id: {_is_null: true}, campaign_id: {_is_null: true}}
    order_by: {updated_at: desc}
    limit: $limit
    offset: $offset
  ) {
    ...Deck
  }
}
    ${DeckFragmentDoc}`;

/**
 * __useGetMyCampaignDecksQuery__
 *
 * To run a query within a React component, call `useGetMyCampaignDecksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMyCampaignDecksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMyCampaignDecksQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetMyCampaignDecksQuery(baseOptions: Apollo.QueryHookOptions<GetMyCampaignDecksQuery, GetMyCampaignDecksQueryVariables> & ({ variables: GetMyCampaignDecksQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMyCampaignDecksQuery, GetMyCampaignDecksQueryVariables>(GetMyCampaignDecksDocument, options);
      }
export function useGetMyCampaignDecksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMyCampaignDecksQuery, GetMyCampaignDecksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMyCampaignDecksQuery, GetMyCampaignDecksQueryVariables>(GetMyCampaignDecksDocument, options);
        }
export function useGetMyCampaignDecksSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMyCampaignDecksQuery, GetMyCampaignDecksQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMyCampaignDecksQuery, GetMyCampaignDecksQueryVariables>(GetMyCampaignDecksDocument, options);
        }
export type GetMyCampaignDecksQueryHookResult = ReturnType<typeof useGetMyCampaignDecksQuery>;
export type GetMyCampaignDecksLazyQueryHookResult = ReturnType<typeof useGetMyCampaignDecksLazyQuery>;
export type GetMyCampaignDecksSuspenseQueryHookResult = ReturnType<typeof useGetMyCampaignDecksSuspenseQuery>;
export type GetMyCampaignDecksQueryResult = Apollo.QueryResult<GetMyCampaignDecksQuery, GetMyCampaignDecksQueryVariables>;
export const GetMyCampaignDecksTotalDocument = gql`
    query getMyCampaignDecksTotal($userId: String!) {
  total: rangers_deck_aggregate(
    where: {user_id: {_eq: $userId}, next_deck_id: {_is_null: true}, campaign_id: {_is_null: true}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetMyCampaignDecksTotalQuery__
 *
 * To run a query within a React component, call `useGetMyCampaignDecksTotalQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMyCampaignDecksTotalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMyCampaignDecksTotalQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetMyCampaignDecksTotalQuery(baseOptions: Apollo.QueryHookOptions<GetMyCampaignDecksTotalQuery, GetMyCampaignDecksTotalQueryVariables> & ({ variables: GetMyCampaignDecksTotalQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMyCampaignDecksTotalQuery, GetMyCampaignDecksTotalQueryVariables>(GetMyCampaignDecksTotalDocument, options);
      }
export function useGetMyCampaignDecksTotalLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMyCampaignDecksTotalQuery, GetMyCampaignDecksTotalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMyCampaignDecksTotalQuery, GetMyCampaignDecksTotalQueryVariables>(GetMyCampaignDecksTotalDocument, options);
        }
export function useGetMyCampaignDecksTotalSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMyCampaignDecksTotalQuery, GetMyCampaignDecksTotalQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMyCampaignDecksTotalQuery, GetMyCampaignDecksTotalQueryVariables>(GetMyCampaignDecksTotalDocument, options);
        }
export type GetMyCampaignDecksTotalQueryHookResult = ReturnType<typeof useGetMyCampaignDecksTotalQuery>;
export type GetMyCampaignDecksTotalLazyQueryHookResult = ReturnType<typeof useGetMyCampaignDecksTotalLazyQuery>;
export type GetMyCampaignDecksTotalSuspenseQueryHookResult = ReturnType<typeof useGetMyCampaignDecksTotalSuspenseQuery>;
export type GetMyCampaignDecksTotalQueryResult = Apollo.QueryResult<GetMyCampaignDecksTotalQuery, GetMyCampaignDecksTotalQueryVariables>;
export const SearchDecksDocument = gql`
    query searchDecks($userId: String, $foc: Int, $spi: Int, $awa: Int, $fit: Int, $background: _text, $specialty: _text, $role: _text, $taboo_set_id: _text, $limit: Int, $offset: Int) {
  decks: rangers_deck_search(
    args: {user_id_eq: $userId, foc_eq: $foc, spi_eq: $spi, awa_eq: $awa, fit_eq: $fit, background: $background, specialty: $specialty, _taboo_set_id: $taboo_set_id, role: $role, _limit: $limit, _offset: $offset}
  ) {
    ...SearchDeck
  }
}
    ${SearchDeckFragmentDoc}`;

/**
 * __useSearchDecksQuery__
 *
 * To run a query within a React component, call `useSearchDecksQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchDecksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchDecksQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      foc: // value for 'foc'
 *      spi: // value for 'spi'
 *      awa: // value for 'awa'
 *      fit: // value for 'fit'
 *      background: // value for 'background'
 *      specialty: // value for 'specialty'
 *      role: // value for 'role'
 *      taboo_set_id: // value for 'taboo_set_id'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useSearchDecksQuery(baseOptions?: Apollo.QueryHookOptions<SearchDecksQuery, SearchDecksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchDecksQuery, SearchDecksQueryVariables>(SearchDecksDocument, options);
      }
export function useSearchDecksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchDecksQuery, SearchDecksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchDecksQuery, SearchDecksQueryVariables>(SearchDecksDocument, options);
        }
export function useSearchDecksSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SearchDecksQuery, SearchDecksQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchDecksQuery, SearchDecksQueryVariables>(SearchDecksDocument, options);
        }
export type SearchDecksQueryHookResult = ReturnType<typeof useSearchDecksQuery>;
export type SearchDecksLazyQueryHookResult = ReturnType<typeof useSearchDecksLazyQuery>;
export type SearchDecksSuspenseQueryHookResult = ReturnType<typeof useSearchDecksSuspenseQuery>;
export type SearchDecksQueryResult = Apollo.QueryResult<SearchDecksQuery, SearchDecksQueryVariables>;
export const GetMyDecksDocument = gql`
    query getMyDecks($userId: String!, $limit: Int!, $offset: Int!) {
  decks: rangers_deck(
    where: {user_id: {_eq: $userId}, next_deck_id: {_is_null: true}, _or: [{published: {_is_null: true}}, {published: {_eq: false}}]}
    order_by: {updated_at: desc}
    limit: $limit
    offset: $offset
  ) {
    ...DeckWithCampaign
  }
}
    ${DeckWithCampaignFragmentDoc}`;

/**
 * __useGetMyDecksQuery__
 *
 * To run a query within a React component, call `useGetMyDecksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMyDecksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMyDecksQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetMyDecksQuery(baseOptions: Apollo.QueryHookOptions<GetMyDecksQuery, GetMyDecksQueryVariables> & ({ variables: GetMyDecksQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMyDecksQuery, GetMyDecksQueryVariables>(GetMyDecksDocument, options);
      }
export function useGetMyDecksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMyDecksQuery, GetMyDecksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMyDecksQuery, GetMyDecksQueryVariables>(GetMyDecksDocument, options);
        }
export function useGetMyDecksSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMyDecksQuery, GetMyDecksQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMyDecksQuery, GetMyDecksQueryVariables>(GetMyDecksDocument, options);
        }
export type GetMyDecksQueryHookResult = ReturnType<typeof useGetMyDecksQuery>;
export type GetMyDecksLazyQueryHookResult = ReturnType<typeof useGetMyDecksLazyQuery>;
export type GetMyDecksSuspenseQueryHookResult = ReturnType<typeof useGetMyDecksSuspenseQuery>;
export type GetMyDecksQueryResult = Apollo.QueryResult<GetMyDecksQuery, GetMyDecksQueryVariables>;
export const GetMyDecksTotalDocument = gql`
    query getMyDecksTotal($userId: String!) {
  total: rangers_deck_aggregate(
    where: {user_id: {_eq: $userId}, next_deck_id: {_is_null: true}, _or: [{published: {_is_null: true}}, {published: {_eq: false}}]}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetMyDecksTotalQuery__
 *
 * To run a query within a React component, call `useGetMyDecksTotalQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMyDecksTotalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMyDecksTotalQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetMyDecksTotalQuery(baseOptions: Apollo.QueryHookOptions<GetMyDecksTotalQuery, GetMyDecksTotalQueryVariables> & ({ variables: GetMyDecksTotalQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMyDecksTotalQuery, GetMyDecksTotalQueryVariables>(GetMyDecksTotalDocument, options);
      }
export function useGetMyDecksTotalLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMyDecksTotalQuery, GetMyDecksTotalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMyDecksTotalQuery, GetMyDecksTotalQueryVariables>(GetMyDecksTotalDocument, options);
        }
export function useGetMyDecksTotalSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMyDecksTotalQuery, GetMyDecksTotalQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMyDecksTotalQuery, GetMyDecksTotalQueryVariables>(GetMyDecksTotalDocument, options);
        }
export type GetMyDecksTotalQueryHookResult = ReturnType<typeof useGetMyDecksTotalQuery>;
export type GetMyDecksTotalLazyQueryHookResult = ReturnType<typeof useGetMyDecksTotalLazyQuery>;
export type GetMyDecksTotalSuspenseQueryHookResult = ReturnType<typeof useGetMyDecksTotalSuspenseQuery>;
export type GetMyDecksTotalQueryResult = Apollo.QueryResult<GetMyDecksTotalQuery, GetMyDecksTotalQueryVariables>;
export const GetDeckDocument = gql`
    query getDeck($deckId: Int!) {
  deck: rangers_deck_by_pk(id: $deckId) {
    ...DeckDetail
  }
}
    ${DeckDetailFragmentDoc}`;

/**
 * __useGetDeckQuery__
 *
 * To run a query within a React component, call `useGetDeckQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDeckQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDeckQuery({
 *   variables: {
 *      deckId: // value for 'deckId'
 *   },
 * });
 */
export function useGetDeckQuery(baseOptions: Apollo.QueryHookOptions<GetDeckQuery, GetDeckQueryVariables> & ({ variables: GetDeckQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDeckQuery, GetDeckQueryVariables>(GetDeckDocument, options);
      }
export function useGetDeckLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDeckQuery, GetDeckQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDeckQuery, GetDeckQueryVariables>(GetDeckDocument, options);
        }
export function useGetDeckSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetDeckQuery, GetDeckQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetDeckQuery, GetDeckQueryVariables>(GetDeckDocument, options);
        }
export type GetDeckQueryHookResult = ReturnType<typeof useGetDeckQuery>;
export type GetDeckLazyQueryHookResult = ReturnType<typeof useGetDeckLazyQuery>;
export type GetDeckSuspenseQueryHookResult = ReturnType<typeof useGetDeckSuspenseQuery>;
export type GetDeckQueryResult = Apollo.QueryResult<GetDeckQuery, GetDeckQueryVariables>;
export const GetDeckCommentsDocument = gql`
    query getDeckComments($deckId: Int!, $limit: Int!, $offset: Int!) {
  rangers_comment(
    where: {deck_id: {_eq: $deckId}, comment_id: {_is_null: true}}
    order_by: {created_at: desc}
    offset: $offset
    limit: $limit
  ) {
    ...DeckComment
  }
}
    ${DeckCommentFragmentDoc}`;

/**
 * __useGetDeckCommentsQuery__
 *
 * To run a query within a React component, call `useGetDeckCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDeckCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDeckCommentsQuery({
 *   variables: {
 *      deckId: // value for 'deckId'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetDeckCommentsQuery(baseOptions: Apollo.QueryHookOptions<GetDeckCommentsQuery, GetDeckCommentsQueryVariables> & ({ variables: GetDeckCommentsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDeckCommentsQuery, GetDeckCommentsQueryVariables>(GetDeckCommentsDocument, options);
      }
export function useGetDeckCommentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDeckCommentsQuery, GetDeckCommentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDeckCommentsQuery, GetDeckCommentsQueryVariables>(GetDeckCommentsDocument, options);
        }
export function useGetDeckCommentsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetDeckCommentsQuery, GetDeckCommentsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetDeckCommentsQuery, GetDeckCommentsQueryVariables>(GetDeckCommentsDocument, options);
        }
export type GetDeckCommentsQueryHookResult = ReturnType<typeof useGetDeckCommentsQuery>;
export type GetDeckCommentsLazyQueryHookResult = ReturnType<typeof useGetDeckCommentsLazyQuery>;
export type GetDeckCommentsSuspenseQueryHookResult = ReturnType<typeof useGetDeckCommentsSuspenseQuery>;
export type GetDeckCommentsQueryResult = Apollo.QueryResult<GetDeckCommentsQuery, GetDeckCommentsQueryVariables>;
export const GetResponseCommentsDocument = gql`
    query getResponseComments($commentId: uuid!, $limit: Int!, $offset: Int!) {
  rangers_comment(
    where: {comment_id: {_eq: $commentId}}
    order_by: {created_at: desc}
    offset: $offset
    limit: $limit
  ) {
    ...DeckComment
  }
}
    ${DeckCommentFragmentDoc}`;

/**
 * __useGetResponseCommentsQuery__
 *
 * To run a query within a React component, call `useGetResponseCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetResponseCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetResponseCommentsQuery({
 *   variables: {
 *      commentId: // value for 'commentId'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetResponseCommentsQuery(baseOptions: Apollo.QueryHookOptions<GetResponseCommentsQuery, GetResponseCommentsQueryVariables> & ({ variables: GetResponseCommentsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetResponseCommentsQuery, GetResponseCommentsQueryVariables>(GetResponseCommentsDocument, options);
      }
export function useGetResponseCommentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetResponseCommentsQuery, GetResponseCommentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetResponseCommentsQuery, GetResponseCommentsQueryVariables>(GetResponseCommentsDocument, options);
        }
export function useGetResponseCommentsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetResponseCommentsQuery, GetResponseCommentsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetResponseCommentsQuery, GetResponseCommentsQueryVariables>(GetResponseCommentsDocument, options);
        }
export type GetResponseCommentsQueryHookResult = ReturnType<typeof useGetResponseCommentsQuery>;
export type GetResponseCommentsLazyQueryHookResult = ReturnType<typeof useGetResponseCommentsLazyQuery>;
export type GetResponseCommentsSuspenseQueryHookResult = ReturnType<typeof useGetResponseCommentsSuspenseQuery>;
export type GetResponseCommentsQueryResult = Apollo.QueryResult<GetResponseCommentsQuery, GetResponseCommentsQueryVariables>;
export const PostCommentDocument = gql`
    mutation postComment($deckId: Int!, $text: String!, $commentId: uuid) {
  insert_rangers_comment_one(
    object: {deck_id: $deckId, text: $text, comment_id: $commentId}
  ) {
    ...BasicDeckComment
    comment_id
    deck_id
  }
}
    ${BasicDeckCommentFragmentDoc}`;
export type PostCommentMutationFn = Apollo.MutationFunction<PostCommentMutation, PostCommentMutationVariables>;

/**
 * __usePostCommentMutation__
 *
 * To run a mutation, you first call `usePostCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePostCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [postCommentMutation, { data, loading, error }] = usePostCommentMutation({
 *   variables: {
 *      deckId: // value for 'deckId'
 *      text: // value for 'text'
 *      commentId: // value for 'commentId'
 *   },
 * });
 */
export function usePostCommentMutation(baseOptions?: Apollo.MutationHookOptions<PostCommentMutation, PostCommentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PostCommentMutation, PostCommentMutationVariables>(PostCommentDocument, options);
      }
export type PostCommentMutationHookResult = ReturnType<typeof usePostCommentMutation>;
export type PostCommentMutationResult = Apollo.MutationResult<PostCommentMutation>;
export type PostCommentMutationOptions = Apollo.BaseMutationOptions<PostCommentMutation, PostCommentMutationVariables>;
export const EditCommentDocument = gql`
    mutation editComment($id: uuid!, $text: String!) {
  update_rangers_comment_by_pk(pk_columns: {id: $id}, _set: {text: $text}) {
    id
    text
    updated_at
  }
}
    `;
export type EditCommentMutationFn = Apollo.MutationFunction<EditCommentMutation, EditCommentMutationVariables>;

/**
 * __useEditCommentMutation__
 *
 * To run a mutation, you first call `useEditCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editCommentMutation, { data, loading, error }] = useEditCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      text: // value for 'text'
 *   },
 * });
 */
export function useEditCommentMutation(baseOptions?: Apollo.MutationHookOptions<EditCommentMutation, EditCommentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditCommentMutation, EditCommentMutationVariables>(EditCommentDocument, options);
      }
export type EditCommentMutationHookResult = ReturnType<typeof useEditCommentMutation>;
export type EditCommentMutationResult = Apollo.MutationResult<EditCommentMutation>;
export type EditCommentMutationOptions = Apollo.BaseMutationOptions<EditCommentMutation, EditCommentMutationVariables>;
export const CreateDeckDocument = gql`
    mutation createDeck($name: String!, $foc: Int!, $fit: Int!, $awa: Int!, $spi: Int!, $meta: jsonb!, $slots: jsonb!, $extraSlots: jsonb!, $description: String, $tabooSetId: String) {
  deck: insert_rangers_deck_one(
    object: {name: $name, foc: $foc, fit: $fit, awa: $awa, spi: $spi, meta: $meta, slots: $slots, extra_slots: $extraSlots, description: $description, taboo_set_id: $tabooSetId}
  ) {
    ...Deck
  }
}
    ${DeckFragmentDoc}`;
export type CreateDeckMutationFn = Apollo.MutationFunction<CreateDeckMutation, CreateDeckMutationVariables>;

/**
 * __useCreateDeckMutation__
 *
 * To run a mutation, you first call `useCreateDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeckMutation, { data, loading, error }] = useCreateDeckMutation({
 *   variables: {
 *      name: // value for 'name'
 *      foc: // value for 'foc'
 *      fit: // value for 'fit'
 *      awa: // value for 'awa'
 *      spi: // value for 'spi'
 *      meta: // value for 'meta'
 *      slots: // value for 'slots'
 *      extraSlots: // value for 'extraSlots'
 *      description: // value for 'description'
 *      tabooSetId: // value for 'tabooSetId'
 *   },
 * });
 */
export function useCreateDeckMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeckMutation, CreateDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDeckMutation, CreateDeckMutationVariables>(CreateDeckDocument, options);
      }
export type CreateDeckMutationHookResult = ReturnType<typeof useCreateDeckMutation>;
export type CreateDeckMutationResult = Apollo.MutationResult<CreateDeckMutation>;
export type CreateDeckMutationOptions = Apollo.BaseMutationOptions<CreateDeckMutation, CreateDeckMutationVariables>;
export const CloneDeckDocument = gql`
    mutation cloneDeck($originalDeckId: Int!, $newDeckId: Int!) {
  deck: insert_rangers_deck_copy_one(
    object: {deck_id: $originalDeckId, copy_deck_id: $newDeckId}
  ) {
    user_id
    deck_id
    copy_deck_id
  }
}
    `;
export type CloneDeckMutationFn = Apollo.MutationFunction<CloneDeckMutation, CloneDeckMutationVariables>;

/**
 * __useCloneDeckMutation__
 *
 * To run a mutation, you first call `useCloneDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCloneDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cloneDeckMutation, { data, loading, error }] = useCloneDeckMutation({
 *   variables: {
 *      originalDeckId: // value for 'originalDeckId'
 *      newDeckId: // value for 'newDeckId'
 *   },
 * });
 */
export function useCloneDeckMutation(baseOptions?: Apollo.MutationHookOptions<CloneDeckMutation, CloneDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CloneDeckMutation, CloneDeckMutationVariables>(CloneDeckDocument, options);
      }
export type CloneDeckMutationHookResult = ReturnType<typeof useCloneDeckMutation>;
export type CloneDeckMutationResult = Apollo.MutationResult<CloneDeckMutation>;
export type CloneDeckMutationOptions = Apollo.BaseMutationOptions<CloneDeckMutation, CloneDeckMutationVariables>;
export const DeleteDeckDocument = gql`
    mutation deleteDeck($id: Int!) {
  delete_rangers_deck_by_pk(id: $id) {
    id
  }
}
    `;
export type DeleteDeckMutationFn = Apollo.MutationFunction<DeleteDeckMutation, DeleteDeckMutationVariables>;

/**
 * __useDeleteDeckMutation__
 *
 * To run a mutation, you first call `useDeleteDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteDeckMutation, { data, loading, error }] = useDeleteDeckMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteDeckMutation(baseOptions?: Apollo.MutationHookOptions<DeleteDeckMutation, DeleteDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteDeckMutation, DeleteDeckMutationVariables>(DeleteDeckDocument, options);
      }
export type DeleteDeckMutationHookResult = ReturnType<typeof useDeleteDeckMutation>;
export type DeleteDeckMutationResult = Apollo.MutationResult<DeleteDeckMutation>;
export type DeleteDeckMutationOptions = Apollo.BaseMutationOptions<DeleteDeckMutation, DeleteDeckMutationVariables>;
export const SaveDeckDocument = gql`
    mutation saveDeck($id: Int!, $name: String!, $foc: Int!, $fit: Int!, $awa: Int!, $spi: Int!, $meta: jsonb!, $slots: jsonb!, $sideSlots: jsonb!, $extraSlots: jsonb!, $tabooSetId: String) {
  update_rangers_deck_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, foc: $foc, fit: $fit, awa: $awa, spi: $spi, meta: $meta, slots: $slots, side_slots: $sideSlots, extra_slots: $extraSlots, taboo_set_id: $tabooSetId}
  ) {
    ...Deck
  }
}
    ${DeckFragmentDoc}`;
export type SaveDeckMutationFn = Apollo.MutationFunction<SaveDeckMutation, SaveDeckMutationVariables>;

/**
 * __useSaveDeckMutation__
 *
 * To run a mutation, you first call `useSaveDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveDeckMutation, { data, loading, error }] = useSaveDeckMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      foc: // value for 'foc'
 *      fit: // value for 'fit'
 *      awa: // value for 'awa'
 *      spi: // value for 'spi'
 *      meta: // value for 'meta'
 *      slots: // value for 'slots'
 *      sideSlots: // value for 'sideSlots'
 *      extraSlots: // value for 'extraSlots'
 *      tabooSetId: // value for 'tabooSetId'
 *   },
 * });
 */
export function useSaveDeckMutation(baseOptions?: Apollo.MutationHookOptions<SaveDeckMutation, SaveDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveDeckMutation, SaveDeckMutationVariables>(SaveDeckDocument, options);
      }
export type SaveDeckMutationHookResult = ReturnType<typeof useSaveDeckMutation>;
export type SaveDeckMutationResult = Apollo.MutationResult<SaveDeckMutation>;
export type SaveDeckMutationOptions = Apollo.BaseMutationOptions<SaveDeckMutation, SaveDeckMutationVariables>;
export const SaveDeckTabooSetDocument = gql`
    mutation saveDeckTabooSet($id: Int!, $tabooSetId: String) {
  update_rangers_deck_by_pk(
    pk_columns: {id: $id}
    _set: {taboo_set_id: $tabooSetId}
  ) {
    id
    taboo_set_id
  }
}
    `;
export type SaveDeckTabooSetMutationFn = Apollo.MutationFunction<SaveDeckTabooSetMutation, SaveDeckTabooSetMutationVariables>;

/**
 * __useSaveDeckTabooSetMutation__
 *
 * To run a mutation, you first call `useSaveDeckTabooSetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveDeckTabooSetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveDeckTabooSetMutation, { data, loading, error }] = useSaveDeckTabooSetMutation({
 *   variables: {
 *      id: // value for 'id'
 *      tabooSetId: // value for 'tabooSetId'
 *   },
 * });
 */
export function useSaveDeckTabooSetMutation(baseOptions?: Apollo.MutationHookOptions<SaveDeckTabooSetMutation, SaveDeckTabooSetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveDeckTabooSetMutation, SaveDeckTabooSetMutationVariables>(SaveDeckTabooSetDocument, options);
      }
export type SaveDeckTabooSetMutationHookResult = ReturnType<typeof useSaveDeckTabooSetMutation>;
export type SaveDeckTabooSetMutationResult = Apollo.MutationResult<SaveDeckTabooSetMutation>;
export type SaveDeckTabooSetMutationOptions = Apollo.BaseMutationOptions<SaveDeckTabooSetMutation, SaveDeckTabooSetMutationVariables>;
export const SaveDeckDescriptionDocument = gql`
    mutation saveDeckDescription($id: Int!, $description: String!) {
  update_rangers_deck_by_pk(
    pk_columns: {id: $id}
    _set: {description: $description}
  ) {
    id
    description
  }
}
    `;
export type SaveDeckDescriptionMutationFn = Apollo.MutationFunction<SaveDeckDescriptionMutation, SaveDeckDescriptionMutationVariables>;

/**
 * __useSaveDeckDescriptionMutation__
 *
 * To run a mutation, you first call `useSaveDeckDescriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveDeckDescriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveDeckDescriptionMutation, { data, loading, error }] = useSaveDeckDescriptionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      description: // value for 'description'
 *   },
 * });
 */
export function useSaveDeckDescriptionMutation(baseOptions?: Apollo.MutationHookOptions<SaveDeckDescriptionMutation, SaveDeckDescriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveDeckDescriptionMutation, SaveDeckDescriptionMutationVariables>(SaveDeckDescriptionDocument, options);
      }
export type SaveDeckDescriptionMutationHookResult = ReturnType<typeof useSaveDeckDescriptionMutation>;
export type SaveDeckDescriptionMutationResult = Apollo.MutationResult<SaveDeckDescriptionMutation>;
export type SaveDeckDescriptionMutationOptions = Apollo.BaseMutationOptions<SaveDeckDescriptionMutation, SaveDeckDescriptionMutationVariables>;
export const LikeDeckDocument = gql`
    mutation likeDeck($deckId: Int!) {
  insert_rangers_deck_like_one(
    object: {deck_id: $deckId, liked: true}
    on_conflict: {constraint: deck_likes_pkey, update_columns: [liked]}
  ) {
    user_id
    deck_id
    liked
  }
}
    `;
export type LikeDeckMutationFn = Apollo.MutationFunction<LikeDeckMutation, LikeDeckMutationVariables>;

/**
 * __useLikeDeckMutation__
 *
 * To run a mutation, you first call `useLikeDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLikeDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [likeDeckMutation, { data, loading, error }] = useLikeDeckMutation({
 *   variables: {
 *      deckId: // value for 'deckId'
 *   },
 * });
 */
export function useLikeDeckMutation(baseOptions?: Apollo.MutationHookOptions<LikeDeckMutation, LikeDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LikeDeckMutation, LikeDeckMutationVariables>(LikeDeckDocument, options);
      }
export type LikeDeckMutationHookResult = ReturnType<typeof useLikeDeckMutation>;
export type LikeDeckMutationResult = Apollo.MutationResult<LikeDeckMutation>;
export type LikeDeckMutationOptions = Apollo.BaseMutationOptions<LikeDeckMutation, LikeDeckMutationVariables>;
export const UnlikeDeckDocument = gql`
    mutation unlikeDeck($userId: String!, $deckId: Int!) {
  update_rangers_deck_like_by_pk(
    pk_columns: {deck_id: $deckId, user_id: $userId}
    _set: {liked: false}
  ) {
    user_id
    deck_id
    liked
  }
}
    `;
export type UnlikeDeckMutationFn = Apollo.MutationFunction<UnlikeDeckMutation, UnlikeDeckMutationVariables>;

/**
 * __useUnlikeDeckMutation__
 *
 * To run a mutation, you first call `useUnlikeDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnlikeDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unlikeDeckMutation, { data, loading, error }] = useUnlikeDeckMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      deckId: // value for 'deckId'
 *   },
 * });
 */
export function useUnlikeDeckMutation(baseOptions?: Apollo.MutationHookOptions<UnlikeDeckMutation, UnlikeDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnlikeDeckMutation, UnlikeDeckMutationVariables>(UnlikeDeckDocument, options);
      }
export type UnlikeDeckMutationHookResult = ReturnType<typeof useUnlikeDeckMutation>;
export type UnlikeDeckMutationResult = Apollo.MutationResult<UnlikeDeckMutation>;
export type UnlikeDeckMutationOptions = Apollo.BaseMutationOptions<UnlikeDeckMutation, UnlikeDeckMutationVariables>;
export const GetNavProfileDocument = gql`
    query getNavProfile($id: String!) {
  profile: rangers_users_by_pk(id: $id) {
    ...NavProfile
  }
}
    ${NavProfileFragmentDoc}`;

/**
 * __useGetNavProfileQuery__
 *
 * To run a query within a React component, call `useGetNavProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNavProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNavProfileQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetNavProfileQuery(baseOptions: Apollo.QueryHookOptions<GetNavProfileQuery, GetNavProfileQueryVariables> & ({ variables: GetNavProfileQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetNavProfileQuery, GetNavProfileQueryVariables>(GetNavProfileDocument, options);
      }
export function useGetNavProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNavProfileQuery, GetNavProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetNavProfileQuery, GetNavProfileQueryVariables>(GetNavProfileDocument, options);
        }
export function useGetNavProfileSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetNavProfileQuery, GetNavProfileQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetNavProfileQuery, GetNavProfileQueryVariables>(GetNavProfileDocument, options);
        }
export type GetNavProfileQueryHookResult = ReturnType<typeof useGetNavProfileQuery>;
export type GetNavProfileLazyQueryHookResult = ReturnType<typeof useGetNavProfileLazyQuery>;
export type GetNavProfileSuspenseQueryHookResult = ReturnType<typeof useGetNavProfileSuspenseQuery>;
export type GetNavProfileQueryResult = Apollo.QueryResult<GetNavProfileQuery, GetNavProfileQueryVariables>;
export const GetProfileDocument = gql`
    query getProfile($id: String!) {
  profile: rangers_users_by_pk(id: $id) {
    ...UserProfile
  }
  settings: rangers_user_settings_by_pk(user_id: $id) {
    user_id
    private_decks
    pack_collection
    adhere_taboos
  }
}
    ${UserProfileFragmentDoc}`;

/**
 * __useGetProfileQuery__
 *
 * To run a query within a React component, call `useGetProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProfileQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetProfileQuery(baseOptions: Apollo.QueryHookOptions<GetProfileQuery, GetProfileQueryVariables> & ({ variables: GetProfileQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProfileQuery, GetProfileQueryVariables>(GetProfileDocument, options);
      }
export function useGetProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProfileQuery, GetProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProfileQuery, GetProfileQueryVariables>(GetProfileDocument, options);
        }
export function useGetProfileSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProfileQuery, GetProfileQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProfileQuery, GetProfileQueryVariables>(GetProfileDocument, options);
        }
export type GetProfileQueryHookResult = ReturnType<typeof useGetProfileQuery>;
export type GetProfileLazyQueryHookResult = ReturnType<typeof useGetProfileLazyQuery>;
export type GetProfileSuspenseQueryHookResult = ReturnType<typeof useGetProfileSuspenseQuery>;
export type GetProfileQueryResult = Apollo.QueryResult<GetProfileQuery, GetProfileQueryVariables>;
export const GetProfileByHandleDocument = gql`
    query getProfileByHandle($handle: String!) {
  profile: rangers_users(where: {handle: {_ilike: $handle}}) {
    ...UserProfile
  }
}
    ${UserProfileFragmentDoc}`;

/**
 * __useGetProfileByHandleQuery__
 *
 * To run a query within a React component, call `useGetProfileByHandleQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProfileByHandleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProfileByHandleQuery({
 *   variables: {
 *      handle: // value for 'handle'
 *   },
 * });
 */
export function useGetProfileByHandleQuery(baseOptions: Apollo.QueryHookOptions<GetProfileByHandleQuery, GetProfileByHandleQueryVariables> & ({ variables: GetProfileByHandleQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProfileByHandleQuery, GetProfileByHandleQueryVariables>(GetProfileByHandleDocument, options);
      }
export function useGetProfileByHandleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProfileByHandleQuery, GetProfileByHandleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProfileByHandleQuery, GetProfileByHandleQueryVariables>(GetProfileByHandleDocument, options);
        }
export function useGetProfileByHandleSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProfileByHandleQuery, GetProfileByHandleQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProfileByHandleQuery, GetProfileByHandleQueryVariables>(GetProfileByHandleDocument, options);
        }
export type GetProfileByHandleQueryHookResult = ReturnType<typeof useGetProfileByHandleQuery>;
export type GetProfileByHandleLazyQueryHookResult = ReturnType<typeof useGetProfileByHandleLazyQuery>;
export type GetProfileByHandleSuspenseQueryHookResult = ReturnType<typeof useGetProfileByHandleSuspenseQuery>;
export type GetProfileByHandleQueryResult = Apollo.QueryResult<GetProfileByHandleQuery, GetProfileByHandleQueryVariables>;
export const UpdateFriendRequestDocument = gql`
    mutation updateFriendRequest($userId: String!, $action: String!) {
  rangers_update_friend_request(args: {target_user_id: $userId, action: $action}) {
    id
  }
}
    `;
export type UpdateFriendRequestMutationFn = Apollo.MutationFunction<UpdateFriendRequestMutation, UpdateFriendRequestMutationVariables>;

/**
 * __useUpdateFriendRequestMutation__
 *
 * To run a mutation, you first call `useUpdateFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFriendRequestMutation, { data, loading, error }] = useUpdateFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      action: // value for 'action'
 *   },
 * });
 */
export function useUpdateFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFriendRequestMutation, UpdateFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFriendRequestMutation, UpdateFriendRequestMutationVariables>(UpdateFriendRequestDocument, options);
      }
export type UpdateFriendRequestMutationHookResult = ReturnType<typeof useUpdateFriendRequestMutation>;
export type UpdateFriendRequestMutationResult = Apollo.MutationResult<UpdateFriendRequestMutation>;
export type UpdateFriendRequestMutationOptions = Apollo.BaseMutationOptions<UpdateFriendRequestMutation, UpdateFriendRequestMutationVariables>;
export const SetHandleDocument = gql`
    mutation setHandle($handle: String!) {
  rangers_set_handle(args: {handle: $handle}) {
    id
    handle
  }
}
    `;
export type SetHandleMutationFn = Apollo.MutationFunction<SetHandleMutation, SetHandleMutationVariables>;

/**
 * __useSetHandleMutation__
 *
 * To run a mutation, you first call `useSetHandleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetHandleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setHandleMutation, { data, loading, error }] = useSetHandleMutation({
 *   variables: {
 *      handle: // value for 'handle'
 *   },
 * });
 */
export function useSetHandleMutation(baseOptions?: Apollo.MutationHookOptions<SetHandleMutation, SetHandleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetHandleMutation, SetHandleMutationVariables>(SetHandleDocument, options);
      }
export type SetHandleMutationHookResult = ReturnType<typeof useSetHandleMutation>;
export type SetHandleMutationResult = Apollo.MutationResult<SetHandleMutation>;
export type SetHandleMutationOptions = Apollo.BaseMutationOptions<SetHandleMutation, SetHandleMutationVariables>;
export const SearchHandlesDocument = gql`
    query searchHandles($normalizedHandle: String!, $normalizedHandleStart: String!, $offset: Int) {
  startMatch: rangers_users(
    where: {normalized_handle: {_ilike: $normalizedHandleStart}}
    limit: 20
    offset: $offset
  ) {
    id
    handle
  }
  looseMatch: rangers_users(
    where: {normalized_handle: {_ilike: $normalizedHandle}}
    limit: 20
    offset: $offset
  ) {
    id
    handle
  }
}
    `;

/**
 * __useSearchHandlesQuery__
 *
 * To run a query within a React component, call `useSearchHandlesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchHandlesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchHandlesQuery({
 *   variables: {
 *      normalizedHandle: // value for 'normalizedHandle'
 *      normalizedHandleStart: // value for 'normalizedHandleStart'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useSearchHandlesQuery(baseOptions: Apollo.QueryHookOptions<SearchHandlesQuery, SearchHandlesQueryVariables> & ({ variables: SearchHandlesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchHandlesQuery, SearchHandlesQueryVariables>(SearchHandlesDocument, options);
      }
export function useSearchHandlesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchHandlesQuery, SearchHandlesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchHandlesQuery, SearchHandlesQueryVariables>(SearchHandlesDocument, options);
        }
export function useSearchHandlesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SearchHandlesQuery, SearchHandlesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchHandlesQuery, SearchHandlesQueryVariables>(SearchHandlesDocument, options);
        }
export type SearchHandlesQueryHookResult = ReturnType<typeof useSearchHandlesQuery>;
export type SearchHandlesLazyQueryHookResult = ReturnType<typeof useSearchHandlesLazyQuery>;
export type SearchHandlesSuspenseQueryHookResult = ReturnType<typeof useSearchHandlesSuspenseQuery>;
export type SearchHandlesQueryResult = Apollo.QueryResult<SearchHandlesQuery, SearchHandlesQueryVariables>;
export const GetPackCollectionDocument = gql`
    query getPackCollection($id: String!) {
  settings: rangers_user_settings_by_pk(user_id: $id) {
    pack_collection
    adhere_taboos
  }
}
    `;

/**
 * __useGetPackCollectionQuery__
 *
 * To run a query within a React component, call `useGetPackCollectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPackCollectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPackCollectionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetPackCollectionQuery(baseOptions: Apollo.QueryHookOptions<GetPackCollectionQuery, GetPackCollectionQueryVariables> & ({ variables: GetPackCollectionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPackCollectionQuery, GetPackCollectionQueryVariables>(GetPackCollectionDocument, options);
      }
export function useGetPackCollectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPackCollectionQuery, GetPackCollectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPackCollectionQuery, GetPackCollectionQueryVariables>(GetPackCollectionDocument, options);
        }
export function useGetPackCollectionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPackCollectionQuery, GetPackCollectionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPackCollectionQuery, GetPackCollectionQueryVariables>(GetPackCollectionDocument, options);
        }
export type GetPackCollectionQueryHookResult = ReturnType<typeof useGetPackCollectionQuery>;
export type GetPackCollectionLazyQueryHookResult = ReturnType<typeof useGetPackCollectionLazyQuery>;
export type GetPackCollectionSuspenseQueryHookResult = ReturnType<typeof useGetPackCollectionSuspenseQuery>;
export type GetPackCollectionQueryResult = Apollo.QueryResult<GetPackCollectionQuery, GetPackCollectionQueryVariables>;
export const SetPrivateDecksDocument = gql`
    mutation setPrivateDecks($userId: String!, $privateDecks: Boolean!) {
  update_rangers_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _set: {private_decks: $privateDecks}
  ) {
    user_id
    private_decks
  }
}
    `;
export type SetPrivateDecksMutationFn = Apollo.MutationFunction<SetPrivateDecksMutation, SetPrivateDecksMutationVariables>;

/**
 * __useSetPrivateDecksMutation__
 *
 * To run a mutation, you first call `useSetPrivateDecksMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetPrivateDecksMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setPrivateDecksMutation, { data, loading, error }] = useSetPrivateDecksMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      privateDecks: // value for 'privateDecks'
 *   },
 * });
 */
export function useSetPrivateDecksMutation(baseOptions?: Apollo.MutationHookOptions<SetPrivateDecksMutation, SetPrivateDecksMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetPrivateDecksMutation, SetPrivateDecksMutationVariables>(SetPrivateDecksDocument, options);
      }
export type SetPrivateDecksMutationHookResult = ReturnType<typeof useSetPrivateDecksMutation>;
export type SetPrivateDecksMutationResult = Apollo.MutationResult<SetPrivateDecksMutation>;
export type SetPrivateDecksMutationOptions = Apollo.BaseMutationOptions<SetPrivateDecksMutation, SetPrivateDecksMutationVariables>;
export const SetPackCollectionDocument = gql`
    mutation setPackCollection($userId: String!, $pack_collection: jsonb!) {
  update_rangers_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _set: {pack_collection: $pack_collection}
  ) {
    user_id
    pack_collection
  }
}
    `;
export type SetPackCollectionMutationFn = Apollo.MutationFunction<SetPackCollectionMutation, SetPackCollectionMutationVariables>;

/**
 * __useSetPackCollectionMutation__
 *
 * To run a mutation, you first call `useSetPackCollectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetPackCollectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setPackCollectionMutation, { data, loading, error }] = useSetPackCollectionMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      pack_collection: // value for 'pack_collection'
 *   },
 * });
 */
export function useSetPackCollectionMutation(baseOptions?: Apollo.MutationHookOptions<SetPackCollectionMutation, SetPackCollectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetPackCollectionMutation, SetPackCollectionMutationVariables>(SetPackCollectionDocument, options);
      }
export type SetPackCollectionMutationHookResult = ReturnType<typeof useSetPackCollectionMutation>;
export type SetPackCollectionMutationResult = Apollo.MutationResult<SetPackCollectionMutation>;
export type SetPackCollectionMutationOptions = Apollo.BaseMutationOptions<SetPackCollectionMutation, SetPackCollectionMutationVariables>;
export const SetAdhereTaboosDocument = gql`
    mutation setAdhereTaboos($userId: String!, $adhereTaboos: Boolean!) {
  update_rangers_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _set: {adhere_taboos: $adhereTaboos}
  ) {
    user_id
    adhere_taboos
  }
}
    `;
export type SetAdhereTaboosMutationFn = Apollo.MutationFunction<SetAdhereTaboosMutation, SetAdhereTaboosMutationVariables>;

/**
 * __useSetAdhereTaboosMutation__
 *
 * To run a mutation, you first call `useSetAdhereTaboosMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetAdhereTaboosMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setAdhereTaboosMutation, { data, loading, error }] = useSetAdhereTaboosMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      adhereTaboos: // value for 'adhereTaboos'
 *   },
 * });
 */
export function useSetAdhereTaboosMutation(baseOptions?: Apollo.MutationHookOptions<SetAdhereTaboosMutation, SetAdhereTaboosMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetAdhereTaboosMutation, SetAdhereTaboosMutationVariables>(SetAdhereTaboosDocument, options);
      }
export type SetAdhereTaboosMutationHookResult = ReturnType<typeof useSetAdhereTaboosMutation>;
export type SetAdhereTaboosMutationResult = Apollo.MutationResult<SetAdhereTaboosMutation>;
export type SetAdhereTaboosMutationOptions = Apollo.BaseMutationOptions<SetAdhereTaboosMutation, SetAdhereTaboosMutationVariables>;

      export interface PossibleTypesResultData {
        possibleTypes: {
          [key: string]: string[]
        }
      }
      const result: PossibleTypesResultData = {
  "possibleTypes": {}
};
      export default result;
    